"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/firebase";
exports.ids = ["vendor-chunks/firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/firebase/analytics/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/firebase/analytics/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalytics: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.getAnalytics),\n/* harmony export */   getGoogleAnalyticsClientId: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.getGoogleAnalyticsClientId),\n/* harmony export */   initializeAnalytics: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.initializeAnalytics),\n/* harmony export */   isSupported: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.isSupported),\n/* harmony export */   logEvent: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.logEvent),\n/* harmony export */   setAnalyticsCollectionEnabled: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setAnalyticsCollectionEnabled),\n/* harmony export */   setConsent: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setConsent),\n/* harmony export */   setCurrentScreen: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setCurrentScreen),\n/* harmony export */   setDefaultEventParameters: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setDefaultEventParameters),\n/* harmony export */   setUserId: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setUserId),\n/* harmony export */   setUserProperties: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setUserProperties),\n/* harmony export */   settings: () => (/* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.settings)\n/* harmony export */ });\n/* harmony import */ var _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/analytics */ \"(ssr)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js\");\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYW5hbHl0aWNzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sb3ZlbW9uZXktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYW5hbHl0aWNzL2Rpc3QvaW5kZXgubWpzP2IwOTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FuYWx5dGljcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/analytics/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/app/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/firebase/app/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._apps),\n/* harmony export */   _clearComponents: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._clearComponents),\n/* harmony export */   _components: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._components),\n/* harmony export */   _getProvider: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._serverApps),\n/* harmony export */   deleteApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.deleteApp),\n/* harmony export */   getApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp),\n/* harmony export */   getApps: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps),\n/* harmony export */   initializeApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp),\n/* harmony export */   initializeServerApp: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeServerApp),\n/* harmony export */   onLog: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.onLog),\n/* harmony export */   registerVersion: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n\n\n\nvar name = \"firebase\";\nvar version = \"11.9.1\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'app');\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ2xCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2xvdmVtb25leS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvZGlzdC9pbmRleC5tanM/MmIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuXG52YXIgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbnZhciB2ZXJzaW9uID0gXCIxMS45LjFcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnYXBwJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/app/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/auth/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/firebase/auth/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ActionCodeOperation),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ActionCodeURL),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.AuthCredential),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.AuthErrorCodes),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.EmailAuthCredential),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.EmailAuthProvider),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.FacebookAuthProvider),\n/* harmony export */   FactorId: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.FactorId),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.GithubAuthProvider),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.GoogleAuthProvider),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OAuthCredential),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OAuthProvider),\n/* harmony export */   OperationType: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.OperationType),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneAuthCredential),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneAuthProvider),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.PhoneMultiFactorGenerator),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.ProviderId),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.RecaptchaVerifier),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.SAMLAuthProvider),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.SignInMethod),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TotpMultiFactorGenerator),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TotpSecret),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.TwitterAuthProvider),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.applyActionCode),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.beforeAuthStateChanged),\n/* harmony export */   browserCookiePersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserCookiePersistence),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserLocalPersistence),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserPopupRedirectResolver),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.browserSessionPersistence),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.checkActionCode),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.confirmPasswordReset),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.connectAuthEmulator),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.createUserWithEmailAndPassword),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.debugErrorMap),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.deleteUser),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.fetchSignInMethodsForEmail),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getAdditionalUserInfo),\n/* harmony export */   getAuth: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getAuth),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getIdToken),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getIdTokenResult),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getMultiFactorResolver),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.getRedirectResult),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.inMemoryPersistence),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.indexedDBLocalPersistence),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.initializeAuth),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.initializeRecaptchaConfig),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.isSignInWithEmailLink),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithCredential),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithPhoneNumber),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithPopup),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.linkWithRedirect),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.multiFactor),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.onAuthStateChanged),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.onIdTokenChanged),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.parseActionCodeURL),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.prodErrorMap),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithCredential),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithPhoneNumber),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithPopup),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reauthenticateWithRedirect),\n/* harmony export */   reload: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.reload),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.revokeAccessToken),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendEmailVerification),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendPasswordResetEmail),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.sendSignInLinkToEmail),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.setPersistence),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInAnonymously),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithCredential),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithCustomToken),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithEmailAndPassword),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithEmailLink),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithPhoneNumber),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithPopup),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signInWithRedirect),\n/* harmony export */   signOut: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.signOut),\n/* harmony export */   unlink: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.unlink),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateCurrentUser),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateEmail),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updatePassword),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updatePhoneNumber),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.updateProfile),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.useDeviceLanguage),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.validatePassword),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.verifyBeforeUpdateEmail),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _firebase_auth__WEBPACK_IMPORTED_MODULE_0__.verifyPasswordResetCode)\n/* harmony export */ });\n/* harmony import */ var _firebase_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/auth */ \"(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js\");\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXV0aC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xvdmVtb25leS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hdXRoL2Rpc3QvaW5kZXgubWpzP2NkZGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2F1dGgnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/auth/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/firestore/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/firebase/firestore/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.CollectionReference),\n/* harmony export */   DocumentReference: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FieldPath),\n/* harmony export */   FieldValue: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FieldValue),\n/* harmony export */   Firestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Firestore),\n/* harmony export */   FirestoreError: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.FirestoreError),\n/* harmony export */   GeoPoint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Timestamp),\n/* harmony export */   Transaction: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.Transaction),\n/* harmony export */   VectorValue: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.VectorValue),\n/* harmony export */   WriteBatch: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.WriteBatch),\n/* harmony export */   _AutoId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._AutoId),\n/* harmony export */   _ByteString: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._ByteString),\n/* harmony export */   _DatabaseId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._FieldPath),\n/* harmony export */   _TestingHooks: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._TestingHooks),\n/* harmony export */   _cast: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._cast),\n/* harmony export */   _debugAssert: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._isBase64Available),\n/* harmony export */   _logWarn: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__._validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.and),\n/* harmony export */   arrayRemove: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.arrayRemove),\n/* harmony export */   arrayUnion: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.arrayUnion),\n/* harmony export */   average: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection),\n/* harmony export */   collectionGroup: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.connectFirestoreEmulator),\n/* harmony export */   count: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc),\n/* harmony export */   deleteField: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteField),\n/* harmony export */   disableNetwork: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc),\n/* harmony export */   documentId: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.endAt),\n/* harmony export */   endBefore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getCountFromServer),\n/* harmony export */   getDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc),\n/* harmony export */   getDocFromCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocFromServer),\n/* harmony export */   getDocs: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs),\n/* harmony export */   getDocsFromCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.increment),\n/* harmony export */   initializeFirestore: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.initializeFirestore),\n/* harmony export */   limit: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limit),\n/* harmony export */   limitToLast: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.limitToLast),\n/* harmony export */   loadBundle: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.namedQuery),\n/* harmony export */   onSnapshot: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshotsInSync),\n/* harmony export */   or: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.or),\n/* harmony export */   orderBy: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy),\n/* harmony export */   persistentLocalCache: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.persistentSingleTabManager),\n/* harmony export */   query: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query),\n/* harmony export */   queryEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.queryEqual),\n/* harmony export */   refEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.refEqual),\n/* harmony export */   runTransaction: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.runTransaction),\n/* harmony export */   serverTimestamp: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),\n/* harmony export */   setDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.snapshotEqual),\n/* harmony export */   startAfter: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.startAfter),\n/* harmony export */   startAt: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.startAt),\n/* harmony export */   sum: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.sum),\n/* harmony export */   terminate: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.terminate),\n/* harmony export */   updateDoc: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc),\n/* harmony export */   vector: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.vector),\n/* harmony export */   waitForPendingWrites: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.waitForPendingWrites),\n/* harmony export */   where: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where),\n/* harmony export */   writeBatch: () => (/* reexport safe */ _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/firestore */ \"(ssr)/./node_modules/@firebase/firestore/dist/index.node.mjs\");\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xvdmVtb25leS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9maXJlc3RvcmUvZGlzdC9pbmRleC5tanM/MjY2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvZmlyZXN0b3JlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/firestore/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   browserCookiePersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a9),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.au),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__.aa)\n/* harmony export */ });\n/* harmony import */ var _totp_18137433_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-18137433.js */ \"(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-18137433.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXduRTtBQUNqbUU7QUFDQztBQUNUO0FBQ2M7QUFDSDtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xvdmVtb25leS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS9pbmRleC5qcz82MmIwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEEgYXMgQWN0aW9uQ29kZU9wZXJhdGlvbiwgYWogYXMgQWN0aW9uQ29kZVVSTCwgTSBhcyBBdXRoQ3JlZGVudGlhbCwgSiBhcyBBdXRoRXJyb3JDb2RlcywgTiBhcyBFbWFpbEF1dGhDcmVkZW50aWFsLCBXIGFzIEVtYWlsQXV0aFByb3ZpZGVyLCBYIGFzIEZhY2Vib29rQXV0aFByb3ZpZGVyLCBGIGFzIEZhY3RvcklkLCBaIGFzIEdpdGh1YkF1dGhQcm92aWRlciwgWSBhcyBHb29nbGVBdXRoUHJvdmlkZXIsIFEgYXMgT0F1dGhDcmVkZW50aWFsLCBfIGFzIE9BdXRoUHJvdmlkZXIsIE8gYXMgT3BlcmF0aW9uVHlwZSwgVSBhcyBQaG9uZUF1dGhDcmVkZW50aWFsLCBQIGFzIFBob25lQXV0aFByb3ZpZGVyLCBuIGFzIFBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3IsIHEgYXMgUHJvdmlkZXJJZCwgUiBhcyBSZWNhcHRjaGFWZXJpZmllciwgJCBhcyBTQU1MQXV0aFByb3ZpZGVyLCBTIGFzIFNpZ25Jbk1ldGhvZCwgVCBhcyBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3IsIG8gYXMgVG90cFNlY3JldCwgYTAgYXMgVHdpdHRlckF1dGhQcm92aWRlciwgYTggYXMgYXBwbHlBY3Rpb25Db2RlLCB5IGFzIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQsIGEgYXMgYnJvd3NlckNvb2tpZVBlcnNpc3RlbmNlLCBiIGFzIGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlLCBtIGFzIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsIGMgYXMgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSwgYTkgYXMgY2hlY2tBY3Rpb25Db2RlLCBhNyBhcyBjb25maXJtUGFzc3dvcmRSZXNldCwgTCBhcyBjb25uZWN0QXV0aEVtdWxhdG9yLCBhYiBhcyBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQsIEggYXMgZGVidWdFcnJvck1hcCwgRyBhcyBkZWxldGVVc2VyLCBhZyBhcyBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCwgYXIgYXMgZ2V0QWRkaXRpb25hbFVzZXJJbmZvLCBwIGFzIGdldEF1dGgsIGFvIGFzIGdldElkVG9rZW4sIGFwIGFzIGdldElkVG9rZW5SZXN1bHQsIGF0IGFzIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIsIGsgYXMgZ2V0UmVkaXJlY3RSZXN1bHQsIFYgYXMgaW5NZW1vcnlQZXJzaXN0ZW5jZSwgaSBhcyBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlLCBLIGFzIGluaXRpYWxpemVBdXRoLCB2IGFzIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcsIGFlIGFzIGlzU2lnbkluV2l0aEVtYWlsTGluaywgYTMgYXMgbGlua1dpdGhDcmVkZW50aWFsLCBsIGFzIGxpbmtXaXRoUGhvbmVOdW1iZXIsIGUgYXMgbGlua1dpdGhQb3B1cCwgaCBhcyBsaW5rV2l0aFJlZGlyZWN0LCBhdSBhcyBtdWx0aUZhY3RvciwgeiBhcyBvbkF1dGhTdGF0ZUNoYW5nZWQsIHggYXMgb25JZFRva2VuQ2hhbmdlZCwgYWsgYXMgcGFyc2VBY3Rpb25Db2RlVVJMLCBJIGFzIHByb2RFcnJvck1hcCwgYTQgYXMgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCwgciBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciwgZiBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCwgaiBhcyByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCwgYXMgYXMgcmVsb2FkLCBFIGFzIHJldm9rZUFjY2Vzc1Rva2VuLCBhaCBhcyBzZW5kRW1haWxWZXJpZmljYXRpb24sIGE2IGFzIHNlbmRQYXNzd29yZFJlc2V0RW1haWwsIGFkIGFzIHNlbmRTaWduSW5MaW5rVG9FbWFpbCwgdCBhcyBzZXRQZXJzaXN0ZW5jZSwgYTEgYXMgc2lnbkluQW5vbnltb3VzbHksIGEyIGFzIHNpZ25JbldpdGhDcmVkZW50aWFsLCBhNSBhcyBzaWduSW5XaXRoQ3VzdG9tVG9rZW4sIGFjIGFzIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkLCBhZiBhcyBzaWduSW5XaXRoRW1haWxMaW5rLCBzIGFzIHNpZ25JbldpdGhQaG9uZU51bWJlciwgZCBhcyBzaWduSW5XaXRoUG9wdXAsIGcgYXMgc2lnbkluV2l0aFJlZGlyZWN0LCBEIGFzIHNpZ25PdXQsIGFxIGFzIHVubGluaywgQyBhcyB1cGRhdGVDdXJyZW50VXNlciwgYW0gYXMgdXBkYXRlRW1haWwsIGFuIGFzIHVwZGF0ZVBhc3N3b3JkLCB1IGFzIHVwZGF0ZVBob25lTnVtYmVyLCBhbCBhcyB1cGRhdGVQcm9maWxlLCBCIGFzIHVzZURldmljZUxhbmd1YWdlLCB3IGFzIHZhbGlkYXRlUGFzc3dvcmQsIGFpIGFzIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsLCBhYSBhcyB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSB9IGZyb20gJy4vdG90cC0xODEzNzQzMy5qcyc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgJ3RzbGliJztcbmltcG9ydCAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9sb2dnZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-18137433.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-18137433.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ useDeviceLanguage),\n/* harmony export */   C: () => (/* binding */ updateCurrentUser),\n/* harmony export */   D: () => (/* binding */ signOut),\n/* harmony export */   E: () => (/* binding */ revokeAccessToken),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ deleteUser),\n/* harmony export */   H: () => (/* binding */ debugErrorMap),\n/* harmony export */   I: () => (/* binding */ prodErrorMap),\n/* harmony export */   J: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   K: () => (/* binding */ initializeAuth),\n/* harmony export */   L: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   M: () => (/* binding */ AuthCredential),\n/* harmony export */   N: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ OAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   V: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   W: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   X: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Z: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   _: () => (/* binding */ OAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserCookiePersistence),\n/* harmony export */   a0: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   a1: () => (/* binding */ signInAnonymously),\n/* harmony export */   a2: () => (/* binding */ signInWithCredential),\n/* harmony export */   a3: () => (/* binding */ linkWithCredential),\n/* harmony export */   a4: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a5: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a6: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a7: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a8: () => (/* binding */ applyActionCode),\n/* harmony export */   a9: () => (/* binding */ checkActionCode),\n/* harmony export */   aA: () => (/* binding */ signInWithIdp),\n/* harmony export */   aB: () => (/* binding */ _fail),\n/* harmony export */   aC: () => (/* binding */ debugAssert),\n/* harmony export */   aD: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aE: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aF: () => (/* binding */ _castAuth),\n/* harmony export */   aG: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aH: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aI: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aJ: () => (/* binding */ _performApiRequest),\n/* harmony export */   aK: () => (/* binding */ _isIOS),\n/* harmony export */   aL: () => (/* binding */ _isAndroid),\n/* harmony export */   aM: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aN: () => (/* binding */ _createError),\n/* harmony export */   aO: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aP: () => (/* binding */ _isIE10),\n/* harmony export */   aQ: () => (/* binding */ UserImpl),\n/* harmony export */   aR: () => (/* binding */ AuthImpl),\n/* harmony export */   aS: () => (/* binding */ _getClientVersion),\n/* harmony export */   aT: () => (/* binding */ FetchProvider),\n/* harmony export */   aU: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   ab: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ad: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ae: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   ag: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ah: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ai: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   aj: () => (/* binding */ ActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   al: () => (/* binding */ updateProfile),\n/* harmony export */   am: () => (/* binding */ updateEmail),\n/* harmony export */   an: () => (/* binding */ updatePassword),\n/* harmony export */   ao: () => (/* binding */ getIdToken),\n/* harmony export */   ap: () => (/* binding */ getIdTokenResult),\n/* harmony export */   aq: () => (/* binding */ unlink),\n/* harmony export */   ar: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   as: () => (/* binding */ reload),\n/* harmony export */   at: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   au: () => (/* binding */ multiFactor),\n/* harmony export */   av: () => (/* binding */ _getInstance),\n/* harmony export */   aw: () => (/* binding */ _assert),\n/* harmony export */   ax: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ay: () => (/* binding */ _reauthenticate),\n/* harmony export */   az: () => (/* binding */ _link),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   d: () => (/* binding */ signInWithPopup),\n/* harmony export */   e: () => (/* binding */ linkWithPopup),\n/* harmony export */   f: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   g: () => (/* binding */ signInWithRedirect),\n/* harmony export */   h: () => (/* binding */ linkWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   k: () => (/* binding */ getRedirectResult),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   n: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   o: () => (/* binding */ TotpSecret),\n/* harmony export */   p: () => (/* binding */ getAuth),\n/* harmony export */   q: () => (/* binding */ ProviderId),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ setPersistence),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   w: () => (/* binding */ validatePassword),\n/* harmony export */   x: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   y: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ onAuthStateChanged)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enum of factors that may be used for multifactor authentication.\n *\n * @public\n */\nconst FactorId = {\n    /** Phone as second factor */\n    PHONE: 'phone',\n    TOTP: 'totp'\n};\n/**\n * Enumeration of supported providers.\n *\n * @public\n */\nconst ProviderId = {\n    /** Facebook provider ID */\n    FACEBOOK: 'facebook.com',\n    /** GitHub provider ID */\n    GITHUB: 'github.com',\n    /** Google provider ID */\n    GOOGLE: 'google.com',\n    /** Password provider */\n    PASSWORD: 'password',\n    /** Phone provider */\n    PHONE: 'phone',\n    /** Twitter provider ID */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported sign-in methods.\n *\n * @public\n */\nconst SignInMethod = {\n    /** Email link sign in method */\n    EMAIL_LINK: 'emailLink',\n    /** Email/password sign in method */\n    EMAIL_PASSWORD: 'password',\n    /** Facebook sign in method */\n    FACEBOOK: 'facebook.com',\n    /** GitHub sign in method */\n    GITHUB: 'github.com',\n    /** Google sign in method */\n    GOOGLE: 'google.com',\n    /** Phone sign in method */\n    PHONE: 'phone',\n    /** Twitter sign in method */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported operation types.\n *\n * @public\n */\nconst OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */\n    LINK: 'link',\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */\n    REAUTHENTICATE: 'reauthenticate',\n    /** Operation involving signing in a user. */\n    SIGN_IN: 'signIn'\n};\n/**\n * An enumeration of the possible email action types.\n *\n * @public\n */\nconst ActionCodeOperation = {\n    /** The email link sign-in action. */\n    EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n    /** The password reset action. */\n    PASSWORD_RESET: 'PASSWORD_RESET',\n    /** The email revocation action. */\n    RECOVER_EMAIL: 'RECOVER_EMAIL',\n    /** The revert second factor addition email action. */\n    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',\n    /** The revert second factor addition email action. */\n    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',\n    /** The email verification action. */\n    VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */]: '',\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: \"This app, identified by the domain where it's hosted, is not \" +\n            'authorized to use Firebase Authentication with the provided API key. ' +\n            'Review your key configuration in the Google API console.',\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +\n            'Android package name or iOS bundle ID) provided is not installed on ' +\n            'this device.',\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +\n            'already used or the domain associated with it does not match the list ' +\n            'of whitelisted domains.',\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +\n            'again.',\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +\n            'again before retrying this request.',\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.',\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +\n            'conditions.',\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +\n            'no longer be configured to use the emulator. Try calling ' +\n            '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +\n            ' The reCAPTCHA token response is either invalid or expired.',\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registered for the current project.',\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */]: \"This user's credential isn't valid for this project. This can happen \" +\n            \"if the user's token has been tampered with, or if the user isn't for \" +\n            'the project associated with this API key.',\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +\n            'invalid. Please resend the verification code sms and be sure to use the ' +\n            'verification code provided by the user.',\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +\n            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\n            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\n            'cordova-plugin-customurlscheme.',\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */]: 'The supplied auth credential is incorrect, malformed or has expired.',\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +\n            'only supports OAuth providers.',\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +\n            'specified API key.',\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +\n            'project. Edit the list of authorized domains from the Firebase console.',\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +\n            'expired, or has already been used.',\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +\n            'phone number in a format that can be parsed into E.164 format. E.164 ' +\n            'phone numbers are written in the format [+][country code][subscriber ' +\n            'number including area code].',\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +\n            'recipient email address is invalid.',\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +\n            'by following the instructions in the Firebase console.',\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +\n            'assertion. A reCAPTCHA response token needs to be provided.',\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +\n            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +\n            'in the ID token payload.',\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +\n            'sign-in credentials. Sign in using a provider associated with this ' +\n            'email address.',\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',\n        [\"null-user\" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +\n            'requires a non-null user object.',\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\n            'Auth section.',\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +\n            'running on. \"location.protocol\" must be http, https or chrome-extension' +\n            ' and web storage must be enabled.',\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +\n            'Try again later.',\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +\n            'the domain in the Firebase console.',\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +\n            'have been deleted.',\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */]: '',\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +\n            'different options. To avoid this error, call initializeAuth() with the ' +\n            'same options as when it was originally called, or call getAuth() to return the' +\n            ' already initialized instance.',\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.',\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */]: 'The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.',\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: 'The password does not meet the requirements.',\n        [\"invalid-hosting-link-domain\" /* AuthErrorCode.INVALID_HOSTING_LINK_DOMAIN */]: 'The provided Hosting link domain is not configured in Firebase Hosting or is not owned by ' +\n            'the current project. This cannot be a default Hosting domain (`web.app` or `firebaseapp.com`).'\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.'\n    };\n}\n/**\n * A verbose error map with detailed descriptions for most error codes.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst debugErrorMap = _debugErrorMap;\n/**\n * A minimal error map with all verbose error messages stripped.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', _prodErrorMap());\n/**\n * A map of potential `Auth` error codes, for easier comparison with errors\n * thrown by the SDK.\n *\n * @remarks\n * Note that you can't tree-shake individual keys\n * in the map, so by using the map you might substantially increase your\n * bundle size.\n *\n * @public\n */\nconst AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',\n    ARGUMENT_ERROR: 'auth/argument-error',\n    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',\n    APP_NOT_INSTALLED: 'auth/app-not-installed',\n    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',\n    CODE_EXPIRED: 'auth/code-expired',\n    CORDOVA_NOT_READY: 'auth/cordova-not-ready',\n    CORS_UNSUPPORTED: 'auth/cors-unsupported',\n    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',\n    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',\n    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',\n    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',\n    EMAIL_EXISTS: 'auth/email-already-in-use',\n    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',\n    EXPIRED_OOB_CODE: 'auth/expired-action-code',\n    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',\n    INTERNAL_ERROR: 'auth/internal-error',\n    INVALID_API_KEY: 'auth/invalid-api-key',\n    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',\n    INVALID_APP_ID: 'auth/invalid-app-id',\n    INVALID_AUTH: 'auth/invalid-user-token',\n    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',\n    INVALID_CERT_HASH: 'auth/invalid-cert-hash',\n    INVALID_CODE: 'auth/invalid-verification-code',\n    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',\n    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',\n    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',\n    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',\n    INVALID_EMAIL: 'auth/invalid-email',\n    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',\n    INVALID_IDP_RESPONSE: 'auth/invalid-credential',\n    INVALID_LOGIN_CREDENTIALS: 'auth/invalid-credential',\n    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',\n    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',\n    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',\n    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',\n    INVALID_OOB_CODE: 'auth/invalid-action-code',\n    INVALID_ORIGIN: 'auth/unauthorized-domain',\n    INVALID_PASSWORD: 'auth/wrong-password',\n    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',\n    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',\n    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',\n    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',\n    INVALID_SENDER: 'auth/invalid-sender',\n    INVALID_SESSION_INFO: 'auth/invalid-verification-id',\n    INVALID_TENANT_ID: 'auth/invalid-tenant-id',\n    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',\n    MFA_REQUIRED: 'auth/multi-factor-auth-required',\n    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',\n    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',\n    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',\n    MISSING_CODE: 'auth/missing-verification-code',\n    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',\n    MISSING_IFRAME_START: 'auth/missing-iframe-start',\n    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',\n    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',\n    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',\n    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',\n    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',\n    MISSING_SESSION_INFO: 'auth/missing-verification-id',\n    MODULE_DESTROYED: 'auth/app-deleted',\n    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',\n    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',\n    NULL_USER: 'auth/null-user',\n    NO_AUTH_EVENT: 'auth/no-auth-event',\n    NO_SUCH_PROVIDER: 'auth/no-such-provider',\n    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',\n    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',\n    POPUP_BLOCKED: 'auth/popup-blocked',\n    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',\n    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',\n    QUOTA_EXCEEDED: 'auth/quota-exceeded',\n    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',\n    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',\n    REJECTED_CREDENTIAL: 'auth/rejected-credential',\n    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',\n    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',\n    TIMEOUT: 'auth/timeout',\n    TOKEN_EXPIRED: 'auth/user-token-expired',\n    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',\n    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',\n    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',\n    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',\n    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',\n    UNVERIFIED_EMAIL: 'auth/unverified-email',\n    USER_CANCELLED: 'auth/user-cancelled',\n    USER_DELETED: 'auth/user-not-found',\n    USER_DISABLED: 'auth/user-disabled',\n    USER_MISMATCH: 'auth/user-mismatch',\n    USER_SIGNED_OUT: 'auth/user-signed-out',\n    WEAK_PASSWORD: 'auth/weak-password',\n    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',\n    ALREADY_INITIALIZED: 'auth/already-initialized',\n    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',\n    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',\n    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',\n    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',\n    MISSING_CLIENT_TYPE: 'auth/missing-client-type',\n    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',\n    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',\n    INVALID_REQ_TYPE: 'auth/invalid-req-type',\n    INVALID_HOSTING_LINK_DOMAIN: 'auth/invalid-hosting-link-domain'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/auth');\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.WARN) {\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.ERROR) {\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */, 'Operations that alter the current user are not supported in conjunction with FirebaseServerApp');\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== 'string') {\n        const code = rest[0];\n        const fullParams = [...rest.slice(1)];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\n * Unconditionally fails, throwing an internal error with the given message.\n *\n * @param failure type of failure encountered\n * @throws Error\n */\nfunction debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * @param assertion\n * @param message\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _getCurrentUrl() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine whether the browser is working online\n */\nfunction _isOnline() {\n    if (typeof navigator !== 'undefined' &&\n        navigator &&\n        'onLine' in navigator &&\n        typeof navigator.onLine === 'boolean' &&\n        // Apply only for traditional web apps and Chrome extensions.\n        // This is especially true for Cordova apps which have unreliable\n        // navigator.onLine behavior unless cordova-plugin-network-information is\n        // installed which overwrites the native navigator.onLine value and\n        // defines navigator.connection.\n        (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || 'connection' in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return (\n    // Most reliable, but only supported in Chrome/Firefox.\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\n        // Supported in most browsers, but returns the language of the browser\n        // UI, not the language set in browser settings.\n        navigatorLanguage.language ||\n        // Couldn't determine language.\n        null);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A structure to help pick between a range of long and short delay durations\n * depending on the current environment. In general, the long delay is used for\n * mobile environments whereas short delays are used for desktop environments.\n */\nclass Delay {\n    constructor(shortDelay, longDelay) {\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _emulatorUrl(config, path) {\n    debugAssert(config.emulator, 'Emulator should always be set here');\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== 'undefined' && 'fetch' in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== 'undefined') {\n            return fetch;\n        }\n        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== 'undefined' && 'Headers' in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== 'undefined') {\n            return Headers;\n        }\n        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== 'undefined' && 'Response' in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== 'undefined') {\n            return Response;\n        }\n        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Map from errors returned by the server to errors to developer visible errors\n */\nconst SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst CookieAuthProxiedEndpoints = [\n    \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */,\n    \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */,\n    \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */,\n    \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */,\n    \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */,\n    \"/v1/token\" /* Endpoint.TOKEN */\n];\nconst DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */) {\n                params = request;\n            }\n            else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({ key: auth.config.apiKey }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/json';\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;\n        }\n        const fetchArgs = Object.assign({ method,\n            headers }, body);\n        /* Security-conscious server-side frameworks tend to have built in mitigations for referrer\n           problems\". See the Cloudflare GitHub issue #487: Error: The 'referrerPolicy' field on\n           'RequestInitializerDict' is not implemented.\"\n           https://github.com/cloudflare/next-on-pages/issues/487 */\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudflareWorker)()) {\n            fetchArgs.referrerPolicy = 'no-referrer';\n        }\n        if (auth.emulatorConfig && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(auth.emulatorConfig.host)) {\n            fetchArgs.credentials = 'include';\n        }\n        return FetchProvider.fetch()(await _getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if ('needConfirmation' in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, json);\n        }\n        if (response.ok && !('errorMessage' in json)) {\n            return json;\n        }\n        else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);\n            }\n            else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */, json);\n            }\n            else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */, json);\n            }\n            const authError = errorMap[serverErrorCode] ||\n                serverErrorCode\n                    .toLowerCase()\n                    .replace(/[_\\s]+/g, '-');\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            }\n            else {\n                _fail(auth, authError);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if ('mfaPendingCredential' in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */, {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nasync function _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    const authInternal = auth;\n    const finalTarget = authInternal.config.emulator\n        ? _emulatorUrl(auth.config, base)\n        : `${auth.config.apiScheme}://${base}`;\n    // Cookie auth works by MiTMing the signIn and token endpoints from the developer's backend,\n    // saving the idToken and refreshToken into cookies, and then redacting the refreshToken\n    // from the response\n    if (CookieAuthProxiedEndpoints.includes(path)) {\n        // Persistence manager is async, we need to await it. We can't just wait for auth initialized\n        // here since auth initialization calls this function.\n        await authInternal._persistenceManagerAvailable;\n        if (authInternal._getPersistenceType() === \"COOKIE\" /* PersistenceType.COOKIE */) {\n            const cookiePersistence = authInternal._getPersistence();\n            return cookiePersistence._getFinalTarget(finalTarget).toString();\n        }\n    }\n    return finalTarget;\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch (enforcementStateStr) {\n        case 'ENFORCE':\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */;\n        case 'AUDIT':\n            return \"AUDIT\" /* EnforcementState.AUDIT */;\n        case 'OFF':\n            return \"OFF\" /* EnforcementState.OFF */;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */;\n    }\n}\nclass NetworkTimeout {\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n    constructor(auth) {\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject) => {\n            this.timer = setTimeout(() => {\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isEnterprise(grecaptcha) {\n    return (grecaptcha !== undefined &&\n        grecaptcha.enterprise !== undefined);\n}\nclass RecaptchaConfig {\n    constructor(response) {\n        /**\n         * The reCAPTCHA site key.\n         */\n        this.siteKey = '';\n        /**\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\n         */\n        this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error('recaptchaKey undefined');\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split('/')[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\n     *\n     * @param providerStr - The provider whose enforcement state is to be returned.\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\n     */\n    getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState ||\n            this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {\n            if (recaptchaEnforcementState.provider &&\n                recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\n     *\n     * @param providerStr - The provider whose enablement state is to be returned.\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\n     */\n    isProviderEnabled(providerStr) {\n        return (this.getProviderEnforcementState(providerStr) ===\n            \"ENFORCE\" /* EnforcementState.ENFORCE */ ||\n            this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */);\n    }\n    /**\n     * Returns true if reCAPTCHA Enterprise protection is enabled in at least one provider, otherwise\n     * returns false.\n     *\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for at least one provider.\n     */\n    isAnyProviderEnabled() {\n        return (this.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) ||\n            this.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */, request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nfunction getIdToken(user, forceRefresh = false) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\n}\n/**\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nasync function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split('.');\n    if (algorithm === undefined ||\n        payload === undefined ||\n        signature === undefined) {\n        _logError('JWT malformed, contained fewer than 3 sections');\n        return null;\n    }\n    try {\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\n        if (!decoded) {\n            _logError('Failed to decode base64 JWT payload');\n            return null;\n        }\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\n */\nfunction _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.exp !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.iat !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return (code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */}` ||\n        code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */}`);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ProactiveRefresh {\n    constructor(user) {\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);\n            return interval;\n        }\n        else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async () => {\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        }\n        catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) ===\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserMetadata {\n    constructor(createdAt, lastLoginAt) {\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)\n        ? extractProviderData(coreAccount.providerUserInfo)\n        : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\n * Reloads user account data, if signed in.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function reload(user) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));\n    return [...deduped, ...newData];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a) => {\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"providerId\"]);\n        return {\n            providerId,\n            uid: provider.rawId || '',\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async () => {\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\n            'grant_type': 'refresh_token',\n            'refresh_token': refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = await _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */, `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';\n        const options = {\n            method: \"POST\" /* HttpMethod.POST */,\n            headers,\n            body\n        };\n        if (auth.emulatorConfig &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(auth.emulatorConfig.host)) {\n            options.credentials = 'include';\n        }\n        return FetchProvider.fetch()(url, options);\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\n * it references AuthInternal which has a circular dependency with UserInternal.\n *\n * @internal\n */\nclass StsTokenManager {\n    constructor() {\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return (!this.expirationTime ||\n            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.idToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.refreshToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'\n            ? Number(response.expiresIn)\n            : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */);\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === 'number', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, { appName });\n}\nclass UserImpl {\n    constructor(_a) {\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"uid\", \"auth\", \"stsTokenManager\"]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [...opt.providerData] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        }\n        else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken &&\n            response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), \n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { \n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey, appName: this.auth.name });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || '';\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === 'string', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof isAnonymous === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const providerData = coreAccount.providerUserInfo !== undefined\n            ? extractProviderData(coreAccount.providerUserInfo)\n            : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) &&\n                !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, 'Expected a class definition');\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass InMemoryPersistence {\n    constructor() {\n        this.type = \"NONE\" /* PersistenceType.NONE */;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = 'NONE';\n/**\n * An implementation of {@link Persistence} of type 'NONE'.\n *\n * @public\n */\nconst inMemoryPersistence = InMemoryPersistence;\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey) {\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        if (!blob) {\n            return null;\n        }\n        if (typeof blob === 'string') {\n            const response = await getAccountInfo(this.auth, { idToken: blob }).catch(() => undefined);\n            if (!response) {\n                return null;\n            }\n            return UserImpl._fromGetAccountInfoResponse(this.auth, response, blob);\n        }\n        return UserImpl._fromJSON(this.auth, blob);\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter(persistence => persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] ||\n            _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy) {\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    let user;\n                    if (typeof blob === 'string') {\n                        const response = await getAccountInfo(auth, {\n                            idToken: blob\n                        }).catch(() => undefined);\n                        if (!response) {\n                            break;\n                        }\n                        user = await UserImpl._fromGetAccountInfoResponse(auth, response, blob);\n                    }\n                    else {\n                        user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    }\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            }\n            catch (_a) { }\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration ||\n            !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                }\n                catch (_a) { }\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine the browser for the purposes of reporting usage to the API\n */\nfunction _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {\n        return \"Opera\" /* BrowserName.OPERA */;\n    }\n    else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */;\n    }\n    else if (ua.includes('msie') || ua.includes('trident/')) {\n        return \"IE\" /* BrowserName.IE */;\n    }\n    else if (ua.includes('edge/')) {\n        return \"Edge\" /* BrowserName.EDGE */;\n    }\n    else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */;\n    }\n    else if (ua.includes('silk/')) {\n        return \"Silk\" /* BrowserName.SILK */;\n    }\n    else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */;\n    }\n    else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */;\n    }\n    else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */;\n    }\n    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&\n        !ua.includes('edge/')) {\n        return \"Chrome\" /* BrowserName.CHROME */;\n    }\n    else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */;\n    }\n    else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */;\n}\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    const ua = userAgent.toLowerCase();\n    return (ua.includes('safari/') &&\n        !ua.includes('chrome/') &&\n        !ua.includes('crios/') &&\n        !ua.includes('android'));\n}\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/iphone|ipad|ipod/i.test(ua) ||\n        (/macintosh/i.test(ua) && /mobile/i.test(ua)));\n}\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) ||\n        /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua));\n}\nfunction _isIE10() {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return (_isIOS(ua) ||\n        _isAndroid(ua) ||\n        _isWebOS(ua) ||\n        _isBlackBerry(ua) ||\n        /windows phone/i.test(ua) ||\n        _isIEMobile(ua));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Determine the SDK version string\n */\nfunction _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch (clientPlatform) {\n        case \"Browser\" /* ClientPlatform.BROWSER */:\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length\n        ? frameworks.join(',')\n        : 'FirebaseCore-web'; /* default value if no other framework is used */\n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */}/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthMiddlewareQueue {\n    constructor(auth) {\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user) => new Promise((resolve, reject) => {\n            try {\n                const result = callback(user);\n                // Either resolve with existing promise or wrap a non-promise\n                // return value into a promise.\n                resolve(result);\n            }\n            catch (e) {\n                // Sync callback throws.\n                reject(e);\n            }\n        });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return () => {\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = () => Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue) {\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        }\n        catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack) {\n                try {\n                    onAbort();\n                }\n                catch (_) {\n                    /* swallow error */\n                }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */, {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\n *\n * @param auth Auth object.\n * @param request Password policy request.\n * @returns Password policy response.\n */\nasync function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\n * Stores password policy requirements and provides password validation against the policy.\n *\n * @internal\n */\nclass PasswordPolicyImpl {\n    constructor(response) {\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength =\n            (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength =\n                responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter =\n                responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter =\n                responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter =\n                responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter =\n                responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED') {\n            this.enforcementState = 'OFF';\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters =\n            (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join('')) !== null && _c !== void 0 ? _c : '';\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\n     * Validates that the password meets the length options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\n     * Validates that the password meets the character options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, \n        /* containsLowercaseCharacter= */ false, \n        /* containsUppercaseCharacter= */ false, \n        /* containsNumericCharacter= */ false, \n        /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for (let i = 0; i < password.length; i++) {\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, \n            /* containsLowercaseCharacter= */ passwordChar >= 'a' &&\n                passwordChar <= 'z', \n            /* containsUppercaseCharacter= */ passwordChar >= 'A' &&\n                passwordChar <= 'Z', \n            /* containsNumericCharacter= */ passwordChar >= '0' &&\n                passwordChar <= '9', \n            /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\n     * Updates the running validation status with the statuses for the character options.\n     * Expected to be called each time a character is processed to update each option status\n     * based on the current character.\n     *\n     * @param status Validation status.\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\n     * @param containsNumericCharacter Whether the character is a numeric character.\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\n     */\n    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        this._resolvePersistenceManagerAvailable = undefined;\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = { appVerificationDisabledForTesting: false };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n        // TODO(jamesdaniels) explore less hacky way to do this, cookie authentication needs\n        // persistenceMananger to be available. see _getFinalTarget for more context\n        this._persistenceManagerAvailable = new Promise(resolve => (this._resolvePersistenceManagerAvailable = resolve));\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async () => {\n            var _a, _b, _c;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            (_a = this._resolvePersistenceManagerAvailable) === null || _a === void 0 ? void 0 : _a.call(this);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_b = this._popupRedirectResolver) === null || _b === void 0 ? void 0 : _b._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                }\n                catch (e) {\n                    /* Ignore the error */\n                }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_c = this.currentUser) === null || _c === void 0 ? void 0 : _c.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\n     * If the persistence is changed in another window, the user manager will let us know\n     */\n    async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, { idToken });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        }\n        catch (err) {\n            console.warn('FirebaseServerApp could not login user with provided authIdToken: ', err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise(resolve => {\n                    setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&\n                (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                }\n                catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser &&\n            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    > [Initialization] \n        //    > [<other queue tasks>] \n        //     [getRedirectResult] <\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        }\n        catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        }\n        catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !==\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern)\n            : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */);\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async () => {\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async () => {\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        }\n        else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !==\n            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */, {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        }\n        else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        }\n        else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistenceType() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject) => {\n            if (this.currentUser) {\n                resolve();\n            }\n            else {\n                const unsubscribe = this.onAuthStateChanged(() => {\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n     */\n    async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: 'apple.com',\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null\n            ? redirectManager.removeCurrentUser()\n            : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||\n                this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], \"redirectUser\" /* KeyName.REDIRECT_USER */);\n            this.redirectUser =\n                await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async () => { });\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async () => this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */\n    _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */\n    get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return () => { };\n        }\n        const cb = typeof nextOrObserver === 'function'\n            ? nextOrObserver\n            : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized\n            ? Promise.resolve()\n            : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(() => {\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === 'function') {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n        else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\n     * Unprotected (from race conditions) method to set the current user. This\n     * should only be called from within a queued callback. This is necessary\n     * because the queue shouldn't rely on another queued callback.\n     */\n    async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        }\n        else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider\n            .getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app) && this.app.settings.appCheckToken) {\n            return this.app.settings.appCheckToken;\n        }\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider\n            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\n * Method to be used to cast down to our private implementation of Auth.\n * It will also handle unwrapping from the compat type if necessary\n *\n * @param auth Auth object passed in from developer\n */\nfunction _castAuth(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n}\n/** Helper class to wrap subscriber logic */\nclass Subscription {\n    constructor(auth) {\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)(observer => (this.observer = observer));\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.observer.next.bind(this.observer);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet externalJSProvider = {\n    async loadJS() {\n        throw new Error('Unable to load external scripts');\n    },\n    recaptchaV2Script: '',\n    recaptchaEnterpriseScript: '',\n    gapiScript: ''\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MockGreCAPTCHATopLevel {\n    constructor() {\n        this.enterprise = new MockGreCAPTCHA();\n    }\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\nclass MockGreCAPTCHA {\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';\nconst FAKE_TOKEN = 'NO_RECAPTCHA';\nclass RecaptchaEnterpriseVerifier {\n    /**\n     *\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\n     *\n     */\n    constructor(authExtern) {\n        /**\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\n         */\n        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\n     * Executes the verification process.\n     *\n     * @returns A Promise for a token that can be used to assert the validity of a request.\n     */\n    async verify(action = 'verify', forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null &&\n                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject) => {\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                })\n                    .then(response => {\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error('recaptcha Enterprise site key undefined'));\n                    }\n                    else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        }\n                        else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                })\n                    .catch(error => {\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(() => {\n                    grecaptcha.enterprise\n                        .execute(siteKey, { action })\n                        .then(token => {\n                        resolve(token);\n                    })\n                        .catch(() => {\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            }\n            else {\n                reject(Error('No reCAPTCHA enterprise script loaded.'));\n            }\n        }\n        // Returns Promise for a mock token when appVerificationDisabledForTesting is true.\n        if (this.auth.settings.appVerificationDisabledForTesting) {\n            const mockRecaptcha = new MockGreCAPTCHATopLevel();\n            return mockRecaptcha.execute('siteKey', { action: 'verify' });\n        }\n        return new Promise((resolve, reject) => {\n            retrieveSiteKey(this.auth)\n                .then(siteKey => {\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                }\n                else {\n                    if (typeof window === 'undefined') {\n                        reject(new Error('RecaptchaVerifier is only supported in browser'));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url)\n                        .then(() => {\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    })\n                        .catch(error => {\n                        reject(error);\n                    });\n                }\n            })\n                .catch(error => {\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, isCaptchaResp = false, isFakeToken = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    if (isFakeToken) {\n        captchaResponse = FAKE_TOKEN;\n    }\n    else {\n        try {\n            captchaResponse = await verifier.verify(action);\n        }\n        catch (error) {\n            captchaResponse = await verifier.verify(action, true);\n        }\n    }\n    const newRequest = Object.assign({}, request);\n    if (action === \"mfaSmsEnrollment\" /* RecaptchaActionName.MFA_SMS_ENROLLMENT */ ||\n        action === \"mfaSmsSignIn\" /* RecaptchaActionName.MFA_SMS_SIGNIN */) {\n        if ('phoneEnrollmentInfo' in newRequest) {\n            const phoneNumber = newRequest.phoneEnrollmentInfo.phoneNumber;\n            const recaptchaToken = newRequest.phoneEnrollmentInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneEnrollmentInfo': {\n                    phoneNumber,\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        else if ('phoneSignInInfo' in newRequest) {\n            const recaptchaToken = newRequest.phoneSignInInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneSignInInfo': {\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        return newRequest;\n    }\n    if (!isCaptchaResp) {\n        Object.assign(newRequest, { captchaResponse });\n    }\n    else {\n        Object.assign(newRequest, { 'captchaResp': captchaResponse });\n    }\n    Object.assign(newRequest, { 'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ });\n    Object.assign(newRequest, {\n        'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod, recaptchaAuthProvider) {\n    var _a, _b;\n    if (recaptchaAuthProvider === \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) {\n        if ((_a = authInstance\n            ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n            return actionMethod(authInstance, requestWithRecaptcha);\n        }\n        else {\n            return actionMethod(authInstance, request).catch(async (error) => {\n                if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {\n                    console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                    const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n                    return actionMethod(authInstance, requestWithRecaptcha);\n                }\n                else {\n                    return Promise.reject(error);\n                }\n            });\n        }\n    }\n    else if (recaptchaAuthProvider === \"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */) {\n        if ((_b = authInstance\n            ._getRecaptchaConfig()) === null || _b === void 0 ? void 0 : _b.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName);\n            return actionMethod(authInstance, requestWithRecaptcha).catch(async (error) => {\n                var _a;\n                if (((_a = authInstance\n                    ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.getProviderEnforcementState(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) === \"AUDIT\" /* EnforcementState.AUDIT */) {\n                    // AUDIT mode\n                    if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}` ||\n                        error.code === `auth/${\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */}`) {\n                        console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${actionName} flow.`);\n                        // reCAPTCHA Enterprise token is missing or reCAPTCHA Enterprise token\n                        // check fails.\n                        // Fallback to reCAPTCHA v2 flow.\n                        const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n                        true // isFakeToken\n                        );\n                        // This will call the PhoneApiCaller to fetch and inject reCAPTCHA v2 token.\n                        return actionMethod(authInstance, requestWithRecaptchaFields);\n                    }\n                }\n                // ENFORCE mode or AUDIT mode with any other error.\n                return Promise.reject(error);\n            });\n        }\n        else {\n            // Do reCAPTCHA v2 flow.\n            const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n            true // isFakeToken\n            );\n            // This will call the PhoneApiCaller to fetch and inject v2 token.\n            return actionMethod(authInstance, requestWithRecaptchaFields);\n        }\n    }\n    else {\n        return Promise.reject(recaptchaAuthProvider + ' provider is not supported.');\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    }\n    else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isAnyProviderEnabled()) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Initializes an {@link Auth} instance with fine-grained control over\n * {@link Dependencies}.\n *\n * @remarks\n *\n * This function allows more control over the {@link Auth} instance than\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\n * need control over which persistence layer is used, or to minimize bundle\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\n *\n * For example, if your app only uses anonymous accounts and you only want\n * accounts saved for the current session, initialize `Auth` with:\n *\n * ```js\n * const auth = initializeAuth(app, {\n *   persistence: browserSessionPersistence,\n *   popupRedirectResolver: undefined,\n * });\n * ```\n *\n * @public\n */\nfunction initializeAuth(app, deps) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        }\n        else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */);\n        }\n    }\n    const auth = provider.initialize({ options: deps });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n\n/**\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\n * Firebase Auth services.\n *\n * @remarks\n * This must be called synchronously immediately following the first call to\n * {@link initializeAuth}.  Do not use with production credentials as emulator\n * traffic is not encrypted.\n *\n *\n * @example\n * ```javascript\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\n * `true` to disable the warning banner attached to the DOM.\n *\n * @public\n */\nfunction connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? '' : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    const emulator = { url: `${protocol}//${host}${portStr}/` };\n    const emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(':', ''),\n        options: Object.freeze({ disableWarnings })\n    });\n    // There are a few scenarios to guard against if the Auth instance has already started:\n    if (!authInternal._canInitEmulator) {\n        // Applications may not initialize the emulator for the first time if Auth has already started\n        // to make network requests.\n        _assert(authInternal.config.emulator && authInternal.emulatorConfig, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\n        // Applications may not alter the configuration of the emulator (aka pass a different config)\n        // once Auth has started to make network requests.\n        _assert((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(emulator, authInternal.config.emulator) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(emulatorConfig, authInternal.emulatorConfig), authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\n        // It's valid, however, to invoke connectAuthEmulator() after Auth has started making\n        // connections, so long as the config matches the existing config. This results in a no-op.\n        return;\n    }\n    authInternal.config.emulator = emulator;\n    authInternal.emulatorConfig = emulatorConfig;\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    // Workaround to get cookies in Firebase Studio\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudWorkstation)(host)) {\n        void (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.pingServer)(`${protocol}//${host}${portStr}`);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.updateEmulatorBanner)('Auth', true);\n    }\n    else if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(':');\n    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return { host: '', port: null };\n    }\n    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };\n    }\n    else {\n        const [host, port] = hostAndPort.split(':');\n        return { host, port: parsePort(port) };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement('p');\n        const sty = el.style;\n        el.innerText =\n            'Running in emulator mode. Do not use with production credentials.';\n        sty.position = 'fixed';\n        sty.width = '100%';\n        sty.backgroundColor = '#ffffff';\n        sty.border = '.1em solid #000000';\n        sty.color = '#b50000';\n        sty.bottom = '0px';\n        sty.left = '0px';\n        sty.margin = '0px';\n        sty.zIndex = '10000';\n        sty.textAlign = 'center';\n        el.classList.add('firebase-emulator-warning');\n        document.body.appendChild(el);\n    }\n    if (typeof console !== 'undefined' && typeof console.info === 'function') {\n        console.info('WARNING: You are using the Auth Emulator,' +\n            ' which is intended for local testing only.  Do not use with' +\n            ' production credentials.');\n    }\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n        if (document.readyState === 'loading') {\n            window.addEventListener('DOMContentLoaded', attachBanner);\n        }\n        else {\n            attachBanner();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by an {@link AuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass AuthCredential {\n    /** @internal */\n    constructor(\n    /**\n     * The authentication provider ID for the credential.\n     *\n     * @remarks\n     * For example, 'facebook.com', or 'google.com'.\n     */\n    providerId, \n    /**\n     * The authentication sign in method for the credential.\n     *\n     * @remarks\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\n     */\n    signInMethod) {\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns a JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getIdTokenResponse(_auth) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _linkToIdToken(_auth, _idToken) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getReauthenticationResolver(_auth) {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\n * {@link ProviderId}.PASSWORD\n *\n * @remarks\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @public\n */\nclass EmailAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _email, \n    /** @internal */\n    _password, signInMethod, \n    /** @internal */\n    _tenantId = null) {\n        super(\"password\" /* ProviderId.PASSWORD */, signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */\n    static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */);\n    }\n    /** @internal */\n    static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */, tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\n     *\n     * @param json - Either `object` or the stringified representation of the object. When string is\n     * provided, `JSON.parse` would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            }\n            else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    async _getIdTokenResponse(auth) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */, signInWithPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    async _linkToIdToken(auth, idToken) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, linkEmailPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI$1 = 'http://localhost';\n/**\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass OAuthCredential extends AuthCredential {\n    constructor() {\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */\n    static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        }\n        else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        }\n        else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(obj, [\"providerId\", \"signInMethod\"]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        }\n        else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody['id_token'] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody['access_token'] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody['oauth_token_secret'] = this.secret;\n            }\n            postBody['providerId'] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody['nonce'] = this.nonce;\n            }\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\n        }\n        return request;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */\n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the credentials returned by {@link PhoneAuthProvider}.\n *\n * @public\n */\nclass PhoneAuthCredential extends AuthCredential {\n    constructor(params) {\n        super(\"phone\" /* ProviderId.PHONE */, \"phone\" /* SignInMethod.PHONE */);\n        this.params = params;\n    }\n    /** @internal */\n    static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({ verificationId, verificationCode });\n    }\n    /** @internal */\n    static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({ phoneNumber, temporaryProof });\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return { temporaryProof, phoneNumber };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */\n    static fromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode &&\n            !verificationId &&\n            !phoneNumber &&\n            !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maps the mode string in action code URL to Action Code Info operation.\n *\n * @param mode\n */\nfunction parseMode(mode) {\n    switch (mode) {\n        case 'recoverEmail':\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */;\n        case 'resetPassword':\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */;\n        case 'signIn':\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n        case 'verifyEmail':\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */;\n        case 'verifyAndChangeEmail':\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;\n        case 'revertSecondFactorAddition':\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;\n        default:\n            return null;\n    }\n}\n/**\n * Helper to parse FDL links\n *\n * @param url\n */\nfunction parseDeepLink(url) {\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['link'];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))['deep_link_id']\n        : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['deep_link_id'];\n    const iOSDoubleDeepLink = iOSDeepLink\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))['link']\n        : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\n * A utility class to parse email action URLs such as password reset, email verification,\n * email link sign in, etc.\n *\n * @public\n */\nclass ActionCodeURL {\n    /**\n     * @param actionLink - The link from which to extract the URL.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @internal\n     */\n    constructor(actionLink) {\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"lang\" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\n     * otherwise returns null.\n     *\n     * @param link  - The email action link string.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @public\n     */\n    static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/**\n * Parses the email action link string and returns an {@link ActionCodeURL} if\n * the link is valid, otherwise returns null.\n *\n * @public\n */\nfunction parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating {@link EmailAuthCredential}.\n *\n * @public\n */\nclass EmailAuthProvider {\n    constructor() {\n        /**\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\n         */\n        this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and password.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credential(email, password);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\n     * ```\n     *\n     * @param email - Email address.\n     * @param password - User account password.\n     * @returns The auth provider credential.\n     */\n    static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\n     * email link operation.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * await sendSignInLinkToEmail(auth, email);\n     * // Obtain emailLink from user.\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\n     * ```\n     *\n     * @param auth - The {@link Auth} instance used to verify the link.\n     * @param email - Email address.\n     * @param emailLink - Sign-in email link.\n     * @returns - The auth provider credential.\n     */\n    static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\n */\nEmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\n */\nEmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_LINK.\n */\nEmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\n *\n * This class is not meant to be instantiated directly.\n *\n * @public\n */\nclass FederatedAuthProvider {\n    /**\n     * Constructor for generic OAuth providers.\n     *\n     * @param providerId - Provider for which credentials should be generated.\n     */\n    constructor(providerId) {\n        this.providerId = providerId;\n        /** @internal */\n        this.defaultLanguageCode = null;\n        /** @internal */\n        this.customParameters = {};\n    }\n    /**\n     * Set the language gode.\n     *\n     * @param languageCode - language code\n     */\n    setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\n     * operations.\n     *\n     * @remarks\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\n     *\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\n     */\n    setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\n     * Retrieve the current list of {@link CustomParameters}.\n     */\n    getCustomParameters() {\n        return this.customParameters;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Common code to all OAuth providers. This is separate from the\n * {@link OAuthProvider} so that child providers (like\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\n * Instead, they rely on a static `credential` method.\n */\nclass BaseOAuthProvider extends FederatedAuthProvider {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this.scopes = [];\n    }\n    /**\n     * Add an OAuth scope to the credential.\n     *\n     * @param scope - Provider OAuth scope to add.\n     */\n    addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\n     * Retrieve the current list of OAuth scopes.\n     */\n    getScopes() {\n        return [...this.scopes];\n    }\n}\n/**\n * Provider for generating generic {@link OAuthCredential}.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new OAuthProvider('google.com');\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a OAuth Access Token for the provider.\n *   const credential = provider.credentialFromResult(auth, result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new OAuthProvider('google.com');\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a OAuth Access Token for the provider.\n * const credential = provider.credentialFromResult(auth, result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass OAuthProvider extends BaseOAuthProvider {\n    /**\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        _assert('providerId' in obj && 'signInMethod' in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\n     *\n     * @remarks\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\n     * the raw nonce must match the nonce field in the ID token.\n     *\n     * @example\n     * ```javascript\n     * // `googleUser` from the onsuccess Google Sign In callback.\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\n     * const provider = new OAuthProvider('google.com');\n     * const credential = provider.credential({\n     *   idToken: googleUser.getAuthResponse().id_token,\n     * });\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param params - Either the options object containing the ID token, access token and raw nonce\n     * or the ID token string.\n     */\n    credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));\n    }\n    /** An internal credential method that accepts more permissive options */\n    _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken &&\n            !oauthTokenSecret &&\n            !oauthIdToken &&\n            !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new FacebookAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('user_birthday');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Facebook Access Token.\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new FacebookAuthProvider();\n * provider.addScope('user_birthday');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Facebook Access Token.\n * const credential = FacebookAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass FacebookAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */);\n    }\n    /**\n     * Creates a credential for Facebook.\n     *\n     * @example\n     * ```javascript\n     * // `event` from the Facebook auth.authResponseChange callback.\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param accessToken - Facebook access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */\nFacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */;\n/** Always set to {@link ProviderId}.FACEBOOK. */\nFacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GoogleAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Google Access Token.\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GoogleAuthProvider();\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Google Access Token.\n * const credential = GoogleAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass GoogleAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"google.com\" /* ProviderId.GOOGLE */);\n        this.addScope('profile');\n    }\n    /**\n     * Creates a credential for Google. At least one of ID token and access token is required.\n     *\n     * @example\n     * ```javascript\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param idToken - Google ID token.\n     * @param accessToken - Google access token.\n     */\n    static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */\nGoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */;\n/** Always set to {@link ProviderId}.GOOGLE. */\nGoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\n *\n * @remarks\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\n * the {@link signInWithPopup} handler:\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GithubAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('repo');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a GitHub Access Token.\n *   const credential = GithubAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GithubAuthProvider();\n * provider.addScope('repo');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a GitHub Access Token.\n * const credential = GithubAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass GithubAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"github.com\" /* ProviderId.GITHUB */);\n    }\n    /**\n     * Creates a credential for GitHub.\n     *\n     * @param accessToken - GitHub access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */\nGithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */;\n/** Always set to {@link ProviderId}.GITHUB. */\nGithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI = 'http://localhost';\n/**\n * @public\n */\nclass SAMLAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(providerId, pendingToken) {\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId ||\n            !signInMethod ||\n            !pendingToken ||\n            providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\n     * Helper static method to avoid exposing the constructor to end users.\n     *\n     * @internal\n     */\n    static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst SAML_PROVIDER_PREFIX = 'saml.';\n/**\n * An {@link AuthProvider} for SAML.\n *\n * @public\n */\nclass SAMLAuthProvider extends FederatedAuthProvider {\n    /**\n     * Constructor. The providerId must start with \"saml.\"\n     * @param providerId - SAML provider ID.\n     */\n    constructor(providerId) {\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        super(providerId);\n    }\n    /**\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\n     * successful SAML flow completes.\n     *\n     * @remarks\n     *\n     * For example, to get an {@link AuthCredential}, you could write the\n     * following code:\n     *\n     * ```js\n     * const userCredential = await signInWithPopup(auth, samlProvider);\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\n     * ```\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));\n    }\n    /**\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new TwitterAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Twitter Access Token and Secret.\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n *   const secret = credential.secret;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new TwitterAuthProvider();\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Twitter Access Token and Secret.\n * const credential = TwitterAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * const secret = credential.secret;\n * ```\n *\n * @public\n */\nclass TwitterAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"twitter.com\" /* ProviderId.TWITTER */);\n    }\n    /**\n     * Creates a credential for Twitter.\n     *\n     * @param token - Twitter access token.\n     * @param secret - Twitter secret.\n     */\n    static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */\nTwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */;\n/** Always set to {@link ProviderId}.TWITTER. */\nTwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserCredentialImpl {\n    constructor(params) {\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if ('phoneNumber' in response) {\n        return \"phone\" /* ProviderId.PHONE */;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in as an anonymous user.\n *\n * @remarks\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\n * new anonymous user identity will be created and returned.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nasync function signInAnonymously(auth) {\n    var _a;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */\n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    constructor(auth, error, operationType, user) {\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */\n        ? credential._getReauthenticationResolver(auth)\n        : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch(error => {\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */}`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a set of UserInfo provider data and converts it to a set of names\n */\nfunction providerDataAsNames(providerData) {\n    return new Set(providerData\n        .map(({ providerId }) => providerId)\n        .filter(pid => !!pid));\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unlinks a provider from a user account.\n *\n * @param user - The user.\n * @param providerId - The provider to unlink.\n *\n * @public\n */\nasync function unlink(user, providerId) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [providerId]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */)) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */, response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false\n        ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */\n        : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    }\n    catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */}`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        }\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\n * Asynchronously signs in with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\n * Links the user account with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function linkWithCredential(user, credential) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\n * Re-authenticates a user using a fresh credential.\n *\n * @remarks\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\n * or a `TOKEN_EXPIRED` error.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in using a custom token.\n *\n * @remarks\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\n * be generated by an auth backend using the\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\n *\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param customToken - The custom token to sign in with.\n *\n * @public\n */\nasync function signInWithCustomToken(auth, customToken) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorInfoImpl {\n    constructor(factorId, response) {\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if ('phoneInfo' in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        else if ('totpInfo' in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"phone\" /* FactorId.PHONE */, response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"totp\" /* FactorId.TOTP */, response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */);\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||\n        actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);\n    _assert(typeof actionCodeSettings.linkDomain === 'undefined' ||\n        actionCodeSettings.linkDomain.length > 0, auth, \"invalid-hosting-link-domain\" /* AuthErrorCode.INVALID_HOSTING_LINK_DOMAIN */);\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.linkDomain = actionCodeSettings.linkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode =\n            actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\n * cached for the project or tenant.\n *\n * @remarks\n * We only fetch the password policy if the password did not meet policy requirements and\n * there is an existing policy cached. A developer must call validatePassword at least\n * once for the cache to be automatically updated.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @private\n */\nasync function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\n * Sends a password reset email to the given email address. This method does not throw an error when\n * there's no user account with the given email address and\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n *\n * @remarks\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\n * the email sent to the user, along with the new password specified by the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain code from user.\n * await confirmPasswordReset('user@example.com', code);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendPasswordResetEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Completes the password reset process, given a confirmation code and new password.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A confirmation code sent to the user.\n * @param newPassword - The new password.\n *\n * @public\n */\nasync function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode,\n        newPassword\n    })\n        .catch(async (error) => {\n        if (error.code ===\n            `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    // Do not return the email.\n}\n/**\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function applyActionCode(auth, oobCode) {\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), { oobCode });\n}\n/**\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @returns metadata about the code.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function checkActionCode(auth, oobCode) {\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const response = await resetPassword(authModular, { oobCode });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    switch (operation) {\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */:\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.newEmail\n                : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.email\n                : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\n *\n * @returns the user's email address if valid.\n *\n * @param auth - The {@link Auth} instance.\n * @param code - A verification code sent to the user.\n *\n * @public\n */\nasync function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\n * Creates a new user account associated with the specified email address and password.\n *\n * @remarks\n * On successful creation of the user account, this user will also be signed in to your application.\n *\n * User account creation can fail if the account already exists or the password is invalid.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The email address acts as a unique identifier for the user and enables an email-based\n * password reset. This function will create a new user account and set the initial user password.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param password - The user's chosen password.\n *\n * @public\n */\nasync function createUserWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, signUp, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n    const response = await signUpResponse.catch(error => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\n * Asynchronously signs in using an email and password.\n *\n * @remarks\n * Fails with an error if the email address and password do not match. When\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\n * email/password.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The user's password is NOT the password used to access the user's email account. The\n * email address serves as a unique identifier for the user, and the password is used to access\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The users email address.\n * @param password - The users password.\n *\n * @public\n */\nfunction signInWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sends a sign-in email link to the user with the specified email.\n *\n * @remarks\n * The sign-in operation has to always be completed in the app unlike other out of band email\n * actions (password reset and email verifications). This is because, at the end of the flow,\n * the user is expected to be signed in and their Auth state persisted within the app.\n *\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\n * address and the email link supplied in the email sent to the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n * @param authInternal - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendSignInLinkToEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\n *\n * @param auth - The {@link Auth} instance.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nfunction isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n}\n/**\n * Asynchronously signs in using an email and sign-in email link.\n *\n * @remarks\n * If no link is passed, the link is inferred from the current URL.\n *\n * Fails with an error if the email address is invalid or OTP in email link expires.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nasync function signInWithEmailLink(auth, email, emailLink) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n    return signInWithCredential(authModular, credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the list of possible sign in methods for the given email address. This method returns an\n * empty list when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, irrespective of the number of authentication methods available for the given email.\n *\n * @remarks\n * This is useful to differentiate methods of sign-in for the same provider, eg.\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\n * {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n *\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\n * Learn more in the Identity Platform documentation for\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\n * @public\n */\nasync function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\n    return signinMethods || [];\n}\n/**\n * Sends a verification email to a user.\n *\n * @remarks\n * The verification process is completed by calling {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendEmailVerification(user, actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\n * Sends a verification email to a new email address.\n *\n * @remarks\n * The user's email will be updated to the new one after being verified.\n *\n * If you have a custom email action handler, you can complete the verification process by calling\n * {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param newEmail - The new email address to be verified before update.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates a user's profile data.\n *\n * @param user - The user.\n * @param profile - The profile's `displayName` and `photoURL` to update.\n *\n * @public\n */\nasync function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === \"password\" /* ProviderId.PASSWORD */);\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\n * Updates the user's email address.\n *\n * @remarks\n * An email will be sent to the original email address (if it was set) that allows to revoke the\n * email address change, in order to protect them from account hijacking.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newEmail - The new email address.\n *\n * Throws \"auth/operation-not-allowed\" error when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\n *\n * @public\n */\nfunction updateEmail(user, newEmail) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\n * Updates the user's password.\n *\n * @remarks\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newPassword - The new password.\n *\n * @public\n */\nfunction updatePassword(user, newPassword) {\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse the `AdditionalUserInfo` from the ID token response.\n *\n */\nfunction _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo\n        ? JSON.parse(idTokenResponse.rawUserInfo)\n        : {};\n    const isNewUser = idTokenResponse.isNewUser ||\n        idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */ &&\n                signInProvider !== \"custom\" /* ProviderId.CUSTOM */\n                ? signInProvider\n                : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch (providerId) {\n        case \"facebook.com\" /* ProviderId.FACEBOOK */:\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */:\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */:\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */:\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */:\n        case \"anonymous\" /* ProviderId.ANONYMOUS */:\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}) {\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username) {\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */, profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */, profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName) {\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */, profile, screenName);\n    }\n}\n/**\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\n *\n * @param userCredential - The user credential.\n *\n * @public\n */\nfunction getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Non-optional auth methods.\n/**\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\n * `Auth` session and applies this type of persistence for future sign-in requests, including\n * sign-in with redirect requests.\n *\n * @remarks\n * This makes it easy for a user signing in to specify whether their session should be\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\n * that are shared by other users or have sensitive data.\n *\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @example\n * ```javascript\n * setPersistence(auth, browserSessionPersistence);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param persistence - The {@link Persistence} to use.\n * @returns A `Promise` that resolves once the persistence change has completed\n *\n * @public\n */\nfunction setPersistence(auth, persistence) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\n}\n/**\n * Loads the reCAPTCHA configuration into the `Auth` instance.\n *\n * @remarks\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\n * verification flow should be triggered for each auth provider, into the\n * current Auth session.\n *\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\n * auth flows.\n *\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\n *\n * This method does not work in a Node.js environment.\n *\n * @example\n * ```javascript\n * initializeRecaptchaConfig(auth);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\n * Validates the password against the password policy configured for the project or tenant.\n *\n * @remarks\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\n * policy configured for the project. Otherwise, this method will use the policy configured\n * for the tenant. If a password policy has not been configured, then the default policy\n * configured for all projects will be used.\n *\n * If an auth flow fails because a submitted password does not meet the password policy\n * requirements and this method has previously been called, then this method will use the\n * most recent policy available when called again.\n *\n * @example\n * ```javascript\n * validatePassword(auth, 'some-password');\n * ```\n *\n * @param auth The {@link Auth} instance.\n * @param password The password to validate.\n *\n * @public\n */\nasync function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\n * Adds an observer for changes to the signed-in user's ID token.\n *\n * @remarks\n * This includes sign-in, sign-out, and token refresh events.\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\n * Adds a blocking callback that runs before an auth state change\n * sets a new user.\n *\n * @param auth - The {@link Auth} instance.\n * @param callback - callback triggered before new user value is set.\n *   If this throws, it blocks the user from being set.\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\n *   callback throws, allowing you to undo any side effects.\n */\nfunction beforeAuthStateChanged(auth, callback, onAbort) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\n * Adds an observer for changes to the user's sign-in state.\n *\n * @remarks\n * To keep the old behavior, see {@link onIdTokenChanged}.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\n * Sets the current language to the default device/browser preference.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction useDeviceLanguage(auth) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\n}\n/**\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\n * {@link Auth} instance.\n *\n * @remarks\n * A new instance copy of the user provided will be made and set as currentUser.\n *\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\n * like other sign in methods.\n *\n * The operation fails with an error if the user to be updated belongs to a different Firebase\n * project.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param user - The new {@link User}.\n *\n * @public\n */\nfunction updateCurrentUser(auth, user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\n}\n/**\n * Signs out the current user.\n *\n * @remarks\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction signOut(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\n}\n/**\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n *\n * @param auth - The {@link Auth} instance.\n * @param token - The Apple OAuth access token.\n *\n * @public\n */\nfunction revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\n * Deletes and signs out the user.\n *\n * @remarks\n * Important: this is a security-sensitive operation that requires the user to have recently\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function deleteUser(user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorSessionImpl {\n    constructor(type, credential, user) {\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */, idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */\n            ? 'idToken'\n            : 'pendingCredential';\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            }\n            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver) {\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */\n    static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion) => {\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch (error.operationType) {\n                case \"signIn\" /* OperationType.SIGN_IN */:\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */:\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\n * Provides a {@link MultiFactorResolver} suitable for completion of a\n * multi-factor flow.\n *\n * @param auth - The {@link Auth} instance.\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\n * reauthentication operation.\n *\n * @public\n */\nfunction getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorUserImpl {\n    constructor(user) {\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload(userInfo => {\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = (await this.getSession());\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\n * The {@link MultiFactorUser} corresponding to the user.\n *\n * @remarks\n * This is used to access all multi-factor properties and operations related to the user.\n *\n * @param user - The user.\n *\n * @public\n */\nfunction multiFactor(user) {\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\n\nvar name = \"@firebase/auth\";\nvar version = \"1.10.7\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthInterop {\n    constructor(auth) {\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return { accessToken };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged(user => {\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        }\n        else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getVersionForPlatform(clientPlatform) {\n    switch (clientPlatform) {\n        case \"Node\" /* ClientPlatform.NODE */:\n            return 'node';\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */:\n            return 'rn';\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            return 'webworker';\n        case \"Cordova\" /* ClientPlatform.CORDOVA */:\n            return 'cordova';\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */:\n            return 'web-extension';\n        default:\n            return undefined;\n    }\n}\n/** @internal */\nfunction registerAuth(clientPlatform) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */, (container, { options: deps }) => {\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        const appCheckServiceProvider = container.getProvider('app-check-internal');\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(':'), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        /**\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\n         * For why we do this, See go/firebase-next-auth-init\n         */\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Because all firebase products that depend on auth depend on auth-internal directly,\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\n         */\n        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */);\n        authInternalProvider.initialize();\n    }));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */, container => {\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */).getImmediate());\n        return (auth => new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(fetch, Headers, Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app);\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)('auth');\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */);\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */\nconst NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n/** Reject with auth/operation-not-supported-in-this-environment */\nasync function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\n * A class which will throw with\n * auth/operation-not-supported-in-this-environment if instantiated\n */\nclass FailClass {\n    constructor() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst browserCookiePersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async () => { };\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorAssertionImpl {\n    constructor(factorId) {\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch (session.type) {\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */:\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */:\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail('unexpected MultiFactorSessionType');\n        }\n    }\n}\n\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * @public\n */\nclass TotpMultiFactorGenerator {\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\n     * the TOTP (time-based one-time password) second factor.\n     * This assertion is used to complete enrollment in TOTP second factor.\n     *\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorUser.enroll}.\n     */\n    static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\n     * This assertion is used to complete signIn with TOTP as the second factor.\n     *\n     * @param enrollmentId identifies the enrolled TOTP second factor.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorResolver.resolveSignIn}.\n     */\n    static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\n     * Used for generating a QR code URL or inputting into a TOTP app.\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\n     *\n     * @param session The {@link MultiFactorSession} that the user is part of.\n     * @returns A promise to {@link TotpSecret}.\n     */\n    static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\n * The identifier of the TOTP second factor: `totp`.\n */\nTotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret) {\n        super(\"totp\" /* FactorId.TOTP */);\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */\n    static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */\n    static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */\n    async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== 'undefined', auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */\n    async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        const totpVerificationInfo = { verificationCode: this.otp };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * Stores the shared secret key and other parameters to generate time-based OTPs.\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\n * @public\n */\nclass TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */\n    static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */\n    _makeTotpVerificationInfo(otp) {\n        return { sessionInfo: this.sessionInfo, verificationCode: otp };\n    }\n    /**\n     * Returns a QR code URL as described in\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\n     *\n     * @param accountName the name of the account/app along with a user identifier.\n     * @param issuer issuer of the TOTP (likely the app name).\n     * @returns A QR code URL string.\n     */\n    generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */\nfunction _isEmptyString(input) {\n    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n\n\n//# sourceMappingURL=totp-18137433.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vdG90cC0xODEzNzQzMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2SDtBQUNxTjtBQUNuVDtBQUNpQjtBQUNJOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxpQkFBaUI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDLGdDQUFnQyxzREFBVyxDQUFDLEtBQUssSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEMsaUNBQWlDLHNEQUFXLENBQUMsS0FBSyxJQUFJO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBcUIsaUJBQWlCO0FBQ3pGLHdCQUF3Qix3REFBWTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFlLE1BQU0sNkRBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxFQUFFLDRDQUE0QztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVcsaUJBQWlCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQSxtQ0FBbUMsa0VBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsc0JBQXNCO0FBQ2pIO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEtBQUssR0FBRyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCLEtBQUssS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixrREFBa0Q7QUFDL0UseUJBQXlCLHVEQUF1RDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBb0U7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNWQUFzVjtBQUNuWTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEZBQTBGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFvRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMktBQTJLO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMEJBQTBCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtFQUFrRSxLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLFlBQVksVUFBVSxlQUFlLFVBQVUsT0FBTyxhQUFhLHNCQUFzQixVQUFVLGdCQUFnQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStxRjtBQUMvcUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sb3ZlbW9uZXktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vdG90cC0xODEzNzQzMy5qcz9jNjBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNES19WRVJTSU9OLCBfaXNGaXJlYmFzZVNlcnZlckFwcCwgX2dldFByb3ZpZGVyLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiwgZ2V0QXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNNb2JpbGVDb3Jkb3ZhLCBpc1JlYWN0TmF0aXZlLCBGaXJlYmFzZUVycm9yLCBxdWVyeXN0cmluZywgaXNDbG91ZGZsYXJlV29ya2VyLCBpc0Nsb3VkV29ya3N0YXRpb24sIGdldE1vZHVsYXJJbnN0YW5jZSwgYmFzZTY0RGVjb2RlLCBnZXRVQSwgaXNJRSwgY3JlYXRlU3Vic2NyaWJlLCBkZWVwRXF1YWwsIHBpbmdTZXJ2ZXIsIHVwZGF0ZUVtdWxhdG9yQmFubmVyLCBxdWVyeXN0cmluZ0RlY29kZSwgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVudW0gb2YgZmFjdG9ycyB0aGF0IG1heSBiZSB1c2VkIGZvciBtdWx0aWZhY3RvciBhdXRoZW50aWNhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEZhY3RvcklkID0ge1xuICAgIC8qKiBQaG9uZSBhcyBzZWNvbmQgZmFjdG9yICovXG4gICAgUEhPTkU6ICdwaG9uZScsXG4gICAgVE9UUDogJ3RvdHAnXG59O1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgcHJvdmlkZXJzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgUHJvdmlkZXJJZCA9IHtcbiAgICAvKiogRmFjZWJvb2sgcHJvdmlkZXIgSUQgKi9cbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXG4gICAgLyoqIEdpdEh1YiBwcm92aWRlciBJRCAqL1xuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxuICAgIC8qKiBHb29nbGUgcHJvdmlkZXIgSUQgKi9cbiAgICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgICAvKiogUGFzc3dvcmQgcHJvdmlkZXIgKi9cbiAgICBQQVNTV09SRDogJ3Bhc3N3b3JkJyxcbiAgICAvKiogUGhvbmUgcHJvdmlkZXIgKi9cbiAgICBQSE9ORTogJ3Bob25lJyxcbiAgICAvKiogVHdpdHRlciBwcm92aWRlciBJRCAqL1xuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcbn07XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBzaWduLWluIG1ldGhvZHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBTaWduSW5NZXRob2QgPSB7XG4gICAgLyoqIEVtYWlsIGxpbmsgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBFTUFJTF9MSU5LOiAnZW1haWxMaW5rJyxcbiAgICAvKiogRW1haWwvcGFzc3dvcmQgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBFTUFJTF9QQVNTV09SRDogJ3Bhc3N3b3JkJyxcbiAgICAvKiogRmFjZWJvb2sgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXG4gICAgLyoqIEdpdEh1YiBzaWduIGluIG1ldGhvZCAqL1xuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxuICAgIC8qKiBHb29nbGUgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgICAvKiogUGhvbmUgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBQSE9ORTogJ3Bob25lJyxcbiAgICAvKiogVHdpdHRlciBzaWduIGluIG1ldGhvZCAqL1xuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcbn07XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBvcGVyYXRpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBPcGVyYXRpb25UeXBlID0ge1xuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIGxpbmtpbmcgYW4gYWRkaXRpb25hbCBwcm92aWRlciB0byBhbiBhbHJlYWR5IHNpZ25lZC1pbiB1c2VyLiAqL1xuICAgIExJTks6ICdsaW5rJyxcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyB1c2luZyBhIHByb3ZpZGVyIHRvIHJlYXV0aGVudGljYXRlIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXG4gICAgUkVBVVRIRU5USUNBVEU6ICdyZWF1dGhlbnRpY2F0ZScsXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgc2lnbmluZyBpbiBhIHVzZXIuICovXG4gICAgU0lHTl9JTjogJ3NpZ25Jbidcbn07XG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBlbWFpbCBhY3Rpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBBY3Rpb25Db2RlT3BlcmF0aW9uID0ge1xuICAgIC8qKiBUaGUgZW1haWwgbGluayBzaWduLWluIGFjdGlvbi4gKi9cbiAgICBFTUFJTF9TSUdOSU46ICdFTUFJTF9TSUdOSU4nLFxuICAgIC8qKiBUaGUgcGFzc3dvcmQgcmVzZXQgYWN0aW9uLiAqL1xuICAgIFBBU1NXT1JEX1JFU0VUOiAnUEFTU1dPUkRfUkVTRVQnLFxuICAgIC8qKiBUaGUgZW1haWwgcmV2b2NhdGlvbiBhY3Rpb24uICovXG4gICAgUkVDT1ZFUl9FTUFJTDogJ1JFQ09WRVJfRU1BSUwnLFxuICAgIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xuICAgIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOiAnUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04nLFxuICAgIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xuICAgIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMOiAnVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwnLFxuICAgIC8qKiBUaGUgZW1haWwgdmVyaWZpY2F0aW9uIGFjdGlvbi4gKi9cbiAgICBWRVJJRllfRU1BSUw6ICdWRVJJRllfRU1BSUwnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2RlYnVnRXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1wiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIHJlc3RyaWN0ZWQgdG8gYWRtaW5pc3RyYXRvcnMgb25seS4nLFxuICAgICAgICBbXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi9dOiAnJyxcbiAgICAgICAgW1wiYXBwLW5vdC1hdXRob3JpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BUFBfTk9UX0FVVEhPUklaRUQgKi9dOiBcIlRoaXMgYXBwLCBpZGVudGlmaWVkIGJ5IHRoZSBkb21haW4gd2hlcmUgaXQncyBob3N0ZWQsIGlzIG5vdCBcIiArXG4gICAgICAgICAgICAnYXV0aG9yaXplZCB0byB1c2UgRmlyZWJhc2UgQXV0aGVudGljYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQgQVBJIGtleS4gJyArXG4gICAgICAgICAgICAnUmV2aWV3IHlvdXIga2V5IGNvbmZpZ3VyYXRpb24gaW4gdGhlIEdvb2dsZSBBUEkgY29uc29sZS4nLFxuICAgICAgICBbXCJhcHAtbm90LWluc3RhbGxlZFwiIC8qIEF1dGhFcnJvckNvZGUuQVBQX05PVF9JTlNUQUxMRUQgKi9dOiAnVGhlIHJlcXVlc3RlZCBtb2JpbGUgYXBwbGljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgaWRlbnRpZmllciAoJyArXG4gICAgICAgICAgICAnQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiAnICtcbiAgICAgICAgICAgICd0aGlzIGRldmljZS4nLFxuICAgICAgICBbXCJjYXB0Y2hhLWNoZWNrLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ0FQVENIQV9DSEVDS19GQUlMRUQgKi9dOiAnVGhlIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCwgZXhwaXJlZCwgJyArXG4gICAgICAgICAgICAnYWxyZWFkeSB1c2VkIG9yIHRoZSBkb21haW4gYXNzb2NpYXRlZCB3aXRoIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBsaXN0ICcgK1xuICAgICAgICAgICAgJ29mIHdoaXRlbGlzdGVkIGRvbWFpbnMuJyxcbiAgICAgICAgW1wiY29kZS1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQgKi9dOiAnVGhlIFNNUyBjb2RlIGhhcyBleHBpcmVkLiBQbGVhc2UgcmUtc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgdG8gdHJ5ICcgK1xuICAgICAgICAgICAgJ2FnYWluLicsXG4gICAgICAgIFtcImNvcmRvdmEtbm90LXJlYWR5XCIgLyogQXV0aEVycm9yQ29kZS5DT1JET1ZBX05PVF9SRUFEWSAqL106ICdDb3Jkb3ZhIGZyYW1ld29yayBpcyBub3QgcmVhZHkuJyxcbiAgICAgICAgW1wiY29ycy11bnN1cHBvcnRlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ09SU19VTlNVUFBPUlRFRCAqL106ICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC4nLFxuICAgICAgICBbXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovXTogJ1RoaXMgY3JlZGVudGlhbCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB1c2VyIGFjY291bnQuJyxcbiAgICAgICAgW1wiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovXTogJ1RoZSBjdXN0b20gdG9rZW4gY29ycmVzcG9uZHMgdG8gYSBkaWZmZXJlbnQgYXVkaWVuY2UuJyxcbiAgICAgICAgW1wicmVxdWlyZXMtcmVjZW50LWxvZ2luXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgc2Vuc2l0aXZlIGFuZCByZXF1aXJlcyByZWNlbnQgYXV0aGVudGljYXRpb24uIExvZyBpbiAnICtcbiAgICAgICAgICAgICdhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LicsXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXG4gICAgICAgICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nLFxuICAgICAgICBbXCJkeW5hbWljLWxpbmstbm90LWFjdGl2YXRlZFwiIC8qIEF1dGhFcnJvckNvZGUuRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgKi9dOiAnUGxlYXNlIGFjdGl2YXRlIER5bmFtaWMgTGlua3MgaW4gdGhlIEZpcmViYXNlIENvbnNvbGUgYW5kIGFncmVlIHRvIHRoZSB0ZXJtcyBhbmQgJyArXG4gICAgICAgICAgICAnY29uZGl0aW9ucy4nLFxuICAgICAgICBbXCJlbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OICovXTogJ011bHRpLWZhY3RvciB1c2VycyBtdXN0IGFsd2F5cyBoYXZlIGEgdmVyaWZpZWQgZW1haWwuJyxcbiAgICAgICAgW1wiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuJyxcbiAgICAgICAgW1wiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqL106ICdBdXRoIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCB0byBtYWtlIGEgbmV0d29yayBjYWxsLiBBdXRoIGNhbiAnICtcbiAgICAgICAgICAgICdubyBsb25nZXIgYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGVtdWxhdG9yLiBUcnkgY2FsbGluZyAnICtcbiAgICAgICAgICAgICdcImNvbm5lY3RBdXRoRW11bGF0b3IoKVwiIHNvb25lci4nLFxuICAgICAgICBbXCJleHBpcmVkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5FWFBJUkVEX09PQl9DT0RFICovXTogJ1RoZSBhY3Rpb24gY29kZSBoYXMgZXhwaXJlZC4nLFxuICAgICAgICBbXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9QT1BVUF9SRVFVRVNUICovXTogJ1RoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBkdWUgdG8gYW5vdGhlciBjb25mbGljdGluZyBwb3B1cCBiZWluZyBvcGVuZWQuJyxcbiAgICAgICAgW1wiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hcHAtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUFBfQ1JFREVOVElBTCAqL106ICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGFpbnMgYW4gaW52YWxpZCBhcHBsaWNhdGlvbiB2ZXJpZmllci4nICtcbiAgICAgICAgICAgICcgVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLicsXG4gICAgICAgIFtcImludmFsaWQtYXBwLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9JRCAqL106ICdUaGUgbW9iaWxlIGFwcCBpZGVudGlmaWVyIGlzIG5vdCByZWdpc3RlcmVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXG4gICAgICAgIFtcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovXTogXCJUaGlzIHVzZXIncyBjcmVkZW50aWFsIGlzbid0IHZhbGlkIGZvciB0aGlzIHByb2plY3QuIFRoaXMgY2FuIGhhcHBlbiBcIiArXG4gICAgICAgICAgICBcImlmIHRoZSB1c2VyJ3MgdG9rZW4gaGFzIGJlZW4gdGFtcGVyZWQgd2l0aCwgb3IgaWYgdGhlIHVzZXIgaXNuJ3QgZm9yIFwiICtcbiAgICAgICAgICAgICd0aGUgcHJvamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUEkga2V5LicsXG4gICAgICAgIFtcImludmFsaWQtYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFICovXTogJ1RoZSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyAnICtcbiAgICAgICAgICAgICdpbnZhbGlkLiBQbGVhc2UgcmVzZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSBzbXMgYW5kIGJlIHN1cmUgdG8gdXNlIHRoZSAnICtcbiAgICAgICAgICAgICd2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4nLFxuICAgICAgICBbXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi9dOiAnVGhlIGNvbnRpbnVlIFVSTCBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPUkRPVkFfQ09ORklHVVJBVElPTiAqL106ICdUaGUgZm9sbG93aW5nIENvcmRvdmEgcGx1Z2lucyBtdXN0IGJlIGluc3RhbGxlZCB0byBlbmFibGUgT0F1dGggc2lnbi1pbjogJyArXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvLCBjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4sICcgK1xuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJyb3dzZXJ0YWIsIGNvcmRvdmEtcGx1Z2luLWluYXBwYnJvd3NlciBhbmQgJyArXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tY3VzdG9tdXJsc2NoZW1lLicsXG4gICAgICAgIFtcImludmFsaWQtY3VzdG9tLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NVU1RPTV9UT0tFTiAqL106ICdUaGUgY3VzdG9tIHRva2VuIGZvcm1hdCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBjaGVjayB0aGUgZG9jdW1lbnRhdGlvbi4nLFxuICAgICAgICBbXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqL106ICdUaGUgcHJvdmlkZWQgZHluYW1pYyBsaW5rIGRvbWFpbiBpcyBub3QgY29uZmlndXJlZCBvciBhdXRob3JpemVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXG4gICAgICAgIFtcImludmFsaWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUwgKi9dOiAnVGhlIGVtYWlsIGFkZHJlc3MgaXMgYmFkbHkgZm9ybWF0dGVkLicsXG4gICAgICAgIFtcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqL106ICdFbXVsYXRvciBVUkwgbXVzdCBzdGFydCB3aXRoIGEgdmFsaWQgc2NoZW1lIChodHRwOi8vIG9yIGh0dHBzOi8vKS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqL106ICdZb3VyIEFQSSBrZXkgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIHlvdSBoYXZlIGNvcGllZCBpdCBjb3JyZWN0bHkuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jZXJ0LWhhc2hcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ0VSVF9IQVNIICovXTogJ1RoZSBTSEEtMSBjZXJ0aWZpY2F0ZSBoYXNoIHByb3ZpZGVkIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBpbmNvcnJlY3QsIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXG4gICAgICAgIFtcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9QUk9WSURFUiAqL106ICdFbWFpbEF1dGhQcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb24gJyArXG4gICAgICAgICAgICAnb25seSBzdXBwb3J0cyBPQXV0aCBwcm92aWRlcnMuJyxcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogJ1RoZSBPQXV0aCBjbGllbnQgSUQgcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQgb3IgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAgICAgJ3NwZWNpZmllZCBBUEkga2V5LicsXG4gICAgICAgIFtcInVuYXV0aG9yaXplZC1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT1JJR0lOICovXTogJ1RoaXMgZG9tYWluIGlzIG5vdCBhdXRob3JpemVkIGZvciBPQXV0aCBvcGVyYXRpb25zIGZvciB5b3VyIEZpcmViYXNlICcgK1xuICAgICAgICAgICAgJ3Byb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERSAqL106ICdUaGUgYWN0aW9uIGNvZGUgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBjb2RlIGlzIG1hbGZvcm1lZCwgJyArXG4gICAgICAgICAgICAnZXhwaXJlZCwgb3IgaGFzIGFscmVhZHkgYmVlbiB1c2VkLicsXG4gICAgICAgIFtcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEVSU0lTVEVOQ0UgKi9dOiAnVGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlIGlzIGludmFsaWQuIEl0IGNhbiBvbmx5IGJlIGxvY2FsLCBzZXNzaW9uIG9yIG5vbmUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1waG9uZS1udW1iZXJcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEhPTkVfTlVNQkVSICovXTogJ1RoZSBmb3JtYXQgb2YgdGhlIHBob25lIG51bWJlciBwcm92aWRlZCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBlbnRlciB0aGUgJyArXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVyIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHBhcnNlZCBpbnRvIEUuMTY0IGZvcm1hdC4gRS4xNjQgJyArXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVycyBhcmUgd3JpdHRlbiBpbiB0aGUgZm9ybWF0IFsrXVtjb3VudHJ5IGNvZGVdW3N1YnNjcmliZXIgJyArXG4gICAgICAgICAgICAnbnVtYmVyIGluY2x1ZGluZyBhcmVhIGNvZGVdLicsXG4gICAgICAgIFtcImludmFsaWQtcHJvdmlkZXItaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUFJPVklERVJfSUQgKi9dOiAnVGhlIHNwZWNpZmllZCBwcm92aWRlciBJRCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjaXBpZW50LWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0lQSUVOVF9FTUFJTCAqL106ICdUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgJyArXG4gICAgICAgICAgICAncmVjaXBpZW50IGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXNlbmRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRU5ERVIgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgYW4gaW52YWxpZCBzZW5kZXIgZW1haWwgb3IgbmFtZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi9dOiAnVGhlIHZlcmlmaWNhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC10ZW5hbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfVEVOQU5UX0lEICovXTogXCJUaGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRCBpcyBpbnZhbGlkLlwiLFxuICAgICAgICBbXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovXTogJ0xvZ2luIGJsb2NrZWQgYnkgdXNlci1wcm92aWRlZCBtZXRob2Q6IHskb3JpZ2luYWxNZXNzYWdlfScsXG4gICAgICAgIFtcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqL106ICdBbiBBbmRyb2lkIFBhY2thZ2UgTmFtZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZSBBbmRyb2lkIEFwcCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQuJyxcbiAgICAgICAgW1wiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOICovXTogJ0JlIHN1cmUgdG8gaW5jbHVkZSBhdXRoRG9tYWluIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCksICcgK1xuICAgICAgICAgICAgJ2J5IGZvbGxvd2luZyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgICAgIFtcIm1pc3NpbmctYXBwLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NSRURFTlRJQUwgKi9dOiAnVGhlIHBob25lIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGlzIG1pc3NpbmcgYW4gYXBwbGljYXRpb24gdmVyaWZpZXIgJyArXG4gICAgICAgICAgICAnYXNzZXJ0aW9uLiBBIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPREUgKi9dOiAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IFNNUyB2ZXJpZmljYXRpb24gY29kZS4nLFxuICAgICAgICBbXCJtaXNzaW5nLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiAnQSBjb250aW51ZSBVUkwgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdC4nLFxuICAgICAgICBbXCJtaXNzaW5nLWlmcmFtZS1zdGFydFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JRlJBTUVfU1RBUlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSU9TX0JVTkRMRV9JRCAqL106ICdBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLicsXG4gICAgICAgIFtcIm1pc3Npbmctb3ItaW52YWxpZC1ub25jZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19PUl9JTlZBTElEX05PTkNFICovXTogJ1RoZSByZXF1ZXN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBub25jZS4gVGhpcyBjYW4gb2NjdXIgaWYgdGhlICcgK1xuICAgICAgICAgICAgJ1NIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgcmF3IG5vbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBoYXNoZWQgbm9uY2UgJyArXG4gICAgICAgICAgICAnaW4gdGhlIElEIHRva2VuIHBheWxvYWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCAqL106ICdBIG5vbi1lbXB0eSBwYXNzd29yZCBtdXN0IGJlIHByb3ZpZGVkJyxcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqL106ICdObyBzZWNvbmQgZmFjdG9yIGlkZW50aWZpZXIgaXMgcHJvdmlkZWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfU0VTU0lPTiAqL106ICdUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICAgICAgW1wibWlzc2luZy1waG9uZS1udW1iZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEhPTkVfTlVNQkVSICovXTogJ1RvIHNlbmQgdmVyaWZpY2F0aW9uIGNvZGVzLCBwcm92aWRlIGEgcGhvbmUgbnVtYmVyIGZvciB0aGUgcmVjaXBpZW50LicsXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgdmVyaWZpY2F0aW9uIElELicsXG4gICAgICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXV0aEVycm9yQ29kZS5NT0RVTEVfREVTVFJPWUVEICovXTogJ1RoaXMgaW5zdGFuY2Ugb2YgRmlyZWJhc2VBcHAgaGFzIGJlZW4gZGVsZXRlZC4nLFxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCAqL106ICdUaGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgc2Vjb25kIGZhY3RvciBtYXRjaGluZyB0aGUgaWRlbnRpZmllciBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovXTogJ1Byb29mIG9mIG93bmVyc2hpcCBvZiBhIHNlY29uZCBmYWN0b3IgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgc2lnbi1pbi4nLFxuICAgICAgICBbXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqL106ICdBbiBhY2NvdW50IGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgZW1haWwgYWRkcmVzcyBidXQgZGlmZmVyZW50ICcgK1xuICAgICAgICAgICAgJ3NpZ24taW4gY3JlZGVudGlhbHMuIFNpZ24gaW4gdXNpbmcgYSBwcm92aWRlciBhc3NvY2lhdGVkIHdpdGggdGhpcyAnICtcbiAgICAgICAgICAgICdlbWFpbCBhZGRyZXNzLicsXG4gICAgICAgIFtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi9dOiAnQSBuZXR3b3JrIEF1dGhFcnJvciAoc3VjaCBhcyB0aW1lb3V0LCBpbnRlcnJ1cHRlZCBjb25uZWN0aW9uIG9yIHVucmVhY2hhYmxlIGhvc3QpIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJuby1hdXRoLWV2ZW50XCIgLyogQXV0aEVycm9yQ29kZS5OT19BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wibm8tc3VjaC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUiAqL106ICdVc2VyIHdhcyBub3QgbGlua2VkIHRvIGFuIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcbiAgICAgICAgW1wibnVsbC11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5OVUxMX1VTRVIgKi9dOiAnQSBudWxsIHVzZXIgb2JqZWN0IHdhcyBwcm92aWRlZCBhcyB0aGUgYXJndW1lbnQgZm9yIGFuIG9wZXJhdGlvbiB3aGljaCAnICtcbiAgICAgICAgICAgICdyZXF1aXJlcyBhIG5vbi1udWxsIHVzZXIgb2JqZWN0LicsXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEICovXTogJ1RoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuICcgK1xuICAgICAgICAgICAgJ0VuYWJsZSBpdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSwgdW5kZXIgdGhlIHNpZ24taW4gbWV0aG9kIHRhYiBvZiB0aGUgJyArXG4gICAgICAgICAgICAnQXV0aCBzZWN0aW9uLicsXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGVudmlyb25tZW50IHRoaXMgYXBwbGljYXRpb24gaXMgJyArXG4gICAgICAgICAgICAncnVubmluZyBvbi4gXCJsb2NhdGlvbi5wcm90b2NvbFwiIG11c3QgYmUgaHR0cCwgaHR0cHMgb3IgY2hyb21lLWV4dGVuc2lvbicgK1xuICAgICAgICAgICAgJyBhbmQgd2ViIHN0b3JhZ2UgbXVzdCBiZSBlbmFibGVkLicsXG4gICAgICAgIFtcInBvcHVwLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRUQgKi9dOiAnVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci4nLFxuICAgICAgICBbXCJwb3B1cC1jbG9zZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUE9QVVBfQ0xPU0VEX0JZX1VTRVIgKi9dOiAnVGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZyB0aGUgb3BlcmF0aW9uLicsXG4gICAgICAgIFtcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCIgLyogQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRCAqL106ICdVc2VyIGNhbiBvbmx5IGJlIGxpbmtlZCB0byBvbmUgaWRlbnRpdHkgZm9yIHRoZSBnaXZlbiBwcm92aWRlci4nLFxuICAgICAgICBbXCJxdW90YS1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuUVVPVEFfRVhDRUVERUQgKi9dOiBcIlRoZSBwcm9qZWN0J3MgcXVvdGEgZm9yIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLlwiLFxuICAgICAgICBbXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVIgKi9dOiAnVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuJyxcbiAgICAgICAgW1wicmVkaXJlY3Qtb3BlcmF0aW9uLXBlbmRpbmdcIiAvKiBBdXRoRXJyb3JDb2RlLlJFRElSRUNUX09QRVJBVElPTl9QRU5ESU5HICovXTogJ0EgcmVkaXJlY3Qgc2lnbi1pbiBvcGVyYXRpb24gaXMgYWxyZWFkeSBwZW5kaW5nLicsXG4gICAgICAgIFtcInJlamVjdGVkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLlJFSkVDVEVEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHJlcXVlc3QgY29udGFpbnMgbWFsZm9ybWVkIG9yIG1pc21hdGNoaW5nIGNyZWRlbnRpYWxzLicsXG4gICAgICAgIFtcInNlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCAqL106ICdUaGUgc2Vjb25kIGZhY3RvciBpcyBhbHJlYWR5IGVucm9sbGVkIG9uIHRoaXMgYWNjb3VudC4nLFxuICAgICAgICBbXCJtYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi9dOiAnVGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIgb2Ygc2Vjb25kIGZhY3RvcnMgb24gYSB1c2VyIGhhcyBiZWVuIGV4Y2VlZGVkLicsXG4gICAgICAgIFtcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovXTogXCJUaGUgcHJvdmlkZWQgdGVuYW50IElEIGRvZXMgbm90IG1hdGNoIHRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEXCIsXG4gICAgICAgIFtcInRpbWVvdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlRJTUVPVVQgKi9dOiAnVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LicsXG4gICAgICAgIFtcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqL106IFwiVGhlIHVzZXIncyBjcmVkZW50aWFsIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlIHVzZXIgbXVzdCBzaWduIGluIGFnYWluLlwiLFxuICAgICAgICBbXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovXTogJ1dlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gJyArXG4gICAgICAgICAgICAnVHJ5IGFnYWluIGxhdGVyLicsXG4gICAgICAgIFtcInVuYXV0aG9yaXplZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9ET01BSU4gKi9dOiAnVGhlIGRvbWFpbiBvZiB0aGUgY29udGludWUgVVJMIGlzIG5vdCB3aGl0ZWxpc3RlZC4gIFBsZWFzZSB3aGl0ZWxpc3QgJyArXG4gICAgICAgICAgICAndGhlIGRvbWFpbiBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1maXJzdC1mYWN0b3JcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiAqL106ICdFbnJvbGxpbmcgYSBzZWNvbmQgZmFjdG9yIG9yIHNpZ25pbmcgaW4gd2l0aCBhIG11bHRpLWZhY3RvciBhY2NvdW50IHJlcXVpcmVzIHNpZ24taW4gd2l0aCBhIHN1cHBvcnRlZCBmaXJzdCBmYWN0b3IuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfUEVSU0lTVEVOQ0UgKi9dOiAnVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGEgbXVsdGktdGVuYW50IGNvbnRleHQuJyxcbiAgICAgICAgW1widW52ZXJpZmllZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuVU5WRVJJRklFRF9FTUFJTCAqL106ICdUaGUgb3BlcmF0aW9uIHJlcXVpcmVzIGEgdmVyaWZpZWQgZW1haWwuJyxcbiAgICAgICAgW1widXNlci1jYW5jZWxsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfQ0FOQ0VMTEVEICovXTogJ1RoZSB1c2VyIGRpZCBub3QgZ3JhbnQgeW91ciBhcHBsaWNhdGlvbiB0aGUgcGVybWlzc2lvbnMgaXQgcmVxdWVzdGVkLicsXG4gICAgICAgIFtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9dOiAnVGhlcmUgaXMgbm8gdXNlciByZWNvcmQgY29ycmVzcG9uZGluZyB0byB0aGlzIGlkZW50aWZpZXIuIFRoZSB1c2VyIG1heSAnICtcbiAgICAgICAgICAgICdoYXZlIGJlZW4gZGVsZXRlZC4nLFxuICAgICAgICBbXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovXTogJ1RoZSB1c2VyIGFjY291bnQgaGFzIGJlZW4gZGlzYWJsZWQgYnkgYW4gYWRtaW5pc3RyYXRvci4nLFxuICAgICAgICBbXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovXTogJ1RoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci4nLFxuICAgICAgICBbXCJ1c2VyLXNpZ25lZC1vdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfU0lHTkVEX09VVCAqL106ICcnLFxuICAgICAgICBbXCJ3ZWFrLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5XRUFLX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBtdXN0IGJlIDYgY2hhcmFjdGVycyBsb25nIG9yIG1vcmUuJyxcbiAgICAgICAgW1wid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC4nLFxuICAgICAgICBbXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovXTogJ2luaXRpYWxpemVBdXRoKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcbiAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplQXV0aCgpIHdpdGggdGhlICcgK1xuICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRBdXRoKCkgdG8gcmV0dXJuIHRoZScgK1xuICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicsXG4gICAgICAgIFtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL106ICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106ICdUaGUgcmVDQVBUQ0hBIGFjdGlvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcInJlY2FwdGNoYS1ub3QtZW5hYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogJ3JlQ0FQVENIQSBFbnRlcnByaXNlIGludGVncmF0aW9uIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHByb2plY3QuJyxcbiAgICAgICAgW1wibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqL106ICdUaGUgcmVDQVBUQ0hBIGNsaWVudCB0eXBlIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wibWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqL106ICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlcS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFUV9UWVBFICovXTogJ0ludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJzLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtcGFzc3dvcmQtcG9saWN5LXNjaGVtYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gKi9dOiAnVGhlIHBhc3N3b3JkIHBvbGljeSByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kIHVzZXMgYSBzY2hlbWEgdmVyc2lvbiB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBGaXJlYmFzZSBTREsuJyxcbiAgICAgICAgW1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovXTogJ1RoZSBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHRoZSByZXF1aXJlbWVudHMuJyxcbiAgICAgICAgW1wiaW52YWxpZC1ob3N0aW5nLWxpbmstZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0hPU1RJTkdfTElOS19ET01BSU4gKi9dOiAnVGhlIHByb3ZpZGVkIEhvc3RpbmcgbGluayBkb21haW4gaXMgbm90IGNvbmZpZ3VyZWQgaW4gRmlyZWJhc2UgSG9zdGluZyBvciBpcyBub3Qgb3duZWQgYnkgJyArXG4gICAgICAgICAgICAndGhlIGN1cnJlbnQgcHJvamVjdC4gVGhpcyBjYW5ub3QgYmUgYSBkZWZhdWx0IEhvc3RpbmcgZG9tYWluIChgd2ViLmFwcGAgb3IgYGZpcmViYXNlYXBwLmNvbWApLidcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Byb2RFcnJvck1hcCgpIHtcbiAgICAvLyBXZSB3aWxsIGluY2x1ZGUgdGhpcyBvbmUgbWVzc2FnZSBpbiB0aGUgcHJvZCBlcnJvciBtYXAgc2luY2UgYnkgdGhlIHZlcnlcbiAgICAvLyBuYXR1cmUgb2YgdGhpcyBlcnJvciwgZGV2ZWxvcGVycyB3aWxsIG5ldmVyIGJlIGFibGUgdG8gc2VlIHRoZSBtZXNzYWdlXG4gICAgLy8gdXNpbmcgdGhlIGRlYnVnRXJyb3JNYXAgKHdoaWNoIGlzIGluc3RhbGxlZCBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbikuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1wiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovXTogJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLidcbiAgICB9O1xufVxuLyoqXG4gKiBBIHZlcmJvc2UgZXJyb3IgbWFwIHdpdGggZGV0YWlsZWQgZGVzY3JpcHRpb25zIGZvciBtb3N0IGVycm9yIGNvZGVzLlxuICpcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBkZWJ1Z0Vycm9yTWFwID0gX2RlYnVnRXJyb3JNYXA7XG4vKipcbiAqIEEgbWluaW1hbCBlcnJvciBtYXAgd2l0aCBhbGwgdmVyYm9zZSBlcnJvciBtZXNzYWdlcyBzdHJpcHBlZC5cbiAqXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcHJvZEVycm9yTWFwID0gX3Byb2RFcnJvck1hcDtcbmNvbnN0IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBfcHJvZEVycm9yTWFwKCkpO1xuLyoqXG4gKiBBIG1hcCBvZiBwb3RlbnRpYWwgYEF1dGhgIGVycm9yIGNvZGVzLCBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2l0aCBlcnJvcnNcbiAqIHRocm93biBieSB0aGUgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBOb3RlIHRoYXQgeW91IGNhbid0IHRyZWUtc2hha2UgaW5kaXZpZHVhbCBrZXlzXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcbiAqIGJ1bmRsZSBzaXplLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgQVVUSF9FUlJPUl9DT0RFU19NQVBfRE9fTk9UX1VTRV9JTlRFUk5BTExZID0ge1xuICAgIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXG4gICAgQVJHVU1FTlRfRVJST1I6ICdhdXRoL2FyZ3VtZW50LWVycm9yJyxcbiAgICBBUFBfTk9UX0FVVEhPUklaRUQ6ICdhdXRoL2FwcC1ub3QtYXV0aG9yaXplZCcsXG4gICAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcbiAgICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRDogJ2F1dGgvY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxuICAgIENPREVfRVhQSVJFRDogJ2F1dGgvY29kZS1leHBpcmVkJyxcbiAgICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxuICAgIENPUlNfVU5TVVBQT1JURUQ6ICdhdXRoL2NvcnMtdW5zdXBwb3J0ZWQnLFxuICAgIENSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0U6ICdhdXRoL2NyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2UnLFxuICAgIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXG4gICAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOiAnYXV0aC9yZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxuICAgIERFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSDogJ2F1dGgvZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aCcsXG4gICAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcbiAgICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OOiAnYXV0aC9lbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcbiAgICBFTUFJTF9FWElTVFM6ICdhdXRoL2VtYWlsLWFscmVhZHktaW4tdXNlJyxcbiAgICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcbiAgICBFWFBJUkVEX09PQl9DT0RFOiAnYXV0aC9leHBpcmVkLWFjdGlvbi1jb2RlJyxcbiAgICBFWFBJUkVEX1BPUFVQX1JFUVVFU1Q6ICdhdXRoL2NhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0JyxcbiAgICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxuICAgIElOVkFMSURfQVBJX0tFWTogJ2F1dGgvaW52YWxpZC1hcGkta2V5JyxcbiAgICBJTlZBTElEX0FQUF9DUkVERU5USUFMOiAnYXV0aC9pbnZhbGlkLWFwcC1jcmVkZW50aWFsJyxcbiAgICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxuICAgIElOVkFMSURfQVVUSDogJ2F1dGgvaW52YWxpZC11c2VyLXRva2VuJyxcbiAgICBJTlZBTElEX0FVVEhfRVZFTlQ6ICdhdXRoL2ludmFsaWQtYXV0aC1ldmVudCcsXG4gICAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcbiAgICBJTlZBTElEX0NPREU6ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfQ09OVElOVUVfVVJJOiAnYXV0aC9pbnZhbGlkLWNvbnRpbnVlLXVyaScsXG4gICAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcbiAgICBJTlZBTElEX0NVU1RPTV9UT0tFTjogJ2F1dGgvaW52YWxpZC1jdXN0b20tdG9rZW4nLFxuICAgIElOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTjogJ2F1dGgvaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluJyxcbiAgICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcbiAgICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRTogJ2F1dGgvaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxuICAgIElOVkFMSURfSURQX1JFU1BPTlNFOiAnYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWwnLFxuICAgIElOVkFMSURfTE9HSU5fQ1JFREVOVElBTFM6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXG4gICAgSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6ICdhdXRoL2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcbiAgICBJTlZBTElEX01GQV9TRVNTSU9OOiAnYXV0aC9pbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxuICAgIElOVkFMSURfT0FVVEhfUFJPVklERVI6ICdhdXRoL2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxuICAgIElOVkFMSURfT09CX0NPREU6ICdhdXRoL2ludmFsaWQtYWN0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcbiAgICBJTlZBTElEX1BBU1NXT1JEOiAnYXV0aC93cm9uZy1wYXNzd29yZCcsXG4gICAgSU5WQUxJRF9QRVJTSVNURU5DRTogJ2F1dGgvaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxuICAgIElOVkFMSURfUFJPVklERVJfSUQ6ICdhdXRoL2ludmFsaWQtcHJvdmlkZXItaWQnLFxuICAgIElOVkFMSURfUkVDSVBJRU5UX0VNQUlMOiAnYXV0aC9pbnZhbGlkLXJlY2lwaWVudC1lbWFpbCcsXG4gICAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcbiAgICBJTlZBTElEX1NFU1NJT05fSU5GTzogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxuICAgIElOVkFMSURfVEVOQU5UX0lEOiAnYXV0aC9pbnZhbGlkLXRlbmFudC1pZCcsXG4gICAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxuICAgIE1GQV9SRVFVSVJFRDogJ2F1dGgvbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxuICAgIE1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUU6ICdhdXRoL21pc3NpbmctYW5kcm9pZC1wa2ctbmFtZScsXG4gICAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXG4gICAgTUlTU0lOR19BVVRIX0RPTUFJTjogJ2F1dGgvYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcbiAgICBNSVNTSU5HX0NPREU6ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXG4gICAgTUlTU0lOR19JRlJBTUVfU1RBUlQ6ICdhdXRoL21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcbiAgICBNSVNTSU5HX0lPU19CVU5ETEVfSUQ6ICdhdXRoL21pc3NpbmctaW9zLWJ1bmRsZS1pZCcsXG4gICAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxuICAgIE1JU1NJTkdfTUZBX0lORk86ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxuICAgIE1JU1NJTkdfTUZBX1NFU1NJT046ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICAgIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXG4gICAgTUlTU0lOR19TRVNTSU9OX0lORk86ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcbiAgICBNT0RVTEVfREVTVFJPWUVEOiAnYXV0aC9hcHAtZGVsZXRlZCcsXG4gICAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxuICAgIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQ6ICdhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxuICAgIE5VTExfVVNFUjogJ2F1dGgvbnVsbC11c2VyJyxcbiAgICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcbiAgICBOT19TVUNIX1BST1ZJREVSOiAnYXV0aC9uby1zdWNoLXByb3ZpZGVyJyxcbiAgICBPUEVSQVRJT05fTk9UX0FMTE9XRUQ6ICdhdXRoL29wZXJhdGlvbi1ub3QtYWxsb3dlZCcsXG4gICAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxuICAgIFBPUFVQX0JMT0NLRUQ6ICdhdXRoL3BvcHVwLWJsb2NrZWQnLFxuICAgIFBPUFVQX0NMT1NFRF9CWV9VU0VSOiAnYXV0aC9wb3B1cC1jbG9zZWQtYnktdXNlcicsXG4gICAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcbiAgICBRVU9UQV9FWENFRURFRDogJ2F1dGgvcXVvdGEtZXhjZWVkZWQnLFxuICAgIFJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSOiAnYXV0aC9yZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlcicsXG4gICAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcbiAgICBSRUpFQ1RFRF9DUkVERU5USUFMOiAnYXV0aC9yZWplY3RlZC1jcmVkZW50aWFsJyxcbiAgICBTRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQ6ICdhdXRoL3NlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2UnLFxuICAgIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXG4gICAgVEVOQU5UX0lEX01JU01BVENIOiAnYXV0aC90ZW5hbnQtaWQtbWlzbWF0Y2gnLFxuICAgIFRJTUVPVVQ6ICdhdXRoL3RpbWVvdXQnLFxuICAgIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXG4gICAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOiAnYXV0aC90b28tbWFueS1yZXF1ZXN0cycsXG4gICAgVU5BVVRIT1JJWkVEX0RPTUFJTjogJ2F1dGgvdW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaScsXG4gICAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxuICAgIFVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFOiAnYXV0aC91bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBVTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OOiAnYXV0aC91bnN1cHBvcnRlZC10ZW5hbnQtb3BlcmF0aW9uJyxcbiAgICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcbiAgICBVU0VSX0NBTkNFTExFRDogJ2F1dGgvdXNlci1jYW5jZWxsZWQnLFxuICAgIFVTRVJfREVMRVRFRDogJ2F1dGgvdXNlci1ub3QtZm91bmQnLFxuICAgIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxuICAgIFVTRVJfTUlTTUFUQ0g6ICdhdXRoL3VzZXItbWlzbWF0Y2gnLFxuICAgIFVTRVJfU0lHTkVEX09VVDogJ2F1dGgvdXNlci1zaWduZWQtb3V0JyxcbiAgICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcbiAgICBXRUJfU1RPUkFHRV9VTlNVUFBPUlRFRDogJ2F1dGgvd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxuICAgIEFMUkVBRFlfSU5JVElBTElaRUQ6ICdhdXRoL2FscmVhZHktaW5pdGlhbGl6ZWQnLFxuICAgIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS10b2tlbicsXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxuICAgIE1JU1NJTkdfQ0xJRU5UX1RZUEU6ICdhdXRoL21pc3NpbmctY2xpZW50LXR5cGUnLFxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL21pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVRX1RZUEU6ICdhdXRoL2ludmFsaWQtcmVxLXR5cGUnLFxuICAgIElOVkFMSURfSE9TVElOR19MSU5LX0RPTUFJTjogJ2F1dGgvaW52YWxpZC1ob3N0aW5nLWxpbmstZG9tYWluJ1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hdXRoJyk7XG5mdW5jdGlvbiBfbG9nV2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgbG9nQ2xpZW50Lndhcm4oYEF1dGggKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2xvZ0Vycm9yKG1zZywgLi4uYXJncykge1xuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9mYWlsKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUVycm9yKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnJvck1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvZEVycm9yTWFwKCkpLCB7IFtjb2RlXTogbWVzc2FnZSB9KTtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IEVycm9yRmFjdG9yeSgnYXV0aCcsICdGaXJlYmFzZScsIGVycm9yTWFwKTtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUoY29kZSwge1xuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpIHtcbiAgICByZXR1cm4gX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UoYXV0aCwgXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLywgJ09wZXJhdGlvbnMgdGhhdCBhbHRlciB0aGUgY3VycmVudCB1c2VyIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNvbmp1bmN0aW9uIHdpdGggRmlyZWJhc2VTZXJ2ZXJBcHAnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xuICAgIGlmICh0eXBlb2YgYXV0aE9yQ29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHJlc3RbMF07XG4gICAgICAgIGNvbnN0IGZ1bGxQYXJhbXMgPSBbLi4ucmVzdC5zbGljZSgxKV07XG4gICAgICAgIGlmIChmdWxsUGFyYW1zWzBdKSB7XG4gICAgICAgICAgICBmdWxsUGFyYW1zWzBdLmFwcE5hbWUgPSBhdXRoT3JDb2RlLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGhPckNvZGUuX2Vycm9yRmFjdG9yeS5jcmVhdGUoY29kZSwgLi4uZnVsbFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkuY3JlYXRlKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gX2Fzc2VydChhc3NlcnRpb24sIGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xuICAgIH1cbn1cbi8qKlxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBpbnRlcm5hbCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBmYWlsdXJlIHR5cGUgb2YgZmFpbHVyZSBlbmNvdW50ZXJlZFxuICogQHRocm93cyBFcnJvclxuICovXG5mdW5jdGlvbiBkZWJ1Z0ZhaWwoZmFpbHVyZSkge1xuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcbiAgICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgSU5URVJOQUwgQVNTRVJUSU9OIEZBSUxFRDogYCArIGZhaWx1cmU7XG4gICAgX2xvZ0Vycm9yKG1lc3NhZ2UpO1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlYmFzZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxuICpcbiAqIEBwYXJhbSBhc3NlcnRpb25cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIGRlYnVnRmFpbChtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZ2V0Q3VycmVudFVybCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHNlbGYubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkgfHwgJyc7XG59XG5mdW5jdGlvbiBfaXNIdHRwT3JIdHRwcygpIHtcbiAgICByZXR1cm4gX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHA6JyB8fCBfZ2V0Q3VycmVudFNjaGVtZSgpID09PSAnaHR0cHM6Jztcbn1cbmZ1bmN0aW9uIF9nZXRDdXJyZW50U2NoZW1lKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvY29sKSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgd29ya2luZyBvbmxpbmVcbiAqL1xuZnVuY3Rpb24gX2lzT25saW5lKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBuYXZpZ2F0b3IgJiZcbiAgICAgICAgJ29uTGluZScgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3Iub25MaW5lID09PSAnYm9vbGVhbicgJiZcbiAgICAgICAgLy8gQXBwbHkgb25seSBmb3IgdHJhZGl0aW9uYWwgd2ViIGFwcHMgYW5kIENocm9tZSBleHRlbnNpb25zLlxuICAgICAgICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgdHJ1ZSBmb3IgQ29yZG92YSBhcHBzIHdoaWNoIGhhdmUgdW5yZWxpYWJsZVxuICAgICAgICAvLyBuYXZpZ2F0b3Iub25MaW5lIGJlaGF2aW9yIHVubGVzcyBjb3Jkb3ZhLXBsdWdpbi1uZXR3b3JrLWluZm9ybWF0aW9uIGlzXG4gICAgICAgIC8vIGluc3RhbGxlZCB3aGljaCBvdmVyd3JpdGVzIHRoZSBuYXRpdmUgbmF2aWdhdG9yLm9uTGluZSB2YWx1ZSBhbmRcbiAgICAgICAgLy8gZGVmaW5lcyBuYXZpZ2F0b3IuY29ubmVjdGlvbi5cbiAgICAgICAgKF9pc0h0dHBPckh0dHBzKCkgfHwgaXNCcm93c2VyRXh0ZW5zaW9uKCkgfHwgJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5vbkxpbmU7XG4gICAgfVxuICAgIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc3RhdGUsIGFzc3VtZSBpdCBpcyBvbmxpbmUuXG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBfZ2V0VXNlckxhbmd1YWdlKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbmF2aWdhdG9yTGFuZ3VhZ2UgPSBuYXZpZ2F0b3I7XG4gICAgcmV0dXJuIChcbiAgICAvLyBNb3N0IHJlbGlhYmxlLCBidXQgb25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lL0ZpcmVmb3guXG4gICAgKG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZXNbMF0pIHx8XG4gICAgICAgIC8vIFN1cHBvcnRlZCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmV0dXJucyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gVUksIG5vdCB0aGUgbGFuZ3VhZ2Ugc2V0IGluIGJyb3dzZXIgc2V0dGluZ3MuXG4gICAgICAgIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlIHx8XG4gICAgICAgIC8vIENvdWxkbid0IGRldGVybWluZSBsYW5ndWFnZS5cbiAgICAgICAgbnVsbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgc3RydWN0dXJlIHRvIGhlbHAgcGljayBiZXR3ZWVuIGEgcmFuZ2Ugb2YgbG9uZyBhbmQgc2hvcnQgZGVsYXkgZHVyYXRpb25zXG4gKiBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIGdlbmVyYWwsIHRoZSBsb25nIGRlbGF5IGlzIHVzZWQgZm9yXG4gKiBtb2JpbGUgZW52aXJvbm1lbnRzIHdoZXJlYXMgc2hvcnQgZGVsYXlzIGFyZSB1c2VkIGZvciBkZXNrdG9wIGVudmlyb25tZW50cy5cbiAqL1xuY2xhc3MgRGVsYXkge1xuICAgIGNvbnN0cnVjdG9yKHNob3J0RGVsYXksIGxvbmdEZWxheSkge1xuICAgICAgICB0aGlzLnNob3J0RGVsYXkgPSBzaG9ydERlbGF5O1xuICAgICAgICB0aGlzLmxvbmdEZWxheSA9IGxvbmdEZWxheTtcbiAgICAgICAgLy8gSW50ZXJuYWwgZXJyb3Igd2hlbiBpbXByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgICAgICBkZWJ1Z0Fzc2VydChsb25nRGVsYXkgPiBzaG9ydERlbGF5LCAnU2hvcnQgZGVsYXkgc2hvdWxkIGJlIGxlc3MgdGhhbiBsb25nIGRlbGF5IScpO1xuICAgICAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGVDb3Jkb3ZhKCkgfHwgaXNSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGlmICghX2lzT25saW5lKCkpIHtcbiAgICAgICAgICAgIC8vIFBpY2sgdGhlIHNob3J0ZXIgdGltZW91dC5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbig1MDAwIC8qIERlbGF5TWluLk9GRkxJTkUgKi8sIHRoaXMuc2hvcnREZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcnVubmluZyBpbiBhIG1vYmlsZSBlbnZpcm9ubWVudCwgcmV0dXJuIHRoZSBsb25nIGRlbGF5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzaG9ydCBkZWxheS5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCBpbiB0aGUgZnV0dXJlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBiYXNlZCBvbiBvdGhlclxuICAgICAgICAvLyB2YXJpYWJsZXMgaW5zdGVhZCBvZiBqdXN0IHJlYWRpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gdGhpcy5sb25nRGVsYXkgOiB0aGlzLnNob3J0RGVsYXk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2VtdWxhdG9yVXJsKGNvbmZpZywgcGF0aCkge1xuICAgIGRlYnVnQXNzZXJ0KGNvbmZpZy5lbXVsYXRvciwgJ0VtdWxhdG9yIHNob3VsZCBhbHdheXMgYmUgc2V0IGhlcmUnKTtcbiAgICBjb25zdCB7IHVybCB9ID0gY29uZmlnLmVtdWxhdG9yO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dXJsfSR7cGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmV0Y2hQcm92aWRlciB7XG4gICAgc3RhdGljIGluaXRpYWxpemUoZmV0Y2hJbXBsLCBoZWFkZXJzSW1wbCwgcmVzcG9uc2VJbXBsKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsID0gZmV0Y2hJbXBsO1xuICAgICAgICBpZiAoaGVhZGVyc0ltcGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc0ltcGwgPSBoZWFkZXJzSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlSW1wbCA9IHJlc3BvbnNlSW1wbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZmV0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2ZldGNoJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5mZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmZldGNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBmZXRjaCBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgc3RhdGljIGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdIZWFkZXJzJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5IZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5IZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5IZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgSGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBIZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgSGVhZGVycyBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgc3RhdGljIHJlc3BvbnNlKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdSZXNwb25zZScgaW4gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLlJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5SZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgUmVzcG9uc2UgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBNYXAgZnJvbSBlcnJvcnMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byBlcnJvcnMgdG8gZGV2ZWxvcGVyIHZpc2libGUgZXJyb3JzXG4gKi9cbmNvbnN0IFNFUlZFUl9FUlJPUl9NQVAgPSB7XG4gICAgLy8gQ3VzdG9tIHRva2VuIGVycm9ycy5cbiAgICBbXCJDUkVERU5USUFMX01JU01BVENIXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9NSVNNQVRDSCAqL106IFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX0NVU1RPTV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ1VTVE9NX1RPS0VOICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gQ3JlYXRlIEF1dGggVVJJIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX0lERU5USUZJRVJcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lERU5USUZJRVIgKi9dOiBcImludmFsaWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUwgKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfQ09OVElOVUVfVVJJXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBTaWduIGluIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycyAoc29tZSBhcHBseSB0byBzaWduIHVwIHRvbykuXG4gICAgW1wiSU5WQUxJRF9QQVNTV09SRFwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUEFTU1dPUkQgKi9dOiBcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX1BBU1NXT1JEXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19QQVNTV09SRCAqL106IFwibWlzc2luZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCAqLyxcbiAgICAvLyBUaHJvd24gaWYgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbiBpcyBlbmFibGVkIGluIHRoZSBwcm9qZWN0IGFuZCB0aGUgZW1haWwgb3IgcGFzc3dvcmQgaXNcbiAgICAvLyBpbnZhbGlkLlxuICAgIFtcIklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFNcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0xPR0lOX0NSRURFTlRJQUxTICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcbiAgICAvLyBTaWduIHVwIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycy5cbiAgICBbXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi9dOiBcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi8sXG4gICAgW1wiUEFTU1dPUkRfTE9HSU5fRElTQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5QQVNTV09SRF9MT0dJTl9ESVNBQkxFRCAqL106IFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRUQgKi8sXG4gICAgLy8gVmVyaWZ5IGFzc2VydGlvbiBmb3Igc2lnbiBpbiB3aXRoIGNyZWRlbnRpYWwgZXJyb3JzOlxuICAgIFtcIklOVkFMSURfSURQX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRFBfUkVTUE9OU0UgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxuICAgIFtcIklOVkFMSURfUEVORElOR19UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUEVORElOR19UT0tFTiAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgW1wiRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURcIiAvKiBTZXJ2ZXJFcnJvci5GRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCAqL106IFwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVRX1RZUEUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBTZW5kIFBhc3N3b3JkIHJlc2V0IGVtYWlsIGVycm9yczpcbiAgICBbXCJFTUFJTF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi8sXG4gICAgW1wiUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUXCIgLyogU2VydmVyRXJyb3IuUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUICovXTogXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovLFxuICAgIFtcIkVYUElSRURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5FWFBJUkVEX09PQl9DT0RFICovXTogXCJleHBpcmVkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5FWFBJUkVEX09PQl9DT0RFICovLFxuICAgIFtcIklOVkFMSURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09PQl9DT0RFICovXTogXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19PT0JfQ09ERSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIE9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIElEIHRva2VuIGluIHJlcXVlc3Q6XG4gICAgW1wiQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovXTogXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqLyxcbiAgICBbXCJJTlZBTElEX0lEX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRF9UT0tFTiAqL106IFwiaW52YWxpZC11c2VyLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEggKi8sXG4gICAgW1wiVE9LRU5fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlRPS0VOX0VYUElSRUQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcbiAgICBbXCJVU0VSX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EICovXTogXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8sXG4gICAgLy8gT3RoZXIgZXJyb3JzLlxuICAgIFtcIlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUlwiIC8qIFNlcnZlckVycm9yLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106IFwidG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqLyxcbiAgICBbXCJQQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UU1wiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovXTogXCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi8sXG4gICAgLy8gUGhvbmUgQXV0aCByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0NPREUgKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSAqLyxcbiAgICBbXCJJTlZBTElEX1NFU1NJT05fSU5GT1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi8sXG4gICAgW1wiSU5WQUxJRF9URU1QT1JBUllfUFJPT0ZcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1RFTVBPUkFSWV9QUk9PRiAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgW1wiTUlTU0lOR19TRVNTSU9OX0lORk9cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106IFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovLFxuICAgIFtcIlNFU1NJT05fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlNFU1NJT05fRVhQSVJFRCAqL106IFwiY29kZS1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQgKi8sXG4gICAgLy8gT3RoZXIgYWN0aW9uIGNvZGUgZXJyb3JzIHdoZW4gYWRkaXRpb25hbCBzZXR0aW5ncyBwYXNzZWQuXG4gICAgLy8gTUlTU0lOR19DT05USU5VRV9VUkkgaXMgZ2V0dGluZyBtYXBwZWQgdG8gSU5URVJOQUxfRVJST1IgYWJvdmUuXG4gICAgLy8gVGhpcyBpcyBPSyBhcyB0aGlzIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXG4gICAgW1wiTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi9dOiBcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqLyxcbiAgICBbXCJVTkFVVEhPUklaRURfRE9NQUlOXCIgLyogU2VydmVyRXJyb3IuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106IFwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqLyxcbiAgICAvLyBnZXRQcm9qZWN0Q29uZmlnIGVycm9ycyB3aGVuIGNsaWVudElkIGlzIHBhc3NlZC5cbiAgICBbXCJJTlZBTElEX09BVVRIX0NMSUVOVF9JRFwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogXCJpbnZhbGlkLW9hdXRoLWNsaWVudC1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgKi8sXG4gICAgLy8gVXNlciBhY3Rpb25zIChzaWduLXVwIG9yIGRlbGV0aW9uKSBkaXNhYmxlZCBlcnJvcnMuXG4gICAgW1wiQURNSU5fT05MWV9PUEVSQVRJT05cIiAvKiBTZXJ2ZXJFcnJvci5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106IFwiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovLFxuICAgIC8vIE11bHRpIGZhY3RvciByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi8sXG4gICAgW1wiTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EICovXTogXCJtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCAqLyxcbiAgICBbXCJNSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRCAqL106IFwibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqLyxcbiAgICBbXCJNSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04gKi8sXG4gICAgW1wiU0VDT05EX0ZBQ1RPUl9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0VYSVNUUyAqL106IFwic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovLFxuICAgIFtcIlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERURcIiAvKiBTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovXTogXCJtYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi8sXG4gICAgLy8gQmxvY2tpbmcgZnVuY3Rpb25zIHJlbGF0ZWQgZXJyb3JzLlxuICAgIFtcIkJMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0UgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBSZWNhcHRjaGEgcmVsYXRlZCBlcnJvcnMuXG4gICAgW1wiUkVDQVBUQ0hBX05PVF9FTkFCTEVEXCIgLyogU2VydmVyRXJyb3IuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqLyxcbiAgICBbXCJNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi8sXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovLFxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi8sXG4gICAgW1wiTUlTU0lOR19DTElFTlRfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi9dOiBcIm1pc3NpbmctY2xpZW50LXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi8sXG4gICAgW1wiTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcIm1pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXG4gICAgW1wiSU5WQUxJRF9SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVRX1RZUEUgKi9dOiBcImludmFsaWQtcmVxLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEUgKi9cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBDb29raWVBdXRoUHJveGllZEVuZHBvaW50cyA9IFtcbiAgICBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoQ3VzdG9tVG9rZW5cIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfQ1VTVE9NX1RPS0VOICovLFxuICAgIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmtcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyAqLyxcbiAgICBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoSWRwXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0lEUCAqLyxcbiAgICBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEFTU1dPUkQgKi8sXG4gICAgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLyxcbiAgICBcIi92MS90b2tlblwiIC8qIEVuZHBvaW50LlRPS0VOICovXG5dO1xuY29uc3QgREVGQVVMVF9BUElfVElNRU9VVF9NUyA9IG5ldyBEZWxheSgzMDAwMCwgNjAwMDApO1xuZnVuY3Rpb24gX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpIHtcbiAgICBpZiAoYXV0aC50ZW5hbnRJZCAmJiAhcmVxdWVzdC50ZW5hbnRJZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyB0ZW5hbnRJZDogYXV0aC50ZW5hbnRJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCA9IHt9KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgYm9keSA9IHt9O1xuICAgICAgICBsZXQgcGFyYW1zID0ge307XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5c3RyaW5nKE9iamVjdC5hc3NpZ24oeyBrZXk6IGF1dGguY29uZmlnLmFwaUtleSB9LCBwYXJhbXMpKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIGlmIChhdXRoLmxhbmd1YWdlQ29kZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtTG9jYWxlXCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0xPQ0FMRSAqL10gPSBhdXRoLmxhbmd1YWdlQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZXRjaEFyZ3MgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyB9LCBib2R5KTtcbiAgICAgICAgLyogU2VjdXJpdHktY29uc2Npb3VzIHNlcnZlci1zaWRlIGZyYW1ld29ya3MgdGVuZCB0byBoYXZlIGJ1aWx0IGluIG1pdGlnYXRpb25zIGZvciByZWZlcnJlclxuICAgICAgICAgICBwcm9ibGVtc1wiLiBTZWUgdGhlIENsb3VkZmxhcmUgR2l0SHViIGlzc3VlICM0ODc6IEVycm9yOiBUaGUgJ3JlZmVycmVyUG9saWN5JyBmaWVsZCBvblxuICAgICAgICAgICAnUmVxdWVzdEluaXRpYWxpemVyRGljdCcgaXMgbm90IGltcGxlbWVudGVkLlwiXG4gICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL25leHQtb24tcGFnZXMvaXNzdWVzLzQ4NyAqL1xuICAgICAgICBpZiAoIWlzQ2xvdWRmbGFyZVdvcmtlcigpKSB7XG4gICAgICAgICAgICBmZXRjaEFyZ3MucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRoLmVtdWxhdG9yQ29uZmlnICYmIGlzQ2xvdWRXb3Jrc3RhdGlvbihhdXRoLmVtdWxhdG9yQ29uZmlnLmhvc3QpKSB7XG4gICAgICAgICAgICBmZXRjaEFyZ3MuY3JlZGVudGlhbHMgPSAnaW5jbHVkZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZldGNoUHJvdmlkZXIuZmV0Y2goKShhd2FpdCBfZ2V0RmluYWxUYXJnZXQoYXV0aCwgYXV0aC5jb25maWcuYXBpSG9zdCwgcGF0aCwgcXVlcnkpLCBmZXRjaEFyZ3MpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIGN1c3RvbUVycm9yTWFwLCBmZXRjaEZuKSB7XG4gICAgYXV0aC5fY2FuSW5pdEVtdWxhdG9yID0gZmFsc2U7XG4gICAgY29uc3QgZXJyb3JNYXAgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIFNFUlZFUl9FUlJPUl9NQVApLCBjdXN0b21FcnJvck1hcCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV0d29ya1RpbWVvdXQgPSBuZXcgTmV0d29ya1RpbWVvdXQoYXV0aCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIGZldGNoRm4oKSxcbiAgICAgICAgICAgIG5ldHdvcmtUaW1lb3V0LnByb21pc2VcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgdGhlIGZldGNoIHN1Y2NlZWRlZCBhbmQgdGhlIG5ldHdvcmtUaW1lb3V0XG4gICAgICAgIC8vIGRpZG4ndCB0aHJvdzsgY2xlYXIgdGhlIG5ldHdvcmsgdGltZW91dCBkZWxheSBzbyB0aGF0IE5vZGUgd29uJ3QgaGFuZ1xuICAgICAgICBuZXR3b3JrVGltZW91dC5jbGVhck5ldHdvcmtUaW1lb3V0KCk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICgnbmVlZENvbmZpcm1hdGlvbicgaW4ganNvbikge1xuICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgISgnZXJyb3JNZXNzYWdlJyBpbiBqc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5vayA/IGpzb24uZXJyb3JNZXNzYWdlIDoganNvbi5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgW3NlcnZlckVycm9yQ29kZSwgc2VydmVyRXJyb3JNZXNzYWdlXSA9IGVycm9yTWVzc2FnZS5zcGxpdCgnIDogJyk7XG4gICAgICAgICAgICBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCIgLyogU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqLywganNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiRU1BSUxfRVhJU1RTXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfRVhJU1RTICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi8sIGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIlVTRVJfRElTQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX0RJU0FCTEVEICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcInVzZXItZGlzYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQgKi8sIGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aEVycm9yID0gZXJyb3JNYXBbc2VydmVyRXJyb3JDb2RlXSB8fFxuICAgICAgICAgICAgICAgIHNlcnZlckVycm9yQ29kZVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW19cXHNdKy9nLCAnLScpO1xuICAgICAgICAgICAgaWYgKHNlcnZlckVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGF1dGhFcnJvciwgc2VydmVyRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIGF1dGhFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoYW5naW5nIHRoaXMgdG8gYSBkaWZmZXJlbnQgZXJyb3IgY29kZSB3aWxsIGxvZyB1c2VyIG91dCB3aGVuIHRoZXJlIGlzIGEgbmV0d29yayBlcnJvclxuICAgICAgICAvLyBiZWNhdXNlIHdlIHRyZWF0IGFueSBlcnJvciBvdGhlciB0aGFuIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQgYXMgdG9rZW4gaXMgaW52YWxpZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzRmYmM3MzYxMGQ3MGJlNGUwODUyZTdkZTYzYTM5Y2I3ODk3ZTg1NDYvcGFja2FnZXMvYXV0aC9zcmMvY29yZS9hdXRoL2F1dGhfaW1wbC50cyNMMzA5LUwzMTZcbiAgICAgICAgX2ZhaWwoYXV0aCwgXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovLCB7ICdtZXNzYWdlJzogU3RyaW5nKGUpIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwID0ge30pIHtcbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwKTtcbiAgICBpZiAoJ21mYVBlbmRpbmdDcmVkZW50aWFsJyBpbiBzZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICBfZmFpbChhdXRoLCBcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi8sIHtcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogc2VydmVyUmVzcG9uc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9nZXRGaW5hbFRhcmdldChhdXRoLCBob3N0LCBwYXRoLCBxdWVyeSkge1xuICAgIGNvbnN0IGJhc2UgPSBgJHtob3N0fSR7cGF0aH0/JHtxdWVyeX1gO1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IGF1dGg7XG4gICAgY29uc3QgZmluYWxUYXJnZXQgPSBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yXG4gICAgICAgID8gX2VtdWxhdG9yVXJsKGF1dGguY29uZmlnLCBiYXNlKVxuICAgICAgICA6IGAke2F1dGguY29uZmlnLmFwaVNjaGVtZX06Ly8ke2Jhc2V9YDtcbiAgICAvLyBDb29raWUgYXV0aCB3b3JrcyBieSBNaVRNaW5nIHRoZSBzaWduSW4gYW5kIHRva2VuIGVuZHBvaW50cyBmcm9tIHRoZSBkZXZlbG9wZXIncyBiYWNrZW5kLFxuICAgIC8vIHNhdmluZyB0aGUgaWRUb2tlbiBhbmQgcmVmcmVzaFRva2VuIGludG8gY29va2llcywgYW5kIHRoZW4gcmVkYWN0aW5nIHRoZSByZWZyZXNoVG9rZW5cbiAgICAvLyBmcm9tIHRoZSByZXNwb25zZVxuICAgIGlmIChDb29raWVBdXRoUHJveGllZEVuZHBvaW50cy5pbmNsdWRlcyhwYXRoKSkge1xuICAgICAgICAvLyBQZXJzaXN0ZW5jZSBtYW5hZ2VyIGlzIGFzeW5jLCB3ZSBuZWVkIHRvIGF3YWl0IGl0LiBXZSBjYW4ndCBqdXN0IHdhaXQgZm9yIGF1dGggaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gaGVyZSBzaW5jZSBhdXRoIGluaXRpYWxpemF0aW9uIGNhbGxzIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fcGVyc2lzdGVuY2VNYW5hZ2VyQXZhaWxhYmxlO1xuICAgICAgICBpZiAoYXV0aEludGVybmFsLl9nZXRQZXJzaXN0ZW5jZVR5cGUoKSA9PT0gXCJDT09LSUVcIiAvKiBQZXJzaXN0ZW5jZVR5cGUuQ09PS0lFICovKSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVQZXJzaXN0ZW5jZSA9IGF1dGhJbnRlcm5hbC5fZ2V0UGVyc2lzdGVuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVQZXJzaXN0ZW5jZS5fZ2V0RmluYWxUYXJnZXQoZmluYWxUYXJnZXQpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsVGFyZ2V0O1xufVxuZnVuY3Rpb24gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShlbmZvcmNlbWVudFN0YXRlU3RyKSB7XG4gICAgc3dpdGNoIChlbmZvcmNlbWVudFN0YXRlU3RyKSB7XG4gICAgICAgIGNhc2UgJ0VORk9SQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5GT1JDRVwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRSAqLztcbiAgICAgICAgY2FzZSAnQVVESVQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiQVVESVRcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkFVRElUICovO1xuICAgICAgICBjYXNlICdPRkYnOlxuICAgICAgICAgICAgcmV0dXJuIFwiT0ZGXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5PRkYgKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJFTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRUQgKi87XG4gICAgfVxufVxuY2xhc3MgTmV0d29ya1RpbWVvdXQge1xuICAgIGNsZWFyTmV0d29ya1RpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcbiAgICAgICAgLy8gZG9uJ3QgY2FyZSBhYm91dCB0aGUgdmFsdWUgaGVyZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoX2NyZWF0ZUVycm9yKHRoaXMuYXV0aCwgXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovKSk7XG4gICAgICAgICAgICB9LCBERUZBVUxUX0FQSV9USU1FT1VUX01TLmdldCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX21ha2VUYWdnZWRFcnJvcihhdXRoLCBjb2RlLCByZXNwb25zZSkge1xuICAgIGNvbnN0IGVycm9yUGFyYW1zID0ge1xuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZS5lbWFpbCkge1xuICAgICAgICBlcnJvclBhcmFtcy5lbWFpbCA9IHJlc3BvbnNlLmVtYWlsO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UucGhvbmVOdW1iZXIpIHtcbiAgICAgICAgZXJyb3JQYXJhbXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZU51bWJlcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBfY3JlYXRlRXJyb3IoYXV0aCwgY29kZSwgZXJyb3JQYXJhbXMpO1xuICAgIC8vIFdlIGtub3cgY3VzdG9tRGF0YSBpcyBkZWZpbmVkIG9uIGVycm9yIGJlY2F1c2UgZXJyb3JQYXJhbXMgaXMgZGVmaW5lZFxuICAgIGVycm9yLmN1c3RvbURhdGEuX3Rva2VuUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkge1xuICAgIHJldHVybiAoZ3JlY2FwdGNoYSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZSAhPT0gdW5kZWZpbmVkKTtcbn1cbmNsYXNzIFJlY2FwdGNoYUNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZUNBUFRDSEEgc2l0ZSBrZXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpdGVLZXkgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHByb3ZpZGVycyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0dXMgZm9yIHJlQ0FQVENIQSBFbnRlcnByaXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlID0gW107XG4gICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNhcHRjaGFLZXkgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhhbXBsZSByZXNwb25zZS5yZWNhcHRjaGFLZXk6IFwicHJvamVjdHMvcHJvajEyMy9rZXlzL3NpdGVrZXkxMjNcIlxuICAgICAgICB0aGlzLnNpdGVLZXkgPSByZXNwb25zZS5yZWNhcHRjaGFLZXkuc3BsaXQoJy8nKVszXTtcbiAgICAgICAgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVDQVBUQ0hBIEVudGVycHJpc2UgZW5mb3JjZW1lbnQgc3RhdGUgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlclN0ciAtIFRoZSBwcm92aWRlciB3aG9zZSBlbmZvcmNlbWVudCBzdGF0ZSBpcyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVDQVBUQ0hBIEVudGVycHJpc2UgZW5mb3JjZW1lbnQgc3RhdGUgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgfHxcbiAgICAgICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSBvZiB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyICYmXG4gICAgICAgICAgICAgICAgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5wcm92aWRlciA9PT0gcHJvdmlkZXJTdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLmVuZm9yY2VtZW50U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgcHJvdmlkZXIgaXMgc2V0IHRvIEVORk9SQ0Ugb3IgQVVESVQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJTdHIgLSBUaGUgcHJvdmlkZXIgd2hvc2UgZW5hYmxlbWVudCBzdGF0ZSBpcyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKi9cbiAgICBpc1Byb3ZpZGVyRW5hYmxlZChwcm92aWRlclN0cikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT1cbiAgICAgICAgICAgIFwiRU5GT1JDRVwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpID09PSBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgaW4gYXQgbGVhc3Qgb25lIHByb3ZpZGVyLCBvdGhlcndpc2VcbiAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBvciBub3QgcmVDQVBUQ0hBIEVudGVycHJpc2UgcHJvdGVjdGlvbiBpcyBlbmFibGVkIGZvciBhdCBsZWFzdCBvbmUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgaXNBbnlQcm92aWRlckVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Byb3ZpZGVyRW5hYmxlZChcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3JlY2FwdGNoYUNvbmZpZ1wiIC8qIEVuZHBvaW50LkdFVF9SRUNBUFRDSEFfQ09ORklHICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWNjb3VudChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmRlbGV0ZVwiIC8qIEVuZHBvaW50LkRFTEVURV9BQ0NPVU5UICovLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUxpbmtlZEFjY291bnRzKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SW5mbyhhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmxvb2t1cFwiIC8qIEVuZHBvaW50LkdFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHV0Y1RpbWVzdGFtcCkge1xuICAgIGlmICghdXRjVGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gZGF0ZSBvYmplY3QuXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShOdW1iZXIodXRjVGltZXN0YW1wKSk7XG4gICAgICAgIC8vIFRlc3QgZGF0ZSBpcyB2YWxpZC5cbiAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gVVRDIGRhdGUgc3RyaW5nLlxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLiB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIEpTT04gV2ViIFRva2VuIChKV1QpIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHVzZXIgdG8gYSBGaXJlYmFzZSBzZXJ2aWNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGlmIGl0IGhhcyBub3QgZXhwaXJlZCBvciBpZiBpdCB3aWxsIG5vdCBleHBpcmUgaW4gdGhlIG5leHQgZml2ZVxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldElkVG9rZW4odXNlciwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJZFRva2VuUmVzdWx0KHVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbiAgICBjb25zdCBjbGFpbXMgPSBfcGFyc2VUb2tlbih0b2tlbik7XG4gICAgX2Fzc2VydChjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsIHVzZXJJbnRlcm5hbC5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgY29uc3QgZmlyZWJhc2UgPSB0eXBlb2YgY2xhaW1zLmZpcmViYXNlID09PSAnb2JqZWN0JyA/IGNsYWltcy5maXJlYmFzZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzaWduSW5Qcm92aWRlciA9IGZpcmViYXNlID09PSBudWxsIHx8IGZpcmViYXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJlYmFzZVsnc2lnbl9pbl9wcm92aWRlciddO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYWltcyxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpKSxcbiAgICAgICAgaXNzdWVkQXRUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5pYXQpKSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmV4cCkpLFxuICAgICAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcbiAgICAgICAgc2lnbkluU2Vjb25kRmFjdG9yOiAoZmlyZWJhc2UgPT09IG51bGwgfHwgZmlyZWJhc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcmViYXNlWydzaWduX2luX3NlY29uZF9mYWN0b3InXSkgfHwgbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcykgKiAxMDAwO1xufVxuZnVuY3Rpb24gX3BhcnNlVG9rZW4odG9rZW4pIHtcbiAgICBjb25zdCBbYWxnb3JpdGhtLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAoYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgcGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9sb2dFcnJvcignSldUIG1hbGZvcm1lZCwgY29udGFpbmVkIGZld2VyIHRoYW4gMyBzZWN0aW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJhc2U2NERlY29kZShwYXlsb2FkKTtcbiAgICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgICAgICBfbG9nRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IEpXVCBwYXlsb2FkJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgX2xvZ0Vycm9yKCdDYXVnaHQgZXJyb3IgcGFyc2luZyBKV1QgcGF5bG9hZCBhcyBKU09OJywgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3QgZXhwaXJlc0luIFRUTCBmcm9tIGEgdG9rZW4gYnkgc3VidHJhY3RpbmcgdGhlIGV4cGlyYXRpb24gZnJvbSB0aGUgaXNzdWFuY2UuXG4gKi9cbmZ1bmN0aW9uIF90b2tlbkV4cGlyZXNJbih0b2tlbikge1xuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gX3BhcnNlVG9rZW4odG9rZW4pO1xuICAgIF9hc3NlcnQocGFyc2VkVG9rZW4sIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5leHAgIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgcGFyc2VkVG9rZW4uaWF0ICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIHJldHVybiBOdW1iZXIocGFyc2VkVG9rZW4uZXhwKSAtIE51bWJlcihwYXJzZWRUb2tlbi5pYXQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgcHJvbWlzZSwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmIGlzVXNlckludmFsaWRhdGVkKGUpKSB7XG4gICAgICAgICAgICBpZiAodXNlci5hdXRoLmN1cnJlbnRVc2VyID09PSB1c2VyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXNlci5hdXRoLnNpZ25PdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVXNlckludmFsaWRhdGVkKHsgY29kZSB9KSB7XG4gICAgcmV0dXJuIChjb2RlID09PSBgYXV0aC8ke1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL31gIHx8XG4gICAgICAgIGNvZGUgPT09IGBhdXRoLyR7XCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi99YCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBQcm9hY3RpdmVSZWZyZXNoIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyByZXR1cm4gZnVuZGFtZW50YWxseSBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGNhcmUgd2hhdCB0aGUgdmFsdWUgaXMgYnV0IFRTIHdvbid0IGFjY2VwdCB1bmtub3duIGFuZFxuICAgICAgICAvLyB3ZSBjYW4ndCBjYXN0IHByb3Blcmx5IGluIGJvdGggZW52aXJvbm1lbnRzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IDMwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOICovO1xuICAgIH1cbiAgICBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIH1cbiAgICBfc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnRpbWVySWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEludGVydmFsKHdhc0Vycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHdhc0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuZXJyb3JCYWNrb2ZmO1xuICAgICAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLmVycm9yQmFja29mZiAqIDIsIDk2MDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01BWCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZXJyb3IgYmFja29mZlxuICAgICAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSAzMDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTiAqLztcbiAgICAgICAgICAgIGNvbnN0IGV4cFRpbWUgPSAoX2EgPSB0aGlzLnVzZXIuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBleHBUaW1lIC0gRGF0ZS5ub3coKSAtIDMwMDAwMCAvKiBEdXJhdGlvbi5PRkZTRVQgKi87XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlKHdhc0Vycm9yID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlLi4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmdldEludGVydmFsKHdhc0Vycm9yKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLml0ZXJhdGlvbigpO1xuICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfVxuICAgIGFzeW5jIGl0ZXJhdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5jb2RlKSA9PT1cbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSgvKiB3YXNFcnJvciAqLyB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgVXNlck1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIGxhc3RMb2dpbkF0KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICB0aGlzLmxhc3RMb2dpbkF0ID0gbGFzdExvZ2luQXQ7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVUaW1lKCk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplVGltZSgpIHtcbiAgICAgICAgdGhpcy5sYXN0U2lnbkluVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmxhc3RMb2dpbkF0KTtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5jcmVhdGVkQXQpO1xuICAgIH1cbiAgICBfY29weShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IG1ldGFkYXRhLmNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IG1ldGFkYXRhLmxhc3RMb2dpbkF0O1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHRoaXMuY3JlYXRlZEF0LFxuICAgICAgICAgICAgbGFzdExvZ2luQXQ6IHRoaXMubGFzdExvZ2luQXRcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF1dGggPSB1c2VyLmF1dGg7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgZ2V0QWNjb3VudEluZm8oYXV0aCwgeyBpZFRva2VuIH0pKTtcbiAgICBfYXNzZXJ0KHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS51c2Vycy5sZW5ndGgsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBjb25zdCBjb3JlQWNjb3VudCA9IHJlc3BvbnNlLnVzZXJzWzBdO1xuICAgIHVzZXIuX25vdGlmeVJlbG9hZExpc3RlbmVyKGNvcmVBY2NvdW50KTtcbiAgICBjb25zdCBuZXdQcm92aWRlckRhdGEgPSAoKF9hID0gY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aClcbiAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXG4gICAgICAgIDogW107XG4gICAgY29uc3QgcHJvdmlkZXJEYXRhID0gbWVyZ2VQcm92aWRlckRhdGEodXNlci5wcm92aWRlckRhdGEsIG5ld1Byb3ZpZGVyRGF0YSk7XG4gICAgLy8gUHJlc2VydmVzIHRoZSBub24tbm9ueW1vdXMgc3RhdHVzIG9mIHRoZSBzdG9yZWQgdXNlciwgZXZlbiBpZiBubyBtb3JlXG4gICAgLy8gY3JlZGVudGlhbHMgKGZlZGVyYXRlZCBvciBlbWFpbC9wYXNzd29yZCkgYXJlIGxpbmtlZCB0byB0aGUgdXNlci4gSWZcbiAgICAvLyB0aGUgdXNlciB3YXMgcHJldmlvdXNseSBhbm9ueW1vdXMsIHRoZW4gdXNlIHByb3ZpZGVyIGRhdGEgdG8gdXBkYXRlLlxuICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBpdCB3YXMgbm90IGFub255bW91cyBiZWZvcmUsIGl0IHNob3VsZCBuZXZlciBiZVxuICAgIC8vIGNvbnNpZGVyZWQgYW5vbnltb3VzIG5vdy5cbiAgICBjb25zdCBvbGRJc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XG4gICAgY29uc3QgbmV3SXNBbm9ueW1vdXMgPSAhKHVzZXIuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xuICAgIGNvbnN0IGlzQW5vbnltb3VzID0gIW9sZElzQW5vbnltb3VzID8gZmFsc2UgOiBuZXdJc0Fub255bW91cztcbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgICBwaG90b1VSTDogY29yZUFjY291bnQucGhvdG9VcmwgfHwgbnVsbCxcbiAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXG4gICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXG4gICAgICAgIHBob25lTnVtYmVyOiBjb3JlQWNjb3VudC5waG9uZU51bWJlciB8fCBudWxsLFxuICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcbiAgICAgICAgcHJvdmlkZXJEYXRhLFxuICAgICAgICBtZXRhZGF0YTogbmV3IFVzZXJNZXRhZGF0YShjb3JlQWNjb3VudC5jcmVhdGVkQXQsIGNvcmVBY2NvdW50Lmxhc3RMb2dpbkF0KSxcbiAgICAgICAgaXNBbm9ueW1vdXNcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24odXNlciwgdXBkYXRlcyk7XG59XG4vKipcbiAqIFJlbG9hZHMgdXNlciBhY2NvdW50IGRhdGEsIGlmIHNpZ25lZCBpbi5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVsb2FkKHVzZXIpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlckludGVybmFsKTtcbiAgICAvLyBFdmVuIHRob3VnaCB0aGUgY3VycmVudCB1c2VyIGhhc24ndCBjaGFuZ2VkLCB1cGRhdGVcbiAgICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxuICAgIC8vIG5ldyBpbmZvLlxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvdmlkZXJEYXRhKG9yaWdpbmFsLCBuZXdEYXRhKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZCkpO1xuICAgIHJldHVybiBbLi4uZGVkdXBlZCwgLi4ubmV3RGF0YV07XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvdmlkZXJEYXRhKHByb3ZpZGVycykge1xuICAgIHJldHVybiBwcm92aWRlcnMubWFwKChfYSkgPT4ge1xuICAgICAgICB2YXIgeyBwcm92aWRlcklkIH0gPSBfYSwgcHJvdmlkZXIgPSBfX3Jlc3QoX2EsIFtcInByb3ZpZGVySWRcIl0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHVpZDogcHJvdmlkZXIucmF3SWQgfHwgJycsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvdmlkZXIuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsOiBwcm92aWRlci5lbWFpbCB8fCBudWxsLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IHByb3ZpZGVyLnBob25lTnVtYmVyIHx8IG51bGwsXG4gICAgICAgICAgICBwaG90b1VSTDogcHJvdmlkZXIucGhvdG9VcmwgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFN0c1Rva2VuKGF1dGgsIHJlZnJlc2hUb2tlbikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIHt9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBxdWVyeXN0cmluZyh7XG4gICAgICAgICAgICAnZ3JhbnRfdHlwZSc6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJzogcmVmcmVzaFRva2VuXG4gICAgICAgIH0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB7IHRva2VuQXBpSG9zdCwgYXBpS2V5IH0gPSBhdXRoLmNvbmZpZztcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgX2dldEZpbmFsVGFyZ2V0KGF1dGgsIHRva2VuQXBpSG9zdCwgXCIvdjEvdG9rZW5cIiAvKiBFbmRwb2ludC5UT0tFTiAqLywgYGtleT0ke2FwaUtleX1gKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGF1dGguZW11bGF0b3JDb25maWcgJiZcbiAgICAgICAgICAgIGlzQ2xvdWRXb3Jrc3RhdGlvbihhdXRoLmVtdWxhdG9yQ29uZmlnLmhvc3QpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gJ2luY2x1ZGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkodXJsLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICAvLyBUaGUgcmVzcG9uc2UgY29tZXMgYmFjayBpbiBzbmFrZV9jYXNlLiBDb252ZXJ0IHRvIGNhbWVsOlxuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2Vzc1Rva2VuOiByZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNJbjogcmVzcG9uc2UuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZS5yZWZyZXNoX3Rva2VuXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJldm9rZVRva2VuKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHM6cmV2b2tlVG9rZW5cIiAvKiBFbmRwb2ludC5SRVZPS0VfVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGNsYXNzIGFzIGludGVybmFsIGV4cGxpY2l0bHkgdG8gZXhjbHVkZSBpdCBpbiB0aGUgcHVibGljIHR5cGluZ3MsIGJlY2F1c2VcbiAqIGl0IHJlZmVyZW5jZXMgQXV0aEludGVybmFsIHdoaWNoIGhhcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBVc2VySW50ZXJuYWwuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFN0c1Rva2VuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNFeHBpcmVkKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmV4cGlyYXRpb25UaW1lIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpID4gdGhpcy5leHBpcmF0aW9uVGltZSAtIDMwMDAwIC8qIEJ1ZmZlci5UT0tFTl9SRUZSRVNIICovKTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5pZFRva2VuICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5yZWZyZXNoVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9ICdleHBpcmVzSW4nIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IE51bWJlcihyZXNwb25zZS5leHBpcmVzSW4pXG4gICAgICAgICAgICA6IF90b2tlbkV4cGlyZXNJbihyZXNwb25zZS5pZFRva2VuKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKHJlc3BvbnNlLmlkVG9rZW4sIHJlc3BvbnNlLnJlZnJlc2hUb2tlbiwgZXhwaXJlc0luKTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbikge1xuICAgICAgICBfYXNzZXJ0KGlkVG9rZW4ubGVuZ3RoICE9PSAwLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IF90b2tlbkV4cGlyZXNJbihpZFRva2VuKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGlkVG9rZW4sIG51bGwsIGV4cGlyZXNJbik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuKGF1dGgsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuaXNFeHBpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMucmVmcmVzaFRva2VuLCBhdXRoLCBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyk7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoKGF1dGgsIHRoaXMucmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjbGVhclJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKGF1dGgsIG9sZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgZXhwaXJlc0luIH0gPSBhd2FpdCByZXF1ZXN0U3RzVG9rZW4oYXV0aCwgb2xkVG9rZW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgTnVtYmVyKGV4cGlyZXNJbikpO1xuICAgIH1cbiAgICB1cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJblNlYykge1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbiB8fCBudWxsO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IERhdGUubm93KCkgKyBleHBpcmVzSW5TZWMgKiAxMDAwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oYXBwTmFtZSwgb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVmcmVzaFRva2VuLCBhY2Nlc3NUb2tlbiwgZXhwaXJhdGlvblRpbWUgfSA9IG9iamVjdDtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcbiAgICAgICAgaWYgKHJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVmcmVzaFRva2VuID09PSAnc3RyaW5nJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hbmFnZXIucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlci5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgZXhwaXJhdGlvblRpbWUgPT09ICdudW1iZXInLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogdGhpcy5leHBpcmF0aW9uVGltZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYXNzaWduKHN0c1Rva2VuTWFuYWdlcikge1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBzdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICAgIF9jbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFN0c1Rva2VuTWFuYWdlcigpLCB0aGlzLnRvSlNPTigpKTtcbiAgICB9XG4gICAgX3BlcmZvcm1SZWZyZXNoKCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChhc3NlcnRpb24sIGFwcE5hbWUpIHtcbiAgICBfYXNzZXJ0KHR5cGVvZiBhc3NlcnRpb24gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhc3NlcnRpb24gPT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywgeyBhcHBOYW1lIH0pO1xufVxuY2xhc3MgVXNlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IHVpZCwgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyIH0gPSBfYSwgb3B0ID0gX19yZXN0KF9hLCBbXCJ1aWRcIiwgXCJhdXRoXCIsIFwic3RzVG9rZW5NYW5hZ2VyXCJdKTtcbiAgICAgICAgLy8gRm9yIHRoZSB1c2VyIG9iamVjdCwgcHJvdmlkZXIgaXMgYWx3YXlzIEZpcmViYXNlLlxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBcImZpcmViYXNlXCIgLyogUHJvdmlkZXJJZC5GSVJFQkFTRSAqLztcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoID0gbmV3IFByb2FjdGl2ZVJlZnJlc2godGhpcyk7XG4gICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyID0gc3RzVG9rZW5NYW5hZ2VyO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gb3B0LmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZW1haWwgPSBvcHQuZW1haWwgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gb3B0LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSBvcHQucGhvbmVOdW1iZXIgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5waG90b1VSTCA9IG9wdC5waG90b1VSTCB8fCBudWxsO1xuICAgICAgICB0aGlzLmlzQW5vbnltb3VzID0gb3B0LmlzQW5vbnltb3VzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gb3B0LnRlbmFudElkIHx8IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXJEYXRhID0gb3B0LnByb3ZpZGVyRGF0YSA/IFsuLi5vcHQucHJvdmlkZXJEYXRhXSA6IFtdO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFVzZXJNZXRhZGF0YShvcHQuY3JlYXRlZEF0IHx8IHVuZGVmaW5lZCwgb3B0Lmxhc3RMb2dpbkF0IHx8IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzeW5jIGdldElkVG9rZW4oZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgdGhpcy5zdHNUb2tlbk1hbmFnZXIuZ2V0VG9rZW4odGhpcy5hdXRoLCBmb3JjZVJlZnJlc2gpKTtcbiAgICAgICAgX2Fzc2VydChhY2Nlc3NUb2tlbiwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICE9PSBhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgZ2V0SWRUb2tlblJlc3VsdChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuIGdldElkVG9rZW5SZXN1bHQodGhpcywgZm9yY2VSZWZyZXNoKTtcbiAgICB9XG4gICAgcmVsb2FkKCkge1xuICAgICAgICByZXR1cm4gcmVsb2FkKHRoaXMpO1xuICAgIH1cbiAgICBfYXNzaWduKHVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMudWlkID09PSB1c2VyLnVpZCwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSB1c2VyLmRpc3BsYXlOYW1lO1xuICAgICAgICB0aGlzLnBob3RvVVJMID0gdXNlci5waG90b1VSTDtcbiAgICAgICAgdGhpcy5lbWFpbCA9IHVzZXIuZW1haWw7XG4gICAgICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IHVzZXIuZW1haWxWZXJpZmllZDtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHVzZXIucGhvbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gdXNlci50ZW5hbnRJZDtcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSB1c2VyLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLl9jb3B5KHVzZXIubWV0YWRhdGEpO1xuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5fYXNzaWduKHVzZXIuc3RzVG9rZW5NYW5hZ2VyKTtcbiAgICB9XG4gICAgX2Nsb25lKGF1dGgpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlciA9IG5ldyBVc2VySW1wbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMpLCB7IGF1dGgsIHN0c1Rva2VuTWFuYWdlcjogdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Nsb25lKCkgfSkpO1xuICAgICAgICBuZXdVc2VyLm1ldGFkYXRhLl9jb3B5KHRoaXMubWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gbmV3VXNlcjtcbiAgICB9XG4gICAgX29uUmVsb2FkKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIGxpc3RlbmVyLCBhbmQgdGhhdCBpcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBNdWx0aUZhY3RvclVzZXJcbiAgICAgICAgX2Fzc2VydCghdGhpcy5yZWxvYWRMaXN0ZW5lciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkVXNlckluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlbG9hZExpc3RlbmVyKHRoaXMucmVsb2FkVXNlckluZm8pO1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeVJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbG9hZExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGxpc3RlbmVyIGlzIHN1YnNjcmliZWQgeWV0LCBzYXZlIHRoZSByZXN1bHQgc28gaXQncyBhdmFpbGFibGUgd2hlbiB0aGV5IGRvIHN1YnNjcmliZVxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IHVzZXJJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RhcnQoKTtcbiAgICB9XG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0b3AoKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCByZWxvYWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdG9rZW5zUmVmcmVzaGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXNwb25zZS5pZFRva2VuICYmXG4gICAgICAgICAgICByZXNwb25zZS5pZFRva2VuICE9PSB0aGlzLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRva2Vuc1JlZnJlc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbG9hZCkge1xuICAgICAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgaWYgKHRva2Vuc1JlZnJlc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hdXRoLmFwcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcih0aGlzLmF1dGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5nZXRJZFRva2VuKCk7XG4gICAgICAgIGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMsIGRlbGV0ZUFjY291bnQodGhpcy5hdXRoLCB7IGlkVG9rZW4gfSkpO1xuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5jbGVhclJlZnJlc2hUb2tlbigpO1xuICAgICAgICAvLyBUT0RPOiBEZXRlcm1pbmUgaWYgY2FuY2VsbGFibGUtcHJvbWlzZXMgYXJlIG5lY2Vzc2FyeSB0byB1c2UgaW4gdGhpcyBjbGFzcyBzbyB0aGF0IGRlbGV0ZSgpXG4gICAgICAgIC8vICAgICAgIGNhbmNlbHMgcGVuZGluZyBhY3Rpb25zLi4uXG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguc2lnbk91dCgpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB1aWQ6IHRoaXMudWlkLCBlbWFpbDogdGhpcy5lbWFpbCB8fCB1bmRlZmluZWQsIGVtYWlsVmVyaWZpZWQ6IHRoaXMuZW1haWxWZXJpZmllZCwgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUgfHwgdW5kZWZpbmVkLCBpc0Fub255bW91czogdGhpcy5pc0Fub255bW91cywgcGhvdG9VUkw6IHRoaXMucGhvdG9VUkwgfHwgdW5kZWZpbmVkLCBwaG9uZU51bWJlcjogdGhpcy5waG9uZU51bWJlciB8fCB1bmRlZmluZWQsIHRlbmFudElkOiB0aGlzLnRlbmFudElkIHx8IHVuZGVmaW5lZCwgcHJvdmlkZXJEYXRhOiB0aGlzLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnRvSlNPTigpLCBcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0IGV2ZW50IElEIG11c3QgYmUgbWFpbnRhaW5lZCBpbiBjYXNlIHRoZXJlIGlzIGEgcGVuZGluZ1xuICAgICAgICAgICAgLy8gcmVkaXJlY3QgZXZlbnQuXG4gICAgICAgICAgICBfcmVkaXJlY3RFdmVudElkOiB0aGlzLl9yZWRpcmVjdEV2ZW50SWQgfSwgdGhpcy5tZXRhZGF0YS50b0pTT04oKSksIHsgXG4gICAgICAgICAgICAvLyBSZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBsZWdhY3kgU0RLIChnby9maXJlYmFzZS1hdXRoLXNkay1wZXJzaXN0ZW5jZS1wYXJzaW5nKTpcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hdXRoLmNvbmZpZy5hcGlLZXksIGFwcE5hbWU6IHRoaXMuYXV0aC5uYW1lIH0pO1xuICAgIH1cbiAgICBnZXQgcmVmcmVzaFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VuIHx8ICcnO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21KU09OKGF1dGgsIG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IChfYSA9IG9iamVjdC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBlbWFpbCA9IChfYiA9IG9iamVjdC5lbWFpbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwaG9uZU51bWJlciA9IChfYyA9IG9iamVjdC5waG9uZU51bWJlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwaG90b1VSTCA9IChfZCA9IG9iamVjdC5waG90b1VSTCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IChfZSA9IG9iamVjdC50ZW5hbnRJZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBfcmVkaXJlY3RFdmVudElkID0gKF9mID0gb2JqZWN0Ll9yZWRpcmVjdEV2ZW50SWQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gKF9nID0gb2JqZWN0LmNyZWF0ZWRBdCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBsYXN0TG9naW5BdCA9IChfaCA9IG9iamVjdC5sYXN0TG9naW5BdCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB7IHVpZCwgZW1haWxWZXJpZmllZCwgaXNBbm9ueW1vdXMsIHByb3ZpZGVyRGF0YSwgc3RzVG9rZW5NYW5hZ2VyOiBwbGFpbk9iamVjdFRva2VuTWFuYWdlciB9ID0gb2JqZWN0O1xuICAgICAgICBfYXNzZXJ0KHVpZCAmJiBwbGFpbk9iamVjdFRva2VuTWFuYWdlciwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBTdHNUb2tlbk1hbmFnZXIuZnJvbUpTT04odGhpcy5uYW1lLCBwbGFpbk9iamVjdFRva2VuTWFuYWdlcik7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHVpZCA9PT0gJ3N0cmluZycsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZGlzcGxheU5hbWUsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGVtYWlsLCBhdXRoLm5hbWUpO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiBlbWFpbFZlcmlmaWVkID09PSAnYm9vbGVhbicsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgaXNBbm9ueW1vdXMgPT09ICdib29sZWFuJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChwaG9uZU51bWJlciwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQocGhvdG9VUkwsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHRlbmFudElkLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChfcmVkaXJlY3RFdmVudElkLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChjcmVhdGVkQXQsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGxhc3RMb2dpbkF0LCBhdXRoLm5hbWUpO1xuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcbiAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIGVtYWlsVmVyaWZpZWQsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIGlzQW5vbnltb3VzLFxuICAgICAgICAgICAgcGhvdG9VUkwsXG4gICAgICAgICAgICBwaG9uZU51bWJlcixcbiAgICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLFxuICAgICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgICAgbGFzdExvZ2luQXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm92aWRlckRhdGEgJiYgQXJyYXkuaXNBcnJheShwcm92aWRlckRhdGEpKSB7XG4gICAgICAgICAgICB1c2VyLnByb3ZpZGVyRGF0YSA9IHByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcmVkaXJlY3RFdmVudElkKSB7XG4gICAgICAgICAgICB1c2VyLl9yZWRpcmVjdEV2ZW50SWQgPSBfcmVkaXJlY3RFdmVudElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIGF1dGhcbiAgICAgKiBAcGFyYW0gaWRUb2tlblJlc3BvbnNlXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIF9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgIHN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcbiAgICAgICAgICAgIHVpZDogaWRUb2tlblJlc3BvbnNlLmxvY2FsSWQsXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLFxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIHVzZXIgaW5mbyBhbmQgZGF0YSBhbmQgcmVzb2x2ZXMgd2l0aCBhIHVzZXIgaW5zdGFuY2UuXG4gICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSBhdXRoXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UoYXV0aCwgcmVzcG9uc2UsIGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcbiAgICAgICAgX2Fzc2VydChjb3JlQWNjb3VudC5sb2NhbElkICE9PSB1bmRlZmluZWQsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJEYXRhID0gY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGV4dHJhY3RQcm92aWRlckRhdGEoY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbylcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IGlzQW5vbnltb3VzID0gIShjb3JlQWNjb3VudC5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmICEocHJvdmlkZXJEYXRhID09PSBudWxsIHx8IHByb3ZpZGVyRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXJEYXRhLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcbiAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21JZFRva2VuKGlkVG9rZW4pO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBGaXJlYmFzZSBBdXRoIHVzZXIuXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgICAgICAgIGlzQW5vbnltb3VzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHVzZXIgd2l0aCBkYXRhIGZyb20gdGhlIEdldEFjY291bnRJbmZvIHJlc3BvbnNlLlxuICAgICAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBwaG90b1VSTDogY29yZUFjY291bnQucGhvdG9VcmwgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsOiBjb3JlQWNjb3VudC5lbWFpbCB8fCBudWxsLFxuICAgICAgICAgICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBjb3JlQWNjb3VudC5waG9uZU51bWJlciB8fCBudWxsLFxuICAgICAgICAgICAgdGVuYW50SWQ6IGNvcmVBY2NvdW50LnRlbmFudElkIHx8IG51bGwsXG4gICAgICAgICAgICBwcm92aWRlckRhdGEsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IFVzZXJNZXRhZGF0YShjb3JlQWNjb3VudC5jcmVhdGVkQXQsIGNvcmVBY2NvdW50Lmxhc3RMb2dpbkF0KSxcbiAgICAgICAgICAgIGlzQW5vbnltb3VzOiAhKGNvcmVBY2NvdW50LmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiZcbiAgICAgICAgICAgICAgICAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24odXNlciwgdXBkYXRlcyk7XG4gICAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGluc3RhbmNlQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBfZ2V0SW5zdGFuY2UoY2xzKSB7XG4gICAgZGVidWdBc3NlcnQoY2xzIGluc3RhbmNlb2YgRnVuY3Rpb24sICdFeHBlY3RlZCBhIGNsYXNzIGRlZmluaXRpb24nKTtcbiAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZUNhY2hlLmdldChjbHMpO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBkZWJ1Z0Fzc2VydChpbnN0YW5jZSBpbnN0YW5jZW9mIGNscywgJ0luc3RhbmNlIHN0b3JlZCBpbiBjYWNoZSBtaXNtYXRjaGVkIHdpdGggY2xhc3MnKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBpbnN0YW5jZSA9IG5ldyBjbHMoKTtcbiAgICBpbnN0YW5jZUNhY2hlLnNldChjbHMsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbk1lbW9yeVBlcnNpc3RlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50eXBlID0gXCJOT05FXCIgLyogUGVyc2lzdGVuY2VUeXBlLk5PTkUgKi87XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xuICAgIH1cbiAgICBhc3luYyBfaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIF9yZW1vdmUoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgICB9XG4gICAgX2FkZExpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGluLW1lbW9yeSBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3Mvd29ya2Vyc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9yZW1vdmVMaXN0ZW5lcihfa2V5LCBfbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBpbi1tZW1vcnkgc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzL3dvcmtlcnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbkluTWVtb3J5UGVyc2lzdGVuY2UudHlwZSA9ICdOT05FJztcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBlcnNpc3RlbmNlfSBvZiB0eXBlICdOT05FJy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGluTWVtb3J5UGVyc2lzdGVuY2UgPSBJbk1lbW9yeVBlcnNpc3RlbmNlO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX3BlcnNpc3RlbmNlS2V5TmFtZShrZXksIGFwaUtleSwgYXBwTmFtZSkge1xuICAgIHJldHVybiBgJHtcImZpcmViYXNlXCIgLyogTmFtZXNwYWNlLlBFUlNJU1RFTkNFICovfToke2tleX06JHthcGlLZXl9OiR7YXBwTmFtZX1gO1xufVxuY2xhc3MgUGVyc2lzdGVuY2VVc2VyTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnVzZXJLZXkgPSB1c2VyS2V5O1xuICAgICAgICBjb25zdCB7IGNvbmZpZywgbmFtZSB9ID0gdGhpcy5hdXRoO1xuICAgICAgICB0aGlzLmZ1bGxVc2VyS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZSh0aGlzLnVzZXJLZXksIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xuICAgICAgICB0aGlzLmZ1bGxQZXJzaXN0ZW5jZUtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUoXCJwZXJzaXN0ZW5jZVwiIC8qIEtleU5hbWUuUEVSU0lTVEVOQ0VfVVNFUiAqLywgY29uZmlnLmFwaUtleSwgbmFtZSk7XG4gICAgICAgIHRoaXMuYm91bmRFdmVudEhhbmRsZXIgPSBhdXRoLl9vblN0b3JhZ2VFdmVudC5iaW5kKGF1dGgpO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLl9hZGRMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudFVzZXIodXNlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fc2V0KHRoaXMuZnVsbFVzZXJLZXksIHVzZXIudG9KU09OKCkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDdXJyZW50VXNlcigpIHtcbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuX2dldCh0aGlzLmZ1bGxVc2VyS2V5KTtcbiAgICAgICAgaWYgKCFibG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEFjY291bnRJbmZvKHRoaXMuYXV0aCwgeyBpZFRva2VuOiBibG9iIH0pLmNhdGNoKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVXNlckltcGwuX2Zyb21HZXRBY2NvdW50SW5mb1Jlc3BvbnNlKHRoaXMuYXV0aCwgcmVzcG9uc2UsIGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVc2VySW1wbC5fZnJvbUpTT04odGhpcy5hdXRoLCBibG9iKTtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmUodGhpcy5mdWxsVXNlcktleSk7XG4gICAgfVxuICAgIHNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fc2V0KHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5LCB0aGlzLnBlcnNpc3RlbmNlLnR5cGUpO1xuICAgIH1cbiAgICBhc3luYyBzZXRQZXJzaXN0ZW5jZShuZXdQZXJzaXN0ZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSA9PT0gbmV3UGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVDdXJyZW50VXNlcigpO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gbmV3UGVyc2lzdGVuY2U7XG4gICAgICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFVzZXIoY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fcmVtb3ZlTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoYXV0aCwgcGVyc2lzdGVuY2VIaWVyYXJjaHksIHVzZXJLZXkgPSBcImF1dGhVc2VyXCIgLyogS2V5TmFtZS5BVVRIX1VTRVIgKi8pIHtcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW5jZUhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihfZ2V0SW5zdGFuY2UoaW5NZW1vcnlQZXJzaXN0ZW5jZSksIGF1dGgsIHVzZXJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsaW1pbmF0ZSBhbnkgcGVyc2lzdGVuY2VzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUGVyc2lzdGVuY2VzID0gKGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwZXJzaXN0ZW5jZS5faXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pKSkuZmlsdGVyKHBlcnNpc3RlbmNlID0+IHBlcnNpc3RlbmNlKTtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBwZXJzaXN0ZW5jZSBsaXN0ZWQsIG9yIGluIG1lbW9yeSBpZiBub25lIGF2YWlsYWJsZVxuICAgICAgICBsZXQgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IGF2YWlsYWJsZVBlcnNpc3RlbmNlc1swXSB8fFxuICAgICAgICAgICAgX2dldEluc3RhbmNlKGluTWVtb3J5UGVyc2lzdGVuY2UpO1xuICAgICAgICBjb25zdCBrZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHVzZXJLZXksIGF1dGguY29uZmlnLmFwaUtleSwgYXV0aC5uYW1lKTtcbiAgICAgICAgLy8gUHVsbCBvdXQgdGhlIGV4aXN0aW5nIHVzZXIsIHNldHRpbmcgdGhlIGNob3NlbiBwZXJzaXN0ZW5jZSB0byB0aGF0XG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIGlmIHRoZSB1c2VyIGV4aXN0cy5cbiAgICAgICAgbGV0IHVzZXJUb01pZ3JhdGUgPSBudWxsO1xuICAgICAgICAvLyBOb3RlLCBoZXJlIHdlIGNoZWNrIGZvciBhIHVzZXIgaW4gX2FsbF8gcGVyc2lzdGVuY2VzLCBub3QganVzdCB0aGVcbiAgICAgICAgLy8gb25lcyBkZWVtZWQgYXZhaWxhYmxlLiBJZiB3ZSBjYW4gbWlncmF0ZSBhIHVzZXIgb3V0IG9mIGEgYnJva2VuXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlLCB3ZSB3aWxsIChidXQgb25seSBpZiB0aGF0IHBlcnNpc3RlbmNlIHN1cHBvcnRzIG1pZ3JhdGlvbikuXG4gICAgICAgIGZvciAoY29uc3QgcGVyc2lzdGVuY2Ugb2YgcGVyc2lzdGVuY2VIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHBlcnNpc3RlbmNlLl9nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXNlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBY2NvdW50SW5mbyhhdXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRUb2tlbjogYmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UoYXV0aCwgcmVzcG9uc2UsIGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IFVzZXJJbXBsLl9mcm9tSlNPTihhdXRoLCBibG9iKTsgLy8gdGhyb3dzIGZvciB1bnBhcnNhYmxlIGJsb2IgKHdyb25nIGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJUb01pZ3JhdGUgPSB1c2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBmaW5kIHRoZSB1c2VyIGluIGEgcGVyc2lzdGVuY2UgdGhhdCBkb2VzIHN1cHBvcnQgbWlncmF0aW9uLCB1c2VcbiAgICAgICAgLy8gdGhhdCBtaWdyYXRpb24gcGF0aCAob2Ygb25seSBwZXJzaXN0ZW5jZXMgdGhhdCBzdXBwb3J0IG1pZ3JhdGlvbilcbiAgICAgICAgY29uc3QgbWlncmF0aW9uSGllcmFyY2h5ID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzLmZpbHRlcihwID0+IHAuX3Nob3VsZEFsbG93TWlncmF0aW9uKTtcbiAgICAgICAgLy8gSWYgdGhlIHBlcnNpc3RlbmNlIGRvZXMgX25vdF8gYWxsb3cgbWlncmF0aW9uLCBqdXN0IGZpbmlzaCBvZmYgaGVyZVxuICAgICAgICBpZiAoIXNlbGVjdGVkUGVyc2lzdGVuY2UuX3Nob3VsZEFsbG93TWlncmF0aW9uIHx8XG4gICAgICAgICAgICAhbWlncmF0aW9uSGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBtaWdyYXRpb25IaWVyYXJjaHlbMF07XG4gICAgICAgIGlmICh1c2VyVG9NaWdyYXRlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG5vcm1hbGx5IHNob3VsZG4ndCB0aHJvdyBzaW5jZSBjaG9zZW5QZXJzaXN0ZW5jZS5pc0F2YWlsYWJsZSgpIGlzIHRydWUsIGJ1dCBpZiBpdCBkb2VzXG4gICAgICAgICAgICAvLyB3ZSdsbCBqdXN0IGxldCBpdCBidWJibGUgdG8gc3VyZmFjZSB0aGUgZXJyb3IuXG4gICAgICAgICAgICBhd2FpdCBzZWxlY3RlZFBlcnNpc3RlbmNlLl9zZXQoa2V5LCB1c2VyVG9NaWdyYXRlLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRlbXB0IHRvIGNsZWFyIHRoZSBrZXkgaW4gb3RoZXIgcGVyc2lzdGVuY2VzIGJ1dCBpZ25vcmUgZXJyb3JzLiBUaGlzIGhlbHBzIHByZXZlbnQgaXNzdWVzXG4gICAgICAgIC8vIHN1Y2ggYXMgdXNlcnMgZ2V0dGluZyBzdHVjayB3aXRoIGEgcHJldmlvdXMgYWNjb3VudCBhZnRlciBzaWduaW5nIG91dCBhbmQgcmVmcmVzaGluZyB0aGUgdGFiLlxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwZXJzaXN0ZW5jZUhpZXJhcmNoeS5tYXAoYXN5bmMgKHBlcnNpc3RlbmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwZXJzaXN0ZW5jZS5fcmVtb3ZlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBicm93c2VyIGZvciB0aGUgcHVycG9zZXMgb2YgcmVwb3J0aW5nIHVzYWdlIHRvIHRoZSBBUElcbiAqL1xuZnVuY3Rpb24gX2dldEJyb3dzZXJOYW1lKHVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHVhLmluY2x1ZGVzKCdvcGVyYS8nKSB8fCB1YS5pbmNsdWRlcygnb3ByLycpIHx8IHVhLmluY2x1ZGVzKCdvcGlvcy8nKSkge1xuICAgICAgICByZXR1cm4gXCJPcGVyYVwiIC8qIEJyb3dzZXJOYW1lLk9QRVJBICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNJRU1vYmlsZSh1YSkpIHtcbiAgICAgICAgLy8gV2luZG93cyBwaG9uZSBJRU1vYmlsZSBicm93c2VyLlxuICAgICAgICByZXR1cm4gXCJJRU1vYmlsZVwiIC8qIEJyb3dzZXJOYW1lLklFTU9CSUxFICovO1xuICAgIH1cbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnbXNpZScpIHx8IHVhLmluY2x1ZGVzKCd0cmlkZW50LycpKSB7XG4gICAgICAgIHJldHVybiBcIklFXCIgLyogQnJvd3Nlck5hbWUuSUUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdlZGdlLycpKSB7XG4gICAgICAgIHJldHVybiBcIkVkZ2VcIiAvKiBCcm93c2VyTmFtZS5FREdFICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNGaXJlZm94KHVhKSkge1xuICAgICAgICByZXR1cm4gXCJGaXJlZm94XCIgLyogQnJvd3Nlck5hbWUuRklSRUZPWCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ3NpbGsvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiU2lsa1wiIC8qIEJyb3dzZXJOYW1lLlNJTEsgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0JsYWNrQmVycnkodWEpKSB7XG4gICAgICAgIC8vIEJsYWNrYmVycnkgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiQmxhY2tiZXJyeVwiIC8qIEJyb3dzZXJOYW1lLkJMQUNLQkVSUlkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1dlYk9TKHVhKSkge1xuICAgICAgICAvLyBXZWJPUyBkZWZhdWx0IGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIldlYm9zXCIgLyogQnJvd3Nlck5hbWUuV0VCT1MgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1NhZmFyaSh1YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiU2FmYXJpXCIgLyogQnJvd3Nlck5hbWUuU0FGQVJJICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgodWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSB8fCBfaXNDaHJvbWVJT1ModWEpKSAmJlxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hyb21lXCIgLyogQnJvd3Nlck5hbWUuQ0hST01FICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNBbmRyb2lkKHVhKSkge1xuICAgICAgICAvLyBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIkFuZHJvaWRcIiAvKiBCcm93c2VyTmFtZS5BTkRST0lEICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgaGF2ZSBuYW1lL3ZlcnNpb24gYXQgZW5kIG9mIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAgICAgICBjb25zdCByZSA9IC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdXNlckFnZW50Lm1hdGNoKHJlKTtcbiAgICAgICAgaWYgKChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXMubGVuZ3RoKSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiT3RoZXJcIiAvKiBCcm93c2VyTmFtZS5PVEhFUiAqLztcbn1cbmZ1bmN0aW9uIF9pc0ZpcmVmb3godWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9maXJlZm94XFwvL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNTYWZhcmkodXNlckFnZW50ID0gZ2V0VUEoKSkge1xuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1YS5pbmNsdWRlcygnc2FmYXJpLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY3Jpb3MvJykgJiZcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdhbmRyb2lkJykpO1xufVxuZnVuY3Rpb24gX2lzQ2hyb21lSU9TKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvY3Jpb3NcXC8vaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0lFTW9iaWxlKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvaWVtb2JpbGUvaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0FuZHJvaWQodWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9hbmRyb2lkL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNCbGFja0JlcnJ5KHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvYmxhY2tiZXJyeS9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzV2ViT1ModWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC93ZWJvcy9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzSU9TKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAoL2lwaG9uZXxpcGFkfGlwb2QvaS50ZXN0KHVhKSB8fFxuICAgICAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSkpO1xufVxuZnVuY3Rpb24gX2lzSU9TN09yOCh1YSA9IGdldFVBKCkpIHtcbiAgICByZXR1cm4gKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kudGVzdCh1YSkgfHxcbiAgICAgICAgLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgOF9cXGQvaS50ZXN0KHVhKSk7XG59XG5mdW5jdGlvbiBfaXNJRTEwKCkge1xuICAgIHJldHVybiBpc0lFKCkgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAxMDtcbn1cbmZ1bmN0aW9uIF9pc01vYmlsZUJyb3dzZXIodWEgPSBnZXRVQSgpKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGdldEJyb3dzZXJOYW1lIGVxdWl2YWxlbnQgZm9yIE9TLlxuICAgIHJldHVybiAoX2lzSU9TKHVhKSB8fFxuICAgICAgICBfaXNBbmRyb2lkKHVhKSB8fFxuICAgICAgICBfaXNXZWJPUyh1YSkgfHxcbiAgICAgICAgX2lzQmxhY2tCZXJyeSh1YSkgfHxcbiAgICAgICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxuICAgICAgICBfaXNJRU1vYmlsZSh1YSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtLCBmcmFtZXdvcmtzID0gW10pIHtcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcbiAgICBzd2l0Y2ggKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgXCJCcm93c2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uQlJPV1NFUiAqLzpcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gX2dldEJyb3dzZXJOYW1lKGdldFVBKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XG4gICAgICAgICAgICAvLyBUZWNobmljYWxseSBhIHdvcmtlciBydW5zIGZyb20gYSBicm93c2VyIGJ1dCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYVxuICAgICAgICAgICAgLy8gd29ya2VyIGZyb20gYSBicm93c2VyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gYCR7X2dldEJyb3dzZXJOYW1lKGdldFVBKCkpfS0ke2NsaWVudFBsYXRmb3JtfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBjbGllbnRQbGF0Zm9ybTtcbiAgICB9XG4gICAgY29uc3QgcmVwb3J0ZWRGcmFtZXdvcmtzID0gZnJhbWV3b3Jrcy5sZW5ndGhcbiAgICAgICAgPyBmcmFtZXdvcmtzLmpvaW4oJywnKVxuICAgICAgICA6ICdGaXJlYmFzZUNvcmUtd2ViJzsgLyogZGVmYXVsdCB2YWx1ZSBpZiBubyBvdGhlciBmcmFtZXdvcmsgaXMgdXNlZCAqL1xuICAgIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke1wiSnNDb3JlXCIgLyogQ2xpZW50SW1wbGVtZW50YXRpb24uQ09SRSAqL30vJHtTREtfVkVSU0lPTn0vJHtyZXBvcnRlZEZyYW1ld29ya3N9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEF1dGhNaWRkbGV3YXJlUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBwdXNoQ2FsbGJhY2soY2FsbGJhY2ssIG9uQWJvcnQpIHtcbiAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGNvdWxkIGJlIHN5bmMgb3IgYXN5bmMuIFdyYXAgaXQgaW50byBhXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAodXNlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgcmVzb2x2ZSB3aXRoIGV4aXN0aW5nIHByb21pc2Ugb3Igd3JhcCBhIG5vbi1wcm9taXNlXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGludG8gYSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3luYyBjYWxsYmFjayB0aHJvd3MuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBvbkFib3J0IGlmIHByZXNlbnRcbiAgICAgICAgd3JhcHBlZENhbGxiYWNrLm9uQWJvcnQgPSBvbkFib3J0O1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2god3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZS4gUmVwbGFjZSB3aXRoIG5vLW9wLiBEbyBub3QgcmVtb3ZlIGZyb20gYXJyYXksIG9yIGl0IHdpbGwgZGlzdHVyYlxuICAgICAgICAgICAgLy8gaW5kZXhpbmcgb2Ygb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlW2luZGV4XSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBydW5NaWRkbGV3YXJlKG5leHRVc2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIgPT09IG5leHRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpbGUgcnVubmluZyB0aGUgbWlkZGxld2FyZSwgYnVpbGQgYSB0ZW1wb3Jhcnkgc3RhY2sgb2Ygb25BYm9ydFxuICAgICAgICAvLyBjYWxsYmFja3MgdG8gY2FsbCBpZiBvbmUgbWlkZGxld2FyZSBjYWxsYmFjayByZWplY3RzLlxuICAgICAgICBjb25zdCBvbkFib3J0U3RhY2sgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmVmb3JlU3RhdGVDYWxsYmFjayBvZiB0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmVmb3JlU3RhdGVDYWxsYmFjayhuZXh0VXNlcik7XG4gICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25BYm9ydFN0YWNrLnB1c2goYmVmb3JlU3RhdGVDYWxsYmFjay5vbkFib3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFJ1biBhbGwgb25BYm9ydCwgd2l0aCBzZXBhcmF0ZSB0cnkvY2F0Y2ggdG8gaWdub3JlIGFueSBlcnJvcnMgYW5kXG4gICAgICAgICAgICAvLyBjb250aW51ZVxuICAgICAgICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb25BYm9ydCBvZiBvbkFib3J0U3RhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbkFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEZldGNoZXMgdGhlIHBhc3N3b3JkIHBvbGljeSBmb3IgdGhlIGN1cnJlbnRseSBzZXQgdGVuYW50IG9yIHRoZSBwcm9qZWN0IGlmIG5vIHRlbmFudCBpcyBzZXQuXG4gKlxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QuXG4gKiBAcGFyYW0gcmVxdWVzdCBQYXNzd29yZCBwb2xpY3kgcmVxdWVzdC5cbiAqIEByZXR1cm5zIFBhc3N3b3JkIHBvbGljeSByZXNwb25zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2dldFBhc3N3b3JkUG9saWN5KGF1dGgsIHJlcXVlc3QgPSB7fSkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJHRVRcIiAvKiBIdHRwTWV0aG9kLkdFVCAqLywgXCIvdjIvcGFzc3dvcmRQb2xpY3lcIiAvKiBFbmRwb2ludC5HRVRfUEFTU1dPUkRfUE9MSUNZICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTWluaW11bSBtaW4gcGFzc3dvcmQgbGVuZ3RoIGVuZm9yY2VkIGJ5IHRoZSBiYWNrZW5kLCBldmVuIGlmIG5vIG1pbmltdW0gbGVuZ3RoIGlzIHNldC5cbmNvbnN0IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSCA9IDY7XG4vKipcbiAqIFN0b3JlcyBwYXNzd29yZCBwb2xpY3kgcmVxdWlyZW1lbnRzIGFuZCBwcm92aWRlcyBwYXNzd29yZCB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIHBvbGljeS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGFzc3dvcmRQb2xpY3lJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSBjdXN0b20gc3RyZW5ndGggb3B0aW9ucyBkZWZpbmVkIGluIHRoZSByZXNwb25zZS5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2UuY3VzdG9tU3RyZW5ndGhPcHRpb25zO1xuICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSB0aGUgYmFja2VuZCBpcyB1cGRhdGVkIHRvIGluY2x1ZGUgdGhlIG1pbmltdW0gbWluIHBhc3N3b3JkIGxlbmd0aCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIG1pbmltdW0gbGVuZ3RoIHNldC5cbiAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGggPVxuICAgICAgICAgICAgKF9hID0gcmVzcG9uc2VPcHRpb25zLm1pblBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNSU5JTVVNX01JTl9QQVNTV09SRF9MRU5HVEg7XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUxldHRlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9IHJlc3BvbnNlLmVuZm9yY2VtZW50U3RhdGU7XG4gICAgICAgIGlmICh0aGlzLmVuZm9yY2VtZW50U3RhdGUgPT09ICdFTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9ICdPRkYnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzID1cbiAgICAgICAgICAgIChfYyA9IChfYiA9IHJlc3BvbnNlLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuam9pbignJykpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnO1xuICAgICAgICB0aGlzLmZvcmNlVXBncmFkZU9uU2lnbmluID0gKF9kID0gcmVzcG9uc2UuZm9yY2VVcGdyYWRlT25TaWduaW4pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSByZXNwb25zZS5zY2hlbWFWZXJzaW9uO1xuICAgIH1cbiAgICB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgcGFzc3dvcmRQb2xpY3k6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHBhc3N3b3JkIGxlbmd0aCBhbmQgY2hhcmFjdGVyIG9wdGlvbnMuXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN0YXR1cyBpbnRvIHNpbmdsZSBpc1ZhbGlkIHByb3BlcnR5LlxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2EgPSBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYiA9IHN0YXR1cy5tZWV0c01heFBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9jID0gc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9kID0gc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9lID0gc3RhdHVzLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdHJ1ZSk7XG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfZiA9IHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlcikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgbGVuZ3RoIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhc3N3b3JkTGVuZ3RoT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IG1pblBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIGNvbnN0IG1heFBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIGlmIChtaW5QYXNzd29yZExlbmd0aCkge1xuICAgICAgICAgICAgc3RhdHVzLm1lZXRzTWluUGFzc3dvcmRMZW5ndGggPSBwYXNzd29yZC5sZW5ndGggPj0gbWluUGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFBhc3N3b3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0dXMubWVldHNNYXhQYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA8PSBtYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcGFzc3dvcmQgbWVldHMgdGhlIGNoYXJhY3RlciBvcHRpb25zIGZvciB0aGUgcG9saWN5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICovXG4gICAgdmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xuICAgICAgICAvLyBBc3NpZ24gc3RhdHVzZXMgZm9yIHJlcXVpcmVtZW50cyBldmVuIGlmIHRoZSBwYXNzd29yZCBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIHRoaXMudXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBcbiAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSk7XG4gICAgICAgIGxldCBwYXNzd29yZENoYXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA9IHBhc3N3b3JkLmNoYXJBdChpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ2EnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICd6JywgXG4gICAgICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gcGFzc3dvcmRDaGFyID49ICdBJyAmJlxuICAgICAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA8PSAnWicsIFxuICAgICAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJzAnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICc5JywgXG4gICAgICAgICAgICAvKiBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcj0gKi8gdGhpcy5hbGxvd2VkTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVycy5pbmNsdWRlcyhwYXNzd29yZENoYXIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBydW5uaW5nIHZhbGlkYXRpb24gc3RhdHVzIHdpdGggdGhlIHN0YXR1c2VzIGZvciB0aGUgY2hhcmFjdGVyIG9wdGlvbnMuXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgY2FsbGVkIGVhY2ggdGltZSBhIGNoYXJhY3RlciBpcyBwcm9jZXNzZWQgdG8gdXBkYXRlIGVhY2ggb3B0aW9uIHN0YXR1c1xuICAgICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhIGxvd2VyY2FzZSBsZXR0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbiB1cHBlcmNhc2UgbGV0dGVyLlxuICAgICAqIEBwYXJhbSBjb250YWluc051bWVyaWNDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbnVtZXJpYyBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIHVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzKHN0YXR1cywgY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyLCBjb250YWluc051bWVyaWNDaGFyYWN0ZXIsIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUxldHRlcikge1xuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyIHx8IChzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgPSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9IGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciB8fCAoc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hcHBDaGVja1NlcnZpY2VQcm92aWRlciA9IGFwcENoZWNrU2VydmljZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW11bGF0b3JDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gPSAxO1xuICAgICAgICAvLyBBbnkgbmV0d29yayBjYWxscyB3aWxsIHNldCB0aGlzIHRvIHRydWUgYW5kIHByZXZlbnQgc3Vic2VxdWVudCBlbXVsYXRvclxuICAgICAgICAvLyBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLl9jYW5Jbml0RW11bGF0b3IgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXJyb3JGYWN0b3J5ID0gX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZO1xuICAgICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJvamVjdFBhc3N3b3JkUG9saWN5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llcyA9IHt9O1xuICAgICAgICB0aGlzLl9yZXNvbHZlUGVyc2lzdGVuY2VNYW5hZ2VyQXZhaWxhYmxlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcmFja3MgdGhlIGxhc3Qgbm90aWZpZWQgVUlEIGZvciBzdGF0ZSBjaGFuZ2UgbGlzdGVuZXJzIHRvIHByZXZlbnRcbiAgICAgICAgLy8gcmVwZWF0ZWQgY2FsbHMgdG8gdGhlIGNhbGxiYWNrcy4gVW5kZWZpbmVkIG1lYW5zIGl0J3MgbmV2ZXIgYmVlblxuICAgICAgICAvLyBjYWxsZWQsIHdoZXJlYXMgbnVsbCBtZWFucyBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYSBzaWduZWQgb3V0IHVzZXJcbiAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7IGFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZzogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5mcmFtZXdvcmtzID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xuICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjb25maWcuc2RrQ2xpZW50VmVyc2lvbjtcbiAgICAgICAgLy8gVE9ETyhqYW1lc2RhbmllbHMpIGV4cGxvcmUgbGVzcyBoYWNreSB3YXkgdG8gZG8gdGhpcywgY29va2llIGF1dGhlbnRpY2F0aW9uIG5lZWRzXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlTWFuYW5nZXIgdG8gYmUgYXZhaWxhYmxlLiBzZWUgX2dldEZpbmFsVGFyZ2V0IGZvciBtb3JlIGNvbnRleHRcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VNYW5hZ2VyQXZhaWxhYmxlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiAodGhpcy5fcmVzb2x2ZVBlcnNpc3RlbmNlTWFuYWdlckF2YWlsYWJsZSA9IHJlc29sdmUpKTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VIaWVyYXJjaHksIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICBpZiAocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBhcHAgZGVsZXRpb24gdGhyb3VnaG91dCBpbml0aWFsaXphdGlvbiAoYWZ0ZXIgZWFjaFxuICAgICAgICAvLyBwcm9taXNlIHJlc29sdXRpb24pXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgcGVyc2lzdGVuY2VIaWVyYXJjaHkpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fcmVzb2x2ZVBlcnNpc3RlbmNlTWFuYWdlckF2YWlsYWJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYXVzZSB0aGUgaWZyYW1lIHRvIGxvYWQgaW1tZWRpYXRlbHkgaW4gY2VydGFpbiBjYXNlcylcbiAgICAgICAgICAgIGlmICgoX2IgPSB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fc2hvdWxkSW5pdFByb2FjdGl2ZWx5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIuX2luaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElnbm9yZSB0aGUgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVDdXJyZW50VXNlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSAoKF9jID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVpZCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XG4gICAgICovXG4gICAgYXN5bmMgX29uU3RvcmFnZUV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRVc2VyICYmICF1c2VyKSB7XG4gICAgICAgICAgICAvLyBObyBjaGFuZ2UsIGRvIG5vdGhpbmcgKHdhcyBzaWduZWQgb3V0IGFuZCByZW1haW5lZCBzaWduZWQgb3V0KS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2FtZSB1c2VyIGlzIHRvIGJlIHN5bmNocm9uaXplZC5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcbiAgICAgICAgICAgIC8vIERhdGEgdXBkYXRlLCBzaW1wbHkgY29weSBkYXRhIGNoYW5nZXMuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fYXNzaWduKHVzZXIpO1xuICAgICAgICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIG5vdGlmeUF1dGhMaXN0ZW5lcnNfLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgQXV0aCBzdGF0ZS4gRWl0aGVyIGEgbmV3IGxvZ2luIG9yIGxvZ291dC5cbiAgICAgICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciwgLyogc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzICovIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbihpZFRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEFjY291bnRJbmZvKHRoaXMsIHsgaWRUb2tlbiB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UodGhpcywgcmVzcG9uc2UsIGlkVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmlyZWJhc2VTZXJ2ZXJBcHAgY291bGQgbm90IGxvZ2luIHVzZXIgd2l0aCBwcm92aWRlZCBhdXRoSWRUb2tlbjogJywgZXJyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IHRoaXMuYXBwLnNldHRpbmdzLmF1dGhJZFRva2VuO1xuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgYXV0aCBvcGVyYXRpb24gaW4gdGhlIG5leHQgdGljayB0byBhbGxvdyBhIG1vbWVudCBmb3IgdGhlIGN1c3RvbWVyJ3MgYXBwIHRvXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGFuIGVtdWxhdG9yLCBpZiBkZXNpcmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluaXRpYWxpemVDdXJyZW50VXNlckZyb21JZFRva2VuKGlkVG9rZW4pLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHBlbmRpbmcgcmVkaXJlY3QgZXZlbnQuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcbiAgICAgICAgbGV0IGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgIGxldCBuZWVkc1RvY2hlY2tNaWRkbGV3YXJlID0gZmFsc2U7XG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVc2VyRXZlbnRJZCA9IChfYSA9IHRoaXMucmVkaXJlY3RVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnRyeVJlZGlyZWN0U2lnbkluKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIHVzZXIgKGkuZS4gdGhlIG9sZCBcImN1cnJlbnRVc2VyXCIpIGhhcyBhIHJlZGlyZWN0SWQgdGhhdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBuZXcgdXNlciBvYmplY3QgZnJvbSByZXN1bHQuXG4gICAgICAgICAgICAvLyBUT0RPKHNhbWdobyk6IE1vcmUgdGhvcm91Z2hseSB0ZXN0IGFsbCBvZiB0aGlzXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxuICAgICAgICAgICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQudXNlcikpIHtcbiAgICAgICAgICAgICAgICBmdXR1cmVDdXJyZW50VXNlciA9IHJlc3VsdC51c2VyO1xuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXG4gICAgICAgIGlmICghZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlci5fcmVkaXJlY3RFdmVudElkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgcmVkaXJlY3QgbGluayBvcGVyYXRpb24sIHdlIGNhbiByZWxvYWQgYW5kIGJhaWwuXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxuICAgICAgICAgICAgaWYgKG5lZWRzVG9jaGVja01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhdmFpbGFibGUgc2luY2UgdGhlIGJpdCBpcyBvbmx5IHNldCB3aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXG4gICAgICAgIC8vIERPIE5PVCByZWxvYWQgdGhlIGN1cnJlbnQgdXNlciwgb3RoZXJ3aXNlIHRoZXknbGwgYmUgY2xlYXJlZCBmcm9tIHN0b3JhZ2UuXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoKSBmbG93LlxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyLl9yZWRpcmVjdEV2ZW50SWQgPT09IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgfVxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgLy8gVGhlIHJlZGlyZWN0IHVzZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCAoYW5kIHNpZ25lZCBpbiBpZiBhdmFpbGFibGUpXG4gICAgICAgIC8vIGR1cmluZyBhdXRoIGluaXRpYWxpemF0aW9uLiBBbGwgb2YgdGhlIG5vcm1hbCBzaWduIGluIGFuZCBsaW5rL3JlYXV0aFxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxuICAgICAgICAvLyBuZWVkIHRvIGF3YWl0IHRoZSByZXN1bHQgb2YgdGhlIHJlZGlyZWN0IHNpZ24gaW4gKmluc2lkZSB0aGUgcHJvbWlzZVxuICAgICAgICAvLyBxdWV1ZSouIFRoaXMgcHJlc2VudHMgYSBwcm9ibGVtOiB3ZSBydW4gaW50byBkZWFkbG9jay4gU2VlOlxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgIC8vICAgIOKUjD4gWzxvdGhlciBxdWV1ZSB0YXNrcz5dIOKUglxuICAgICAgICAvLyAgICDilJTilIAgW2dldFJlZGlyZWN0UmVzdWx0XSA84pSA4pSYXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIHdpbGwgbmV2ZXIgY29tcGxldGUgYmVjYXVzZSBpdCdzIHdhaXRpbmcgb24gc29tZXRoaW5nXG4gICAgICAgIC8vIHRoYXQncyB3YWl0aW5nIGZvciBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW5zdGVhZCwgdGhpcyBtZXRob2QgY2FsbHMgZ2V0UmVkaXJlY3RSZXN1bHQoKSAoc3RvcmVkIGluXG4gICAgICAgIC8vIF9jb21wbGV0ZVJlZGlyZWN0Rm4pIHdpdGggYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgaW5zdHJ1Y3RzIGFsbCBvZlxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxuICAgICAgICAgICAgLy8gaXMgcGFzc2VkIGluLiBUaGUgX2NvbXBsZXRlUmVkaXJlY3RGbiBleHBlY3RzIHRoZSB1bndyYXBwZWQgZXh0ZXJuLlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9jb21wbGV0ZVJlZGlyZWN0Rm4odGhpcywgcmVkaXJlY3RSZXNvbHZlciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgYW55IGVycm9ycyBoZXJlOyB0aGUgY29kZSBjYW4gcmV0cmlldmUgdGhlbSBpblxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyByZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIodXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpICE9PVxuICAgICAgICAgICAgICAgIGBhdXRoLyR7XCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovfWApIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgfVxuICAgIHVzZURldmljZUxhbmd1YWdlKCkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IF9nZXRVc2VyTGFuZ3VhZ2UoKTtcbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUN1cnJlbnRVc2VyKHVzZXJFeHRlcm4pIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcHVibGljIHVwZGF0ZUN1cnJlbnRVc2VyIG1ldGhvZCBuZWVkcyB0byBtYWtlIGEgY29weSBvZiB0aGUgdXNlcixcbiAgICAgICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXh0ZXJuXG4gICAgICAgICAgICA/IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyRXh0ZXJuKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgX2Fzc2VydCh1c2VyLmF1dGguY29uZmlnLmFwaUtleSA9PT0gdGhpcy5jb25maWcuYXBpS2V5LCB0aGlzLCBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciAmJiB1c2VyLl9jbG9uZSh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHRoaXMudGVuYW50SWQgPT09IHVzZXIudGVuYW50SWQsIHRoaXMsIFwidGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZSh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIGZpcnN0LCB0byBibG9jayBfc2V0UmVkaXJlY3RVc2VyKCkgaWYgYW55IGNhbGxiYWNrcyBmYWlsLlxuICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShudWxsKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlciB8fCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGNhbGxiYWNrcyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBpbiBfdXBkYXRlQ3VycmVudFVzZXIsIGFzXG4gICAgICAgIC8vIHRoZXkgd2VyZSBhbHJlYWR5IGNhbGxlZCBpbiB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcbiAgICB9XG4gICAgc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0UGVyc2lzdGVuY2UoX2dldEluc3RhbmNlKHBlcnNpc3RlbmNlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UmVjYXB0Y2hhQ29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmICghdGhpcy5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVQYXNzd29yZFBvbGljeSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhc3N3b3JkIHBvbGljeSB3aWxsIGJlIGRlZmluZWQgYWZ0ZXIgZmV0Y2hpbmcuXG4gICAgICAgIGNvbnN0IHBhc3N3b3JkUG9saWN5ID0gdGhpcy5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2xpY3kgc2NoZW1hIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoZSBTREsuXG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIGxvZ2ljIHRvIHVzZSBhIG1heCBzdXBwb3J0ZWQgcG9saWN5IHNjaGVtYSB2ZXJzaW9uIG9uY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzY2hlbWEgdmVyc2lvbnMuXG4gICAgICAgIGlmIChwYXNzd29yZFBvbGljeS5zY2hlbWFWZXJzaW9uICE9PVxuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvckZhY3RvcnkuY3JlYXRlKFwidW5zdXBwb3J0ZWQtcGFzc3dvcmQtcG9saWN5LXNjaGVtYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gKi8sIHt9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3N3b3JkUG9saWN5LnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIH1cbiAgICBfZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llc1t0aGlzLnRlbmFudElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlUGFzc3dvcmRQb2xpY3koKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2dldFBhc3N3b3JkUG9saWN5KHRoaXMpO1xuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IG5ldyBQYXNzd29yZFBvbGljeUltcGwocmVzcG9uc2UpO1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdFBhc3N3b3JkUG9saWN5ID0gcGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdID0gcGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFBlcnNpc3RlbmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5wZXJzaXN0ZW5jZS50eXBlO1xuICAgIH1cbiAgICBfZ2V0UGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucGVyc2lzdGVuY2U7XG4gICAgfVxuICAgIF91cGRhdGVFcnJvck1hcChlcnJvck1hcCkge1xuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXAoKSk7XG4gICAgfVxuICAgIG9uQXV0aFN0YXRlQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICB9XG4gICAgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCk7XG4gICAgfVxuICAgIG9uSWRUb2tlbkNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xuICAgIH1cbiAgICBhdXRoU3RhdGVSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uQXV0aFN0YXRlQ2hhbmdlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyB0aGUgZ2l2ZW4gYWNjZXNzIHRva2VuLiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIHJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsaXplIHRoaXMgdG8gYWNjZXB0IG90aGVyIHByb3ZpZGVycyBvbmNlIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJJZDogJ2FwcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBcIkFDQ0VTU19UT0tFTlwiIC8qIFRva2VuVHlwZS5BQ0NFU1NfVE9LRU4gKi8sXG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgaWRUb2tlblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbmFudElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRlbmFudElkID0gdGhpcy50ZW5hbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJldm9rZVRva2VuKHRoaXMsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmNvbmZpZy5hcGlLZXksXG4gICAgICAgICAgICBhdXRoRG9tYWluOiB0aGlzLmNvbmZpZy5hdXRoRG9tYWluLFxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgY3VycmVudFVzZXI6IChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFJlZGlyZWN0VXNlcih1c2VyLCBwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RNYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxuICAgICAgICAgICAgPyByZWRpcmVjdE1hbmFnZXIucmVtb3ZlQ3VycmVudFVzZXIoKVxuICAgICAgICAgICAgOiByZWRpcmVjdE1hbmFnZXIuc2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICBpZiAoIXRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXI7XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLCBcInJlZGlyZWN0VXNlclwiIC8qIEtleU5hbWUuUkVESVJFQ1RfVVNFUiAqLyk7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlci5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIGNsZWFyZWQgYW55IHBlbmRpbmcgcGVyc2lzdGVuY2UgYWN0aW9ucyBpZiB3ZSdyZSBub3QgaW5cbiAgICAgICAgLy8gdGhlIGluaXRpYWxpemVyXG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRVc2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9iID0gdGhpcy5yZWRpcmVjdFVzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fcmVkaXJlY3RFdmVudElkKSA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0VXNlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpIHtcbiAgICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIE5vdGlmaWVzIGxpc3RlbmVycyBvbmx5IGlmIHRoZSB1c2VyIGlzIGN1cnJlbnQgKi9cbiAgICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXIpIHtcbiAgICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5QXV0aExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9rZXkoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcbiAgICB9XG4gICAgX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGN1cnJlbnQgdXNlciBjYXN0IGFzIHRoZSBpbnRlcm5hbCB0eXBlICovXG4gICAgZ2V0IF9jdXJyZW50VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFVzZXI7XG4gICAgfVxuICAgIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vdGlmaWVkVWlkICE9PSBjdXJyZW50VWlkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IGN1cnJlbnRVaWQ7XG4gICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihzdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNiID0gdHlwZW9mIG5leHRPck9ic2VydmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IG5leHRPck9ic2VydmVyXG4gICAgICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XG4gICAgICAgIGxldCBpc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5faXNJbml0aWFsaXplZFxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICAgIF9hc3NlcnQocHJvbWlzZSwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG5leHRPck9ic2VydmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaXB0aW9uLmFkZE9ic2VydmVyKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucHJvdGVjdGVkIChmcm9tIHJhY2UgY29uZGl0aW9ucykgbWV0aG9kIHRvIHNldCB0aGUgY3VycmVudCB1c2VyLiBUaGlzXG4gICAgICogc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgcXVldWVkIGNhbGxiYWNrLiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgICAqIGJlY2F1c2UgdGhlIHF1ZXVlIHNob3VsZG4ndCByZWx5IG9uIGFub3RoZXIgcXVldWVkIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIGRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyICE9PSB1c2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlciAmJiB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnJlbW92ZUN1cnJlbnRVc2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUoYWN0aW9uKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugc29tZXRoaW5nIGVycm9ycywgdGhlIGNhbGxiYWNrIHN0aWxsIHNob3VsZCBiZSBjYWxsZWQgaW4gb3JkZXJcbiAgICAgICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSB0aGlzLm9wZXJhdGlvbnMudGhlbihhY3Rpb24sIGFjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnM7XG4gICAgfVxuICAgIGdldCBhc3NlcnRlZFBlcnNpc3RlbmNlKCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyLCB0aGlzLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgICB9XG4gICAgX2xvZ0ZyYW1ld29yayhmcmFtZXdvcmspIHtcbiAgICAgICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1ld29ya3MucHVzaChmcmFtZXdvcmspO1xuICAgICAgICAvLyBTb3J0IGFscGhhYmV0aWNhbGx5IHNvIHRoYXQgXCJGaXJlYmFzZUNvcmUtd2ViLEZpcmViYXNlVUktd2ViXCIgYW5kXG4gICAgICAgIC8vIFwiRmlyZWJhc2VVSS13ZWIsRmlyZWJhc2VDb3JlLXdlYlwiIGFyZW4ndCB2aWV3ZWQgYXMgZGlmZmVyZW50LlxuICAgICAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xuICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBfZ2V0Q2xpZW50VmVyc2lvbih0aGlzLmNvbmZpZy5jbGllbnRQbGF0Zm9ybSwgdGhpcy5fZ2V0RnJhbWV3b3JrcygpKTtcbiAgICB9XG4gICAgX2dldEZyYW1ld29ya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1ld29ya3M7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBBZGRpdGlvbmFsIGhlYWRlcnMgb24gZXZlcnkgcmVxdWVzdFxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgW1wiWC1DbGllbnQtVmVyc2lvblwiIC8qIEh0dHBIZWFkZXIuWF9DTElFTlRfVkVSU0lPTiAqL106IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtZ21waWRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfR01QSUQgKi9dID0gdGhpcy5hcHAub3B0aW9ucy5hcHBJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0ICgoX2EgPSB0aGlzLmhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSh7XG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEhlYXJ0YmVhdHNIZWFkZXIoKSk7XG4gICAgICAgIGlmIChoZWFydGJlYXRzSGVhZGVyKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1DbGllbnRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQ0xJRU5UICovXSA9IGhlYXJ0YmVhdHNIZWFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIEFwcCBDaGVjayBzZXJ2aWNlIGV4aXN0cywgYWRkIHRoZSBBcHAgQ2hlY2sgdG9rZW4gaW4gdGhlIGhlYWRlcnNcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUFwcENoZWNrXCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0FQUF9DSEVDSyAqL10gPSBhcHBDaGVja1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApICYmIHRoaXMuYXBwLnNldHRpbmdzLmFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5zZXR0aW5ncy5hcHBDaGVja1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcENoZWNrVG9rZW5SZXN1bHQgPSBhd2FpdCAoKF9hID0gdGhpcy5hcHBDaGVja1NlcnZpY2VQcm92aWRlclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VG9rZW4oKSk7XG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENvbnRleHQ6IGFwcENoZWNrLmdldFRva2VuKCkgd2lsbCBuZXZlciB0aHJvdyBldmVuIGlmIGFuIGVycm9yIGhhcHBlbmVkLlxuICAgICAgICAgICAgLy8gSW4gdGhlIGVycm9yIGNhc2UsIGEgZHVtbXkgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIGFuIGVycm9yIGZpZWxkIGRlc2NyaWJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlbiAoYWN0dWFsIG9yIGR1bW15KSB0byBzZW5kIHJlcXVlc3RzLlxuICAgICAgICAgICAgX2xvZ1dhcm4oYEVycm9yIHdoaWxlIHJldHJpZXZpbmcgQXBwIENoZWNrIHRva2VuOiAke2FwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IG51bGwgfHwgYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQ2hlY2tUb2tlblJlc3VsdC50b2tlbjtcbiAgICB9XG59XG4vKipcbiAqIE1ldGhvZCB0byBiZSB1c2VkIHRvIGNhc3QgZG93biB0byBvdXIgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBBdXRoLlxuICogSXQgd2lsbCBhbHNvIGhhbmRsZSB1bndyYXBwaW5nIGZyb20gdGhlIGNvbXBhdCB0eXBlIGlmIG5lY2Vzc2FyeVxuICpcbiAqIEBwYXJhbSBhdXRoIEF1dGggb2JqZWN0IHBhc3NlZCBpbiBmcm9tIGRldmVsb3BlclxuICovXG5mdW5jdGlvbiBfY2FzdEF1dGgoYXV0aCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG59XG4vKiogSGVscGVyIGNsYXNzIHRvIHdyYXAgc3Vic2NyaWJlciBsb2dpYyAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFkZE9ic2VydmVyID0gY3JlYXRlU3Vic2NyaWJlKG9ic2VydmVyID0+ICh0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXIpKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7XG4gICAgICAgIF9hc3NlcnQodGhpcy5vYnNlcnZlciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVyLm5leHQuYmluZCh0aGlzLm9ic2VydmVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5sZXQgZXh0ZXJuYWxKU1Byb3ZpZGVyID0ge1xuICAgIGFzeW5jIGxvYWRKUygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHRzJyk7XG4gICAgfSxcbiAgICByZWNhcHRjaGFWMlNjcmlwdDogJycsXG4gICAgcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdDogJycsXG4gICAgZ2FwaVNjcmlwdDogJydcbn07XG5mdW5jdGlvbiBfbG9hZEpTKHVybCkge1xuICAgIHJldHVybiBleHRlcm5hbEpTUHJvdmlkZXIubG9hZEpTKHVybCk7XG59XG5mdW5jdGlvbiBfcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdFVybCgpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLnJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNb2NrR3JlQ0FQVENIQVRvcExldmVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbnRlcnByaXNlID0gbmV3IE1vY2tHcmVDQVBUQ0hBKCk7XG4gICAgfVxuICAgIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGV4ZWN1dGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9zaXRlS2V5LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0b2tlbicpO1xuICAgIH1cbiAgICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXIsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5jbGFzcyBNb2NrR3JlQ0FQVENIQSB7XG4gICAgcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZXhlY3V0ZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3NpdGVLZXksIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Rva2VuJyk7XG4gICAgfVxuICAgIHJlbmRlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2NvbnRhaW5lciwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XG5jb25zdCBGQUtFX1RPS0VOID0gJ05PX1JFQ0FQVENIQSc7XG5jbGFzcyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhFeHRlcm4gLSBUaGUgY29ycmVzcG9uZGluZyBGaXJlYmFzZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoRXh0ZXJuKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIHRoZSB0eXBlIG9mIGFwcGxpY2F0aW9uIHZlcmlmaWVyIChlLmcuIFwicmVjYXB0Y2hhLWVudGVycHJpc2VcIikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xuICAgICAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdmFsaWRpdHkgb2YgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeShhY3Rpb24gPSAndmVyaWZ5JywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGgpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgPT0gbnVsbCAmJiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXS5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdyZWNhcHRjaGEgRW50ZXJwcmlzZSBzaXRlIGtleSB1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25maWcuc2l0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcbiAgICAgICAgICAgIGlmIChpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkpIHtcbiAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UucmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjdXRlKHNpdGVLZXksIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEZBS0VfVE9LRU4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChFcnJvcignTm8gcmVDQVBUQ0hBIGVudGVycHJpc2Ugc2NyaXB0IGxvYWRlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyBQcm9taXNlIGZvciBhIG1vY2sgdG9rZW4gd2hlbiBhcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMuYXV0aC5zZXR0aW5ncy5hcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZWNhcHRjaGEgPSBuZXcgTW9ja0dyZUNBUFRDSEFUb3BMZXZlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vY2tSZWNhcHRjaGEuZXhlY3V0ZSgnc2l0ZUtleScsIHsgYWN0aW9uOiAndmVyaWZ5JyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0cmlldmVTaXRlS2V5KHRoaXMuYXV0aClcbiAgICAgICAgICAgICAgICAudGhlbihzaXRlS2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0VudGVycHJpc2Uod2luZG93LmdyZWNhcHRjaGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBzaXRlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9sb2FkSlModXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoLCByZXF1ZXN0LCBhY3Rpb24sIGlzQ2FwdGNoYVJlc3AgPSBmYWxzZSwgaXNGYWtlVG9rZW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoKTtcbiAgICBsZXQgY2FwdGNoYVJlc3BvbnNlO1xuICAgIGlmIChpc0Zha2VUb2tlbikge1xuICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBGQUtFX1RPS0VOO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3UmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpO1xuICAgIGlmIChhY3Rpb24gPT09IFwibWZhU21zRW5yb2xsbWVudFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuTUZBX1NNU19FTlJPTExNRU5UICovIHx8XG4gICAgICAgIGFjdGlvbiA9PT0gXCJtZmFTbXNTaWduSW5cIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLk1GQV9TTVNfU0lHTklOICovKSB7XG4gICAgICAgIGlmICgncGhvbmVFbnJvbGxtZW50SW5mbycgaW4gbmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSBuZXdSZXF1ZXN0LnBob25lRW5yb2xsbWVudEluZm8ucGhvbmVOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVFbnJvbGxtZW50SW5mby5yZWNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICdwaG9uZUVucm9sbG1lbnRJbmZvJzoge1xuICAgICAgICAgICAgICAgICAgICBwaG9uZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgncGhvbmVTaWduSW5JbmZvJyBpbiBuZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVTaWduSW5JbmZvLnJlY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgJ3Bob25lU2lnbkluSW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmVxdWVzdDtcbiAgICB9XG4gICAgaWYgKCFpc0NhcHRjaGFSZXNwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyBjYXB0Y2hhUmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NhcHRjaGFSZXNwJzogY2FwdGNoYVJlc3BvbnNlIH0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovIH0pO1xuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3UmVxdWVzdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25NZXRob2QsIHJlY2FwdGNoYUF1dGhQcm92aWRlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHJlY2FwdGNoYUF1dGhQcm92aWRlciA9PT0gXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykge1xuICAgICAgICBpZiAoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgYWN0aW9uTmFtZSA9PT0gXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0KS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL31gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2FjdGlvbk5hbWV9IGlzIHByb3RlY3RlZCBieSByZUNBUFRDSEEgRW50ZXJwcmlzZSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBmbG93LmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVjYXB0Y2hhQXV0aFByb3ZpZGVyID09PSBcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSB7XG4gICAgICAgIGlmICgoX2IgPSBhdXRoSW5zdGFuY2VcbiAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc1Byb3ZpZGVyRW5hYmxlZChcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUoXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykpID09PSBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBVURJVCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovfWAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovfWApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gdmVyaWZ5IHdpdGggcmVDQVBUQ0hBIEVudGVycHJpc2UuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIHYyIGZsb3cgdG8gY29tcGxldGUgdGhlICR7YWN0aW9uTmFtZX0gZmxvdy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlQ0FQVENIQSBFbnRlcnByaXNlIHRva2VuIGlzIG1pc3Npbmcgb3IgcmVDQVBUQ0hBIEVudGVycHJpc2UgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZhaWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcmVDQVBUQ0hBIHYyIGZsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGZhbHNlLCAvLyBpc0NhcHRjaGFSZXNwXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlIC8vIGlzRmFrZVRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgdGhlIFBob25lQXBpQ2FsbGVyIHRvIGZldGNoIGFuZCBpbmplY3QgcmVDQVBUQ0hBIHYyIHRva2VuLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFTkZPUkNFIG1vZGUgb3IgQVVESVQgbW9kZSB3aXRoIGFueSBvdGhlciBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyByZUNBUFRDSEEgdjIgZmxvdy5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgZmFsc2UsIC8vIGlzQ2FwdGNoYVJlc3BcbiAgICAgICAgICAgIHRydWUgLy8gaXNGYWtlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCB0aGUgUGhvbmVBcGlDYWxsZXIgdG8gZmV0Y2ggYW5kIGluamVjdCB2MiB0b2tlbi5cbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWNhcHRjaGFBdXRoUHJvdmlkZXIgKyAnIHByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xuICAgIGlmIChhdXRoSW50ZXJuYWwudGVuYW50SWQgPT0gbnVsbCkge1xuICAgICAgICBhdXRoSW50ZXJuYWwuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aEludGVybmFsLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGhJbnRlcm5hbC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgfVxuICAgIGlmIChjb25maWcuaXNBbnlQcm92aWRlckVuYWJsZWQoKSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIoYXV0aEludGVybmFsKTtcbiAgICAgICAgdm9pZCB2ZXJpZmllci52ZXJpZnkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAqIHtAbGluayBEZXBlbmRlbmNpZXN9LlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXG4gKiB7QGxpbmsgZ2V0QXV0aH0uIGBnZXRBdXRoYCB1c2VzIHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzIHRvIHN1cHBseVxuICogdGhlIHtAbGluayBEZXBlbmRlbmNpZXN9LiBJbiBnZW5lcmFsLCBgZ2V0QXV0aGAgaXMgdGhlIGVhc2llc3Qgd2F5IHRvXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XG4gKiBuZWVkIGNvbnRyb2wgb3ZlciB3aGljaCBwZXJzaXN0ZW5jZSBsYXllciBpcyB1c2VkLCBvciB0byBtaW5pbWl6ZSBidW5kbGVcbiAqIHNpemUgaWYgeW91J3JlIG5vdCB1c2luZyBlaXRoZXIgYHNpZ25JbldpdGhQb3B1cGAgb3IgYHNpZ25JbldpdGhSZWRpcmVjdGAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdXIgYXBwIG9ubHkgdXNlcyBhbm9ueW1vdXMgYWNjb3VudHMgYW5kIHlvdSBvbmx5IHdhbnRcbiAqIGFjY291bnRzIHNhdmVkIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLCBpbml0aWFsaXplIGBBdXRoYCB3aXRoOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwLCB7XG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxuICogICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IHVuZGVmaW5lZCxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQXV0aChhcHAsIGRlcHMpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gcHJvdmlkZXIuZ2V0T3B0aW9ucygpO1xuICAgICAgICBpZiAoZGVlcEVxdWFsKGluaXRpYWxPcHRpb25zLCBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHZvaWQgMCA/IGRlcHMgOiB7fSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7IG9wdGlvbnM6IGRlcHMgfSk7XG4gICAgcmV0dXJuIGF1dGg7XG59XG5mdW5jdGlvbiBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoLCBkZXBzKSB7XG4gICAgY29uc3QgcGVyc2lzdGVuY2UgPSAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnBlcnNpc3RlbmNlKSB8fCBbXTtcbiAgICBjb25zdCBoaWVyYXJjaHkgPSAoQXJyYXkuaXNBcnJheShwZXJzaXN0ZW5jZSkgPyBwZXJzaXN0ZW5jZSA6IFtwZXJzaXN0ZW5jZV0pLm1hcChfZ2V0SW5zdGFuY2UpO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuZXJyb3JNYXApIHtcbiAgICAgICAgYXV0aC5fdXBkYXRlRXJyb3JNYXAoZGVwcy5lcnJvck1hcCk7XG4gICAgfVxuICAgIC8vIFRoaXMgcHJvbWlzZSBpcyBpbnRlbmRlZCB0byBmbG9hdDsgYXV0aCBpbml0aWFsaXphdGlvbiBoYXBwZW5zIGluIHRoZVxuICAgIC8vIGJhY2tncm91bmQsIG1lYW53aGlsZSB0aGUgYXV0aCBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgYXV0aC5faW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShoaWVyYXJjaHksIGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBGaXJlYmFzZSBBdXRoIEVtdWxhdG9yLCBpbnN0ZWFkIG9mIHByb2R1Y3Rpb25cbiAqIEZpcmViYXNlIEF1dGggc2VydmljZXMuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIGZpcnN0IGNhbGwgdG9cbiAqIHtAbGluayBpbml0aWFsaXplQXV0aH0uICBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscyBhcyBlbXVsYXRvclxuICogdHJhZmZpYyBpcyBub3QgZW5jcnlwdGVkLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29ubmVjdEF1dGhFbXVsYXRvcihhdXRoLCAnaHR0cDovLzEyNy4wLjAuMTo5MDk5JywgeyBkaXNhYmxlV2FybmluZ3M6IHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBhdCB3aGljaCB0aGUgZW11bGF0b3IgaXMgcnVubmluZyAoZWcsICdodHRwOi8vbG9jYWxob3N0OjkwOTknKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIGBvcHRpb25zLmRpc2FibGVXYXJuaW5nc2AgZGVmYXVsdHMgdG8gYGZhbHNlYC4gU2V0IGl0IHRvXG4gKiBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgd2FybmluZyBiYW5uZXIgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgdXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIF9hc3NlcnQoL15odHRwcz86XFwvXFwvLy50ZXN0KHVybCksIGF1dGhJbnRlcm5hbCwgXCJpbnZhbGlkLWVtdWxhdG9yLXNjaGVtZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUgKi8pO1xuICAgIGNvbnN0IGRpc2FibGVXYXJuaW5ncyA9ICEhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlV2FybmluZ3MpO1xuICAgIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XG4gICAgY29uc3QgeyBob3N0LCBwb3J0IH0gPSBleHRyYWN0SG9zdEFuZFBvcnQodXJsKTtcbiAgICBjb25zdCBwb3J0U3RyID0gcG9ydCA9PT0gbnVsbCA/ICcnIDogYDoke3BvcnR9YDtcbiAgICAvLyBBbHdheXMgcmVwbGFjZSBwYXRoIHdpdGggXCIvXCIgKGV2ZW4gaWYgaW5wdXQgdXJsIGhhZCBubyBwYXRoIGF0IGFsbCwgb3IgaGFkIGEgZGlmZmVyZW50IG9uZSkuXG4gICAgY29uc3QgZW11bGF0b3IgPSB7IHVybDogYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwb3J0U3RyfS9gIH07XG4gICAgY29uc3QgZW11bGF0b3JDb25maWcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sLnJlcGxhY2UoJzonLCAnJyksXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5mcmVlemUoeyBkaXNhYmxlV2FybmluZ3MgfSlcbiAgICB9KTtcbiAgICAvLyBUaGVyZSBhcmUgYSBmZXcgc2NlbmFyaW9zIHRvIGd1YXJkIGFnYWluc3QgaWYgdGhlIEF1dGggaW5zdGFuY2UgaGFzIGFscmVhZHkgc3RhcnRlZDpcbiAgICBpZiAoIWF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yKSB7XG4gICAgICAgIC8vIEFwcGxpY2F0aW9ucyBtYXkgbm90IGluaXRpYWxpemUgdGhlIGVtdWxhdG9yIGZvciB0aGUgZmlyc3QgdGltZSBpZiBBdXRoIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgLy8gdG8gbWFrZSBuZXR3b3JrIHJlcXVlc3RzLlxuICAgICAgICBfYXNzZXJ0KGF1dGhJbnRlcm5hbC5jb25maWcuZW11bGF0b3IgJiYgYXV0aEludGVybmFsLmVtdWxhdG9yQ29uZmlnLCBhdXRoSW50ZXJuYWwsIFwiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqLyk7XG4gICAgICAgIC8vIEFwcGxpY2F0aW9ucyBtYXkgbm90IGFsdGVyIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBlbXVsYXRvciAoYWthIHBhc3MgYSBkaWZmZXJlbnQgY29uZmlnKVxuICAgICAgICAvLyBvbmNlIEF1dGggaGFzIHN0YXJ0ZWQgdG8gbWFrZSBuZXR3b3JrIHJlcXVlc3RzLlxuICAgICAgICBfYXNzZXJ0KGRlZXBFcXVhbChlbXVsYXRvciwgYXV0aEludGVybmFsLmNvbmZpZy5lbXVsYXRvcikgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbChlbXVsYXRvckNvbmZpZywgYXV0aEludGVybmFsLmVtdWxhdG9yQ29uZmlnKSwgYXV0aEludGVybmFsLCBcImVtdWxhdG9yLWNvbmZpZy1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkVNVUxBVE9SX0NPTkZJR19GQUlMRUQgKi8pO1xuICAgICAgICAvLyBJdCdzIHZhbGlkLCBob3dldmVyLCB0byBpbnZva2UgY29ubmVjdEF1dGhFbXVsYXRvcigpIGFmdGVyIEF1dGggaGFzIHN0YXJ0ZWQgbWFraW5nXG4gICAgICAgIC8vIGNvbm5lY3Rpb25zLCBzbyBsb25nIGFzIHRoZSBjb25maWcgbWF0Y2hlcyB0aGUgZXhpc3RpbmcgY29uZmlnLiBUaGlzIHJlc3VsdHMgaW4gYSBuby1vcC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yID0gZW11bGF0b3I7XG4gICAgYXV0aEludGVybmFsLmVtdWxhdG9yQ29uZmlnID0gZW11bGF0b3JDb25maWc7XG4gICAgYXV0aEludGVybmFsLnNldHRpbmdzLmFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZyA9IHRydWU7XG4gICAgLy8gV29ya2Fyb3VuZCB0byBnZXQgY29va2llcyBpbiBGaXJlYmFzZSBTdHVkaW9cbiAgICBpZiAoaXNDbG91ZFdvcmtzdGF0aW9uKGhvc3QpKSB7XG4gICAgICAgIHZvaWQgcGluZ1NlcnZlcihgJHtwcm90b2NvbH0vLyR7aG9zdH0ke3BvcnRTdHJ9YCk7XG4gICAgICAgIHVwZGF0ZUVtdWxhdG9yQmFubmVyKCdBdXRoJywgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFkaXNhYmxlV2FybmluZ3MpIHtcbiAgICAgICAgZW1pdEVtdWxhdG9yV2FybmluZygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbCh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbEVuZCA9IHVybC5pbmRleE9mKCc6Jyk7XG4gICAgcmV0dXJuIHByb3RvY29sRW5kIDwgMCA/ICcnIDogdXJsLnN1YnN0cigwLCBwcm90b2NvbEVuZCArIDEpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCkge1xuICAgIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XG4gICAgY29uc3QgYXV0aG9yaXR5ID0gLyhcXC9cXC8pPyhbXj8jL10rKS8uZXhlYyh1cmwuc3Vic3RyKHByb3RvY29sLmxlbmd0aCkpOyAvLyBCZXR3ZWVuIC8vIGFuZCAvLCA/IG9yICMuXG4gICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIHsgaG9zdDogJycsIHBvcnQ6IG51bGwgfTtcbiAgICB9XG4gICAgY29uc3QgaG9zdEFuZFBvcnQgPSBhdXRob3JpdHlbMl0uc3BsaXQoJ0AnKS5wb3AoKSB8fCAnJzsgLy8gU3RyaXAgb3V0IFwidXNlcm5hbWU6cGFzc3dvcmRAXCIuXG4gICAgY29uc3QgYnJhY2tldGVkSVB2NiA9IC9eKFxcW1teXFxdXStcXF0pKDp8JCkvLmV4ZWMoaG9zdEFuZFBvcnQpO1xuICAgIGlmIChicmFja2V0ZWRJUHY2KSB7XG4gICAgICAgIGNvbnN0IGhvc3QgPSBicmFja2V0ZWRJUHY2WzFdO1xuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQoaG9zdEFuZFBvcnQuc3Vic3RyKGhvc3QubGVuZ3RoICsgMSkpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBbaG9zdCwgcG9ydF0gPSBob3N0QW5kUG9ydC5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQocG9ydCkgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVBvcnQocG9ydFN0cikge1xuICAgIGlmICghcG9ydFN0cikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcG9ydCA9IE51bWJlcihwb3J0U3RyKTtcbiAgICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3J0O1xufVxuZnVuY3Rpb24gZW1pdEVtdWxhdG9yV2FybmluZygpIHtcbiAgICBmdW5jdGlvbiBhdHRhY2hCYW5uZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBjb25zdCBzdHkgPSBlbC5zdHlsZTtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID1cbiAgICAgICAgICAgICdSdW5uaW5nIGluIGVtdWxhdG9yIG1vZGUuIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLic7XG4gICAgICAgIHN0eS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHN0eS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgc3R5LmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJztcbiAgICAgICAgc3R5LmJvcmRlciA9ICcuMWVtIHNvbGlkICMwMDAwMDAnO1xuICAgICAgICBzdHkuY29sb3IgPSAnI2I1MDAwMCc7XG4gICAgICAgIHN0eS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgc3R5LmxlZnQgPSAnMHB4JztcbiAgICAgICAgc3R5Lm1hcmdpbiA9ICcwcHgnO1xuICAgICAgICBzdHkuekluZGV4ID0gJzEwMDAwJztcbiAgICAgICAgc3R5LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmaXJlYmFzZS1lbXVsYXRvci13YXJuaW5nJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdXQVJOSU5HOiBZb3UgYXJlIHVzaW5nIHRoZSBBdXRoIEVtdWxhdG9yLCcgK1xuICAgICAgICAgICAgJyB3aGljaCBpcyBpbnRlbmRlZCBmb3IgbG9jYWwgdGVzdGluZyBvbmx5LiAgRG8gbm90IHVzZSB3aXRoJyArXG4gICAgICAgICAgICAnIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYXR0YWNoQmFubmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dGFjaEJhbm5lcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSBhbiB7QGxpbmsgQXV0aFByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wbGVtZW50YXRpb25zIHNwZWNpZnkgdGhlIGRldGFpbHMgYWJvdXQgZWFjaCBhdXRoIHByb3ZpZGVyJ3MgY3JlZGVudGlhbCByZXF1aXJlbWVudHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBBdXRoQ3JlZGVudGlhbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBJRCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCAnZmFjZWJvb2suY29tJywgb3IgJ2dvb2dsZS5jb20nLlxuICAgICAqL1xuICAgIHByb3ZpZGVySWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBzaWduIGluIG1ldGhvZCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRCwgb3JcbiAgICAgKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaWduLWluIG1ldGhvZFxuICAgICAqIGlkZW50aWZpZXIgYXMgcmV0dXJuZWQgaW4ge0BsaW5rIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsfS5cbiAgICAgKi9cbiAgICBzaWduSW5NZXRob2QpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICAgICAgdGhpcy5zaWduSW5NZXRob2QgPSBzaWduSW5NZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoX2F1dGgpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbGlua1RvSWRUb2tlbihfYXV0aCwgX2lkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKF9hdXRoKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc2V0UGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpyZXNldFBhc3N3b3JkXCIgLyogRW5kcG9pbnQuUkVTRVRfUEFTU1dPUkQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG4vLyBVc2VkIGZvciBsaW5raW5nIGFuIGVtYWlsL3Bhc3N3b3JkIGFjY291bnQgdG8gYW4gZXhpc3RpbmcgaWRUb2tlbi4gVXNlcyB0aGUgc2FtZSByZXF1ZXN0L3Jlc3BvbnNlXG4vLyBmb3JtYXQgYXMgdXBkYXRlRW1haWxQYXNzd29yZC5cbmFzeW5jIGZ1bmN0aW9uIGxpbmtFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnblVwXCIgLyogRW5kcG9pbnQuU0lHTl9VUCAqLywgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEFTU1dPUkQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNlbmRPb2JDb2RlXCIgLyogRW5kcG9pbnQuU0VORF9PT0JfQ09ERSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlBbmRDaGFuZ2VFbWFpbChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGlua1wiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoRW1haWxMaW5rXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gZm9yXG4gKiB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkRcbiAqXG4gKiBAcmVtYXJrc1xuICogQ292ZXJzIGJvdGgge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRW1haWxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9lbWFpbCwgXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wYXNzd29yZCwgc2lnbkluTWV0aG9kLCBcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RlbmFudElkID0gbnVsbCkge1xuICAgICAgICBzdXBlcihcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLywgc2lnbkluTWV0aG9kKTtcbiAgICAgICAgdGhpcy5fZW1haWwgPSBfZW1haWw7XG4gICAgICAgIHRoaXMuX3Bhc3N3b3JkID0gX3Bhc3N3b3JkO1xuICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IF90ZW5hbnRJZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQsIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi8pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tRW1haWxBbmRDb2RlKGVtYWlsLCBvb2JDb2RlLCB0ZW5hbnRJZCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbWFpbEF1dGhDcmVkZW50aWFsKGVtYWlsLCBvb2JDb2RlLCBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovLCB0ZW5hbnRJZCk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXG4gICAgICAgICAgICB0ZW5hbnRJZDogdGhpcy5fdGVuYW50SWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIEVpdGhlciBgb2JqZWN0YCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC4gV2hlbiBzdHJpbmcgaXNcbiAgICAgKiBwcm92aWRlZCwgYEpTT04ucGFyc2VgIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5lbWFpbCkgJiYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5wYXNzd29yZCkpIHtcbiAgICAgICAgICAgIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZFBhc3N3b3JkKG9iai5lbWFpbCwgb2JqLnBhc3N3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvbUVtYWlsQW5kQ29kZShvYmouZW1haWwsIG9iai5wYXNzd29yZCwgb2JqLnRlbmFudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoLCByZXF1ZXN0LCBcInNpZ25JbldpdGhQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9JTl9XSVRIX1BBU1NXT1JEICovLCBzaWduSW5XaXRoUGFzc3dvcmQsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoRW1haWxMaW5rJDEoYXV0aCwge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoLCByZXF1ZXN0LCBcInNpZ25VcFBhc3N3b3JkXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX1VQX1BBU1NXT1JEICovLCBsaW5rRW1haWxQYXNzd29yZCwgXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLyk7XG4gICAgICAgICAgICBjYXNlIFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoSWRwXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0lEUCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IElEUF9SRVFVRVNUX1VSSSQxID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBPQXV0aCBjcmVkZW50aWFscyByZXR1cm5lZCBieSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgT0F1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHBhcmFtcy5wcm92aWRlcklkLCBwYXJhbXMuc2lnbkluTWV0aG9kKTtcbiAgICAgICAgaWYgKHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gT0F1dGggMiBhbmQgZWl0aGVyIElEIHRva2VuIG9yIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIGNyZWQuaWRUb2tlbiA9IHBhcmFtcy5pZFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSBwYXJhbXMuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgbm9uY2UgaWYgYXZhaWxhYmxlIGFuZCBubyBwZW5kaW5nVG9rZW4gaXMgcHJlc2VudC5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubm9uY2UgJiYgIXBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLm5vbmNlID0gcGFyYW1zLm5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHBhcmFtcy5wZW5kaW5nVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm9hdXRoVG9rZW4gJiYgcGFyYW1zLm9hdXRoVG9rZW5TZWNyZXQpIHtcbiAgICAgICAgICAgIC8vIE9BdXRoIDEgYW5kIE9BdXRoIHRva2VuIHdpdGggdG9rZW4gc2VjcmV0XG4gICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLm9hdXRoVG9rZW47XG4gICAgICAgICAgICBjcmVkLnNlY3JldCA9IHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZhaWwoXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVkO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRUb2tlbjogdGhpcy5pZFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kIH0gPSBvYmosIHJlc3QgPSBfX3Jlc3Qob2JqLCBbXCJwcm92aWRlcklkXCIsIFwic2lnbkluTWV0aG9kXCJdKTtcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8ICFzaWduSW5NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIGNyZWQuaWRUb2tlbiA9IHJlc3QuaWRUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSByZXN0LmFjY2Vzc1Rva2VuIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgY3JlZC5zZWNyZXQgPSByZXN0LnNlY3JldDtcbiAgICAgICAgY3JlZC5ub25jZSA9IHJlc3Qubm9uY2U7XG4gICAgICAgIGNyZWQucGVuZGluZ1Rva2VuID0gcmVzdC5wZW5kaW5nVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIGNyZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJJDEsXG4gICAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QucGVuZGluZ1Rva2VuID0gdGhpcy5wZW5kaW5nVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0Qm9keSA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydpZF90b2tlbiddID0gdGhpcy5pZFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnYWNjZXNzX3Rva2VuJ10gPSB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ29hdXRoX3Rva2VuX3NlY3JldCddID0gdGhpcy5zZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0Qm9keVsncHJvdmlkZXJJZCddID0gdGhpcy5wcm92aWRlcklkO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9uY2UgJiYgIXRoaXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ25vbmNlJ10gPSB0aGlzLm5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5wb3N0Qm9keSA9IHF1ZXJ5c3RyaW5nKHBvc3RCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbiAgICBpZiAocmVzcG9uc2UudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmNvbnN0IFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8gPSB7XG4gICAgW1wiVVNFUl9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX05PVF9GT1VORCAqL106IFwidXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL1xufTtcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IGFwaVJlcXVlc3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IG9wZXJhdGlvbjogJ1JFQVVUSCcgfSk7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSwgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQaG9uZUF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLywgXCJwaG9uZVwiIC8qIFNpZ25Jbk1ldGhvZC5QSE9ORSAqLyk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVG9rZW5SZXNwb25zZShwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGxpbmtXaXRoUGhvbmVOdW1iZXIkMShhdXRoLCBPYmplY3QuYXNzaWduKHsgaWRUb2tlbiB9LCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyLCB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIGlmICh0ZW1wb3JhcnlQcm9vZiAmJiBwaG9uZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcbiAgICAgICAgICAgIGNvZGU6IHZlcmlmaWNhdGlvbkNvZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XG4gICAgICAgICAgICBvYmoucGhvbmVOdW1iZXIgPSB0aGlzLnBhcmFtcy5waG9uZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgICAgIG9iai50ZW1wb3JhcnlQcm9vZiA9IHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uQ29kZSA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbkNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uSWQgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIGEgcGhvbmUgY3JlZGVudGlhbCBiYXNlZCBvbiBhIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nLiAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUsIHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9ID0ganNvbjtcbiAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25Db2RlICYmXG4gICAgICAgICAgICAhdmVyaWZpY2F0aW9uSWQgJiZcbiAgICAgICAgICAgICFwaG9uZU51bWJlciAmJlxuICAgICAgICAgICAgIXRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoe1xuICAgICAgICAgICAgdmVyaWZpY2F0aW9uSWQsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25Db2RlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB0ZW1wb3JhcnlQcm9vZlxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1hcHMgdGhlIG1vZGUgc3RyaW5nIGluIGFjdGlvbiBjb2RlIFVSTCB0byBBY3Rpb24gQ29kZSBJbmZvIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbW9kZVxuICovXG5mdW5jdGlvbiBwYXJzZU1vZGUobW9kZSkge1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdyZWNvdmVyRW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVDT1ZFUl9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmVzZXRQYXNzd29yZCc6XG4gICAgICAgICAgICByZXR1cm4gXCJQQVNTV09SRF9SRVNFVFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQgKi87XG4gICAgICAgIGNhc2UgJ3NpZ25Jbic6XG4gICAgICAgICAgICByZXR1cm4gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcbiAgICAgICAgY2FzZSAndmVyaWZ5RW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi87XG4gICAgICAgIGNhc2UgJ3ZlcmlmeUFuZENoYW5nZUVtYWlsJzpcbiAgICAgICAgICAgIHJldHVybiBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT05cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2UgRkRMIGxpbmtzXG4gKlxuICogQHBhcmFtIHVybFxuICovXG5mdW5jdGlvbiBwYXJzZURlZXBMaW5rKHVybCkge1xuICAgIGNvbnN0IGxpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2xpbmsnXTtcbiAgICAvLyBEb3VibGUgbGluayBjYXNlIChhdXRvbWF0aWMgcmVkaXJlY3QpLlxuICAgIGNvbnN0IGRvdWJsZURlZXBMaW5rID0gbGlua1xuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhsaW5rKSlbJ2RlZXBfbGlua19pZCddXG4gICAgICAgIDogbnVsbDtcbiAgICAvLyBpT1MgY3VzdG9tIHNjaGVtZSBsaW5rcy5cbiAgICBjb25zdCBpT1NEZWVwTGluayA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpKVsnZGVlcF9saW5rX2lkJ107XG4gICAgY29uc3QgaU9TRG91YmxlRGVlcExpbmsgPSBpT1NEZWVwTGlua1xuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhpT1NEZWVwTGluaykpWydsaW5rJ11cbiAgICAgICAgOiBudWxsO1xuICAgIHJldHVybiBpT1NEb3VibGVEZWVwTGluayB8fCBpT1NEZWVwTGluayB8fCBkb3VibGVEZWVwTGluayB8fCBsaW5rIHx8IHVybDtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIHBhcnNlIGVtYWlsIGFjdGlvbiBVUkxzIHN1Y2ggYXMgcGFzc3dvcmQgcmVzZXQsIGVtYWlsIHZlcmlmaWNhdGlvbixcbiAqIGVtYWlsIGxpbmsgc2lnbiBpbiwgZXRjLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQWN0aW9uQ29kZVVSTCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjdGlvbkxpbmsgLSBUaGUgbGluayBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9uTGluaykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGFjdGlvbkxpbmspKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKF9hID0gc2VhcmNoUGFyYW1zW1wiYXBpS2V5XCIgLyogUXVlcnlGaWVsZC5BUElfS0VZICovXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgY29uc3QgY29kZSA9IChfYiA9IHNlYXJjaFBhcmFtc1tcIm9vYkNvZGVcIiAvKiBRdWVyeUZpZWxkLkNPREUgKi9dKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJzZU1vZGUoKF9jID0gc2VhcmNoUGFyYW1zW1wibW9kZVwiIC8qIFF1ZXJ5RmllbGQuTU9ERSAqL10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBBUEkga2V5LCBjb2RlIGFuZCBtb2RlLlxuICAgICAgICBfYXNzZXJ0KGFwaUtleSAmJiBjb2RlICYmIG9wZXJhdGlvbiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuY29udGludWVVcmwgPSAoX2QgPSBzZWFyY2hQYXJhbXNbXCJjb250aW51ZVVybFwiIC8qIFF1ZXJ5RmllbGQuQ09OVElOVUVfVVJMICovXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSAoX2UgPSBzZWFyY2hQYXJhbXNbXCJsYW5nXCIgLyogUXVlcnlGaWVsZC5MQU5HVUFHRV9DT0RFICovXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IChfZiA9IHNlYXJjaFBhcmFtc1tcInRlbmFudElkXCIgLyogUXVlcnlGaWVsZC5URU5BTlRfSUQgKi9dKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWYgdGhlIGxpbmsgaXMgdmFsaWQsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5rICAtIFRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcuXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VMaW5rKGxpbmspIHtcbiAgICAgICAgY29uc3QgYWN0aW9uTGluayA9IHBhcnNlRGVlcExpbmsobGluayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbkNvZGVVUkwoYWN0aW9uTGluayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmXG4gKiB0aGUgbGluayBpcyB2YWxpZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQWN0aW9uQ29kZVVSTChsaW5rKSB7XG4gICAgcmV0dXJuIEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGxpbmspO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyB7QGxpbmsgRW1haWxBdXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFbWFpbEF1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRCwgZXZlbiBmb3IgZW1haWwgbGluay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IEVtYWlsQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGF1dGgsIGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFVzZXIgYWNjb3VudCBwYXNzd29yZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IHVzaW5nIGFuIGVtYWlsIGFuZCBhbiBlbWFpbCBsaW5rIGFmdGVyIGEgc2lnbiBpbiB3aXRoXG4gICAgICogZW1haWwgbGluayBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCk7XG4gICAgICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHVzZXIuXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIHVzZWQgdG8gdmVyaWZ5IHRoZSBsaW5rLlxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsTGluayAtIFNpZ24taW4gZW1haWwgbGluay5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxXaXRoTGluayhlbWFpbCwgZW1haWxMaW5rKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbkNvZGVVcmwgPSBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhlbWFpbExpbmspO1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVVcmwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIEVtYWlsQXV0aENyZWRlbnRpYWwuX2Zyb21FbWFpbEFuZENvZGUoZW1haWwsIGFjdGlvbkNvZGVVcmwuY29kZSwgYWN0aW9uQ29kZVVybC50ZW5hbnRJZCk7XG4gICAgfVxufVxuLyoqXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRCwgZXZlbiBmb3IgZW1haWwgbGluay5cbiAqL1xuRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLztcbi8qKlxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRC5cbiAqL1xuRW1haWxBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfU0lHTl9JTl9NRVRIT0QgPSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovO1xuLyoqXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXG4gKi9cbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX0xJTktfU0lHTl9JTl9NRVRIT0QgPSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIEZlZGVyYXRlZCBwcm92aWRlcnMgKE9BdXRoIChpbmNsdWRpbmcgT0lEQyksIFNBTUwpLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGdlbmVyaWMgT0F1dGggcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBQcm92aWRlciBmb3Igd2hpY2ggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0TGFuZ3VhZ2VDb2RlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYW5ndWFnZSBnb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIGxhbmd1YWdlIGNvZGVcbiAgICAgKi9cbiAgICBzZXREZWZhdWx0TGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgT0F1dGggY3VzdG9tIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiBhbiBPQXV0aCByZXF1ZXN0IGZvciBwb3B1cCBhbmQgcmVkaXJlY3Qgc2lnbi1pblxuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBhIGRldGFpbGVkIGxpc3QsIGNoZWNrIHRoZSByZXNlcnZlZCByZXF1aXJlZCBPQXV0aCAyLjAgcGFyYW1ldGVycyBzdWNoIGFzIGBjbGllbnRfaWRgLFxuICAgICAqIGByZWRpcmVjdF91cmlgLCBgc2NvcGVgLCBgcmVzcG9uc2VfdHlwZWAsIGFuZCBgc3RhdGVgIGFyZSBub3QgYWxsb3dlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1c3RvbU9BdXRoUGFyYW1ldGVycyAtIFRoZSBjdXN0b20gT0F1dGggcGFyYW1ldGVycyB0byBwYXNzIGluIHRoZSBPQXV0aCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNldEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tT0F1dGhQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IGN1c3RvbU9BdXRoUGFyYW1ldGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEN1c3RvbVBhcmFtZXRlcnN9LlxuICAgICAqL1xuICAgIGdldEN1c3RvbVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVBhcmFtZXRlcnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21tb24gY29kZSB0byBhbGwgT0F1dGggcHJvdmlkZXJzLiBUaGlzIGlzIHNlcGFyYXRlIGZyb20gdGhlXG4gKiB7QGxpbmsgT0F1dGhQcm92aWRlcn0gc28gdGhhdCBjaGlsZCBwcm92aWRlcnMgKGxpa2VcbiAqIHtAbGluayBHb29nbGVBdXRoUHJvdmlkZXJ9KSBkb24ndCBpbmhlcml0IHRoZSBgY3JlZGVudGlhbGAgaW5zdGFuY2UgbWV0aG9kLlxuICogSW5zdGVhZCwgdGhleSByZWx5IG9uIGEgc3RhdGljIGBjcmVkZW50aWFsYCBtZXRob2QuXG4gKi9cbmNsYXNzIEJhc2VPQXV0aFByb3ZpZGVyIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gT0F1dGggc2NvcGUgdG8gdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGUgLSBQcm92aWRlciBPQXV0aCBzY29wZSB0byBhZGQuXG4gICAgICovXG4gICAgYWRkU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgLy8gSWYgbm90IGFscmVhZHkgYWRkZWQsIGFkZCBzY29wZSB0byBsaXN0LlxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2YgT0F1dGggc2NvcGVzLlxuICAgICAqL1xuICAgIGdldFNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNjb3Blc107XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBnZW5lcmljIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE9BdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBfYXNzZXJ0KCdwcm92aWRlcklkJyBpbiBvYmogJiYgJ3NpZ25Jbk1ldGhvZCcgaW4gb2JqLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMob2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBnZW5lcmljIE9BdXRoIHByb3ZpZGVyJ3MgYWNjZXNzIHRva2VuIG9yIElEIHRva2VuLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgcmF3IG5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mXG4gICAgICogdGhlIHJhdyBub25jZSBtdXN0IG1hdGNoIHRoZSBub25jZSBmaWVsZCBpbiB0aGUgSUQgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBgZ29vZ2xlVXNlcmAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBnZW5lcmF0ZSBPQXV0aCBwcm92aWRlciB3aXRoIGEgYGdvb2dsZS5jb21gIHByb3ZpZGVySWQuXG4gICAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsKHtcbiAgICAgKiAgIGlkVG9rZW46IGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4sXG4gICAgICogfSk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gRWl0aGVyIHRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBJRCB0b2tlbiwgYWNjZXNzIHRva2VuIGFuZCByYXcgbm9uY2VcbiAgICAgKiBvciB0aGUgSUQgdG9rZW4gc3RyaW5nLlxuICAgICAqL1xuICAgIGNyZWRlbnRpYWwocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBub25jZTogcGFyYW1zLnJhd05vbmNlIH0pKTtcbiAgICB9XG4gICAgLyoqIEFuIGludGVybmFsIGNyZWRlbnRpYWwgbWV0aG9kIHRoYXQgYWNjZXB0cyBtb3JlIHBlcm1pc3NpdmUgb3B0aW9ucyAqL1xuICAgIF9jcmVkZW50aWFsKHBhcmFtcykge1xuICAgICAgICBfYXNzZXJ0KHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICAvLyBGb3IgT0F1dGhDcmVkZW50aWFsLCBzaWduIGluIG1ldGhvZCBpcyBzYW1lIGFzIHByb3ZpZGVySWQuXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kOiB0aGlzLnByb3ZpZGVySWQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBvYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0LCBwZW5kaW5nVG9rZW4sIG5vbmNlLCBwcm92aWRlcklkIH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIW9hdXRoQWNjZXNzVG9rZW4gJiZcbiAgICAgICAgICAgICFvYXV0aFRva2VuU2VjcmV0ICYmXG4gICAgICAgICAgICAhb2F1dGhJZFRva2VuICYmXG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoUHJvdmlkZXIocHJvdmlkZXJJZCkuX2NyZWRlbnRpYWwoe1xuICAgICAgICAgICAgICAgIGlkVG9rZW46IG9hdXRoSWRUb2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogb2F1dGhBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBwZW5kaW5nVG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBGYWNlYm9vay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIGBldmVudGAgZnJvbSB0aGUgRmFjZWJvb2sgYXV0aC5hdXRoUmVzcG9uc2VDaGFuZ2UgY2FsbGJhY2suXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZXZlbnQuYXV0aFJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbChhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBGYWNlYm9va0F1dGhQcm92aWRlci5GQUNFQk9PS19TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5GQUNFQk9PSy4gKi9cbkZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9EID0gXCJmYWNlYm9vay5jb21cIiAvKiBTaWduSW5NZXRob2QuRkFDRUJPT0sgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suICovXG5GYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHb29nbGUgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHb29nbGVBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovKTtcbiAgICAgICAgdGhpcy5hZGRTY29wZSgncHJvZmlsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR29vZ2xlLiBBdCBsZWFzdCBvbmUgb2YgSUQgdG9rZW4gYW5kIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIFxcYGdvb2dsZVVzZXJcXGAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZFRva2VuIC0gR29vZ2xlIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoaWRUb2tlbiwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuIH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIW9hdXRoSWRUb2tlbiAmJiAhb2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBvYXV0aCAxIGNyZWRlbnRpYWwgb3IgYSBwaG9uZSBjcmVkZW50aWFsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkdPT0dMRS4gKi9cbkdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QgPSBcImdvb2dsZS5jb21cIiAvKiBTaWduSW5NZXRob2QuR09PR0xFICovO1xuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS4gKi9cbkdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi5cbiAqXG4gKiBAcmVtYXJrc1xuICogR2l0SHViIHJlcXVpcmVzIGFuIE9BdXRoIDIuMCByZWRpcmVjdCwgc28geW91IGNhbiBlaXRoZXIgaGFuZGxlIHRoZSByZWRpcmVjdCBkaXJlY3RseSwgb3IgdXNlXG4gKiB0aGUge0BsaW5rIHNpZ25JbldpdGhQb3B1cH0gaGFuZGxlcjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0SHViIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0SHViIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdpdEh1Yi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdpdEh1YiBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR0lUSFVCLiAqL1xuR2l0aHViQXV0aFByb3ZpZGVyLkdJVEhVQl9TSUdOX0lOX01FVEhPRCA9IFwiZ2l0aHViLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5HSVRIVUIgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLiAqL1xuR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU0FNTEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXJJZCwgcHJvdmlkZXJJZCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1Rva2VuID0gcGVuZGluZ1Rva2VuO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kLCBwZW5kaW5nVG9rZW4gfSA9IG9iajtcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8XG4gICAgICAgICAgICAhc2lnbkluTWV0aG9kIHx8XG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuIHx8XG4gICAgICAgICAgICBwcm92aWRlcklkICE9PSBzaWduSW5NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBzdGF0aWMgbWV0aG9kIHRvIGF2b2lkIGV4cG9zaW5nIHRoZSBjb25zdHJ1Y3RvciB0byBlbmQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTQU1MQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJLFxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgU0FNTF9QUk9WSURFUl9QUkVGSVggPSAnc2FtbC4nO1xuLyoqXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBmb3IgU0FNTC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFNBTUxBdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLiBUaGUgcHJvdmlkZXJJZCBtdXN0IHN0YXJ0IHdpdGggXCJzYW1sLlwiXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBTQU1MIHByb3ZpZGVyIElELlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQpIHtcbiAgICAgICAgX2Fzc2VydChwcm92aWRlcklkLnN0YXJ0c1dpdGgoU0FNTF9QUk9WSURFUl9QUkVGSVgpLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfSBhZnRlciBhXG4gICAgICogc3VjY2Vzc2Z1bCBTQU1MIGZsb3cgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgeW91IGNvdWxkIHdyaXRlIHRoZVxuICAgICAqIGZvbGxvd2luZyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBzYW1sUHJvdmlkZXIpO1xuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNBTUxBdXRoUHJvdmlkZXIuc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aENyZWRlbnRpYWwuZnJvbUpTT04oanNvbik7XG4gICAgICAgIF9hc3NlcnQoY3JlZGVudGlhbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG4gICAgc3RhdGljIHNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBlbmRpbmdUb2tlbiwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFwZW5kaW5nVG9rZW4gfHwgIXByb3ZpZGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU0FNTEF1dGhDcmVkZW50aWFsLl9jcmVhdGUocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgVHdpdHRlckF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogICBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxuICogY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUd2l0dGVyQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIFR3aXR0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUd2l0dGVyIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gc2VjcmV0IC0gVHdpdHRlciBzZWNyZXQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwodG9rZW4sIHNlY3JldCkge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIG9hdXRoVG9rZW46IHRva2VuLFxuICAgICAgICAgICAgb2F1dGhUb2tlblNlY3JldDogc2VjcmV0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuIHx8ICFvYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uVFdJVFRFUi4gKi9cblR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCA9IFwidHdpdHRlci5jb21cIiAvKiBTaWduSW5NZXRob2QuVFdJVFRFUiAqLztcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5UV0lUVEVSLiAqL1xuVHdpdHRlckF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduVXAoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduVXBcIiAvKiBFbmRwb2ludC5TSUdOX1VQICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgVXNlckNyZWRlbnRpYWxJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy51c2VyID0gcGFyYW1zLnVzZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xuICAgICAgICB0aGlzLl90b2tlblJlc3BvbnNlID0gcGFyYW1zLl90b2tlblJlc3BvbnNlO1xuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBwYXJhbXMub3BlcmF0aW9uVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIF9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIG9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlckltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgdXNlckNyZWQgPSBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IGlkVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VyQ3JlZDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIF9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJJZCA9IHByb3ZpZGVySWRGb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UucHJvdmlkZXJJZCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucHJvdmlkZXJJZDtcbiAgICB9XG4gICAgaWYgKCdwaG9uZU51bWJlcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIFwicGhvbmVcIiAvKiBQcm92aWRlcklkLlBIT05FICovO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gYXMgYW4gYW5vbnltb3VzIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYW5vbnltb3VzIHVzZXIgc2lnbmVkIGluLCB0aGF0IHVzZXIgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhXG4gKiBuZXcgYW5vbnltb3VzIHVzZXIgaWRlbnRpdHkgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5Bbm9ueW1vdXNseShhdXRoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIGlmICgoX2EgPSBhdXRoSW50ZXJuYWwuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykge1xuICAgICAgICAvLyBJZiBhbiBhbm9ueW1vdXMgdXNlciBpcyBhbHJlYWR5IHNpZ25lZCBpbiwgbm8gbmVlZCB0byBzaWduIHRoZW0gaW4gYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXI6IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcixcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqL1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduVXAoYXV0aEludGVybmFsLCB7XG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UsIHRydWUpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IG9wZXJhdGlvblR5cGU7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNdWx0aUZhY3RvckVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IHtcbiAgICAgICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZSxcbiAgICAgICAgICAgIHRlbmFudElkOiAoX2EgPSBhdXRoLnRlbmFudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc2VydmVyUmVzcG9uc2U6IGVycm9yLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21FcnJvckFuZE9wZXJhdGlvbihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yRXJyb3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XG4gICAgY29uc3QgaWRUb2tlblByb3ZpZGVyID0gb3BlcmF0aW9uVHlwZSA9PT0gXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi9cbiAgICAgICAgPyBjcmVkZW50aWFsLl9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aClcbiAgICAgICAgOiBjcmVkZW50aWFsLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XG4gICAgcmV0dXJuIGlkVG9rZW5Qcm92aWRlci5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCAqL31gKSB7XG4gICAgICAgICAgICB0aHJvdyBNdWx0aUZhY3RvckVycm9yLl9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiBVc2VySW5mbyBwcm92aWRlciBkYXRhIGFuZCBjb252ZXJ0cyBpdCB0byBhIHNldCBvZiBuYW1lc1xuICovXG5mdW5jdGlvbiBwcm92aWRlckRhdGFBc05hbWVzKHByb3ZpZGVyRGF0YSkge1xuICAgIHJldHVybiBuZXcgU2V0KHByb3ZpZGVyRGF0YVxuICAgICAgICAubWFwKCh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZClcbiAgICAgICAgLmZpbHRlcihwaWQgPT4gISFwaWQpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVW5saW5rcyBhIHByb3ZpZGVyIGZyb20gYSB1c2VyIGFjY291bnQuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm92aWRlcklkIC0gVGhlIHByb3ZpZGVyIHRvIHVubGluay5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVubGluayh1c2VyLCBwcm92aWRlcklkKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXModHJ1ZSwgdXNlckludGVybmFsLCBwcm92aWRlcklkKTtcbiAgICBjb25zdCB7IHByb3ZpZGVyVXNlckluZm8gfSA9IGF3YWl0IGRlbGV0ZUxpbmtlZEFjY291bnRzKHVzZXJJbnRlcm5hbC5hdXRoLCB7XG4gICAgICAgIGlkVG9rZW46IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCksXG4gICAgICAgIGRlbGV0ZVByb3ZpZGVyOiBbcHJvdmlkZXJJZF1cbiAgICB9KTtcbiAgICBjb25zdCBwcm92aWRlcnNMZWZ0ID0gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlclVzZXJJbmZvIHx8IFtdKTtcbiAgICB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maWx0ZXIocGQgPT4gcHJvdmlkZXJzTGVmdC5oYXMocGQucHJvdmlkZXJJZCkpO1xuICAgIGlmICghcHJvdmlkZXJzTGVmdC5oYXMoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8pKSB7XG4gICAgICAgIHVzZXJJbnRlcm5hbC5waG9uZU51bWJlciA9IG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHJldHVybiB1c2VySW50ZXJuYWw7XG59XG5hc3luYyBmdW5jdGlvbiBfbGluayh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgY3JlZGVudGlhbC5fbGlua1RvSWRUb2tlbih1c2VyLmF1dGgsIGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpKSwgYnlwYXNzQXV0aFN0YXRlKTtcbiAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgXCJsaW5rXCIgLyogT3BlcmF0aW9uVHlwZS5MSU5LICovLCByZXNwb25zZSk7XG59XG5hc3luYyBmdW5jdGlvbiBfYXNzZXJ0TGlua2VkU3RhdHVzKGV4cGVjdGVkLCB1c2VyLCBwcm92aWRlcikge1xuICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XG4gICAgY29uc3QgY29kZSA9IGV4cGVjdGVkID09PSBmYWxzZVxuICAgICAgICA/IFwicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBST1ZJREVSX0FMUkVBRFlfTElOS0VEICovXG4gICAgICAgIDogXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovO1xuICAgIF9hc3NlcnQocHJvdmlkZXJJZHMuaGFzKHByb3ZpZGVyKSA9PT0gZXhwZWN0ZWQsIHVzZXIuYXV0aCwgY29kZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi87XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCwgdXNlciksIGJ5cGFzc0F1dGhTdGF0ZSk7XG4gICAgICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VUb2tlbihyZXNwb25zZS5pZFRva2VuKTtcbiAgICAgICAgX2Fzc2VydChwYXJzZWQsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgeyBzdWI6IGxvY2FsSWQgfSA9IHBhcnNlZDtcbiAgICAgICAgX2Fzc2VydCh1c2VyLnVpZCA9PT0gbG9jYWxJZCwgYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcbiAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29udmVydCB1c2VyIGRlbGV0ZWQgZXJyb3IgaW50byB1c2VyIG1pc21hdGNoXG4gICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpID09PSBgYXV0aC8ke1widXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL31gKSB7XG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3NpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi87XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCk7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpO1xuICAgIGlmICghYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIF9zaWduSW5XaXRoQ3JlZGVudGlhbChfY2FzdEF1dGgoYXV0aCksIGNyZWRlbnRpYWwpO1xufVxuLyoqXG4gKiBMaW5rcyB0aGUgdXNlciBhY2NvdW50IHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyhmYWxzZSwgdXNlckludGVybmFsLCBjcmVkZW50aWFsLnByb3ZpZGVySWQpO1xuICAgIHJldHVybiBfbGluayh1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xufVxuLyoqXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIGNyZWRlbnRpYWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluXG4gKiBhdHRlbXB0cy4gVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVjb3ZlciBmcm9tIGEgYENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTmAgZXJyb3JcbiAqIG9yIGEgYFRPS0VOX0VYUElSRURgIGVycm9yLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24gYW55IHtAbGluayBVc2VyfSBzaWduZWQgaW4gYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlc1xuICogY3JlYXRlZCB3aXRoIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gX3JlYXV0aGVudGljYXRlKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgY3JlZGVudGlhbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhDdXN0b21Ub2tlblwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9DVVNUT01fVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgY3VzdG9tIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBDdXN0b20gdG9rZW5zIGFyZSB1c2VkIHRvIGludGVncmF0ZSBGaXJlYmFzZSBBdXRoIHdpdGggZXhpc3RpbmcgYXV0aCBzeXN0ZW1zLCBhbmQgbXVzdFxuICogYmUgZ2VuZXJhdGVkIGJ5IGFuIGF1dGggYmFja2VuZCB1c2luZyB0aGVcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cbiAqIG1ldGhvZCBpbiB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvYWRtaW4gfCBBZG1pbiBTREt9IC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihhdXRoLCBjdXN0b21Ub2tlbikge1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnbkluV2l0aEN1c3RvbVRva2VuJDEoYXV0aEludGVybmFsLCB7XG4gICAgICAgIHRva2VuOiBjdXN0b21Ub2tlbixcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBjcmVkID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGhJbnRlcm5hbCwgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi8sIHJlc3BvbnNlKTtcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKGNyZWQudXNlcik7XG4gICAgcmV0dXJuIGNyZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCwgcmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xuICAgICAgICB0aGlzLnVpZCA9IHJlc3BvbnNlLm1mYUVucm9sbG1lbnRJZDtcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50VGltZSA9IG5ldyBEYXRlKHJlc3BvbnNlLmVucm9sbGVkQXQpLnRvVVRDU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkge1xuICAgICAgICBpZiAoJ3Bob25lSW5mbycgaW4gZW5yb2xsbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCd0b3RwSW5mbycgaW4gZW5yb2xsbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICB9XG59XG5jbGFzcyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihcInBob25lXCIgLyogRmFjdG9ySWQuUEhPTkUgKi8sIHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lSW5mbztcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XG4gICAgfVxufVxuY2xhc3MgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKF9hdXRoLCBlbnJvbGxtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgX2Fzc2VydCgoKF9hID0gYWN0aW9uQ29kZVNldHRpbmdzLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwLCBhdXRoLCBcImludmFsaWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSSAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4ubGVuZ3RoID4gMCwgYXV0aCwgXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgYWN0aW9uQ29kZVNldHRpbmdzLmxpbmtEb21haW4gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5saW5rRG9tYWluLmxlbmd0aCA+IDAsIGF1dGgsIFwiaW52YWxpZC1ob3N0aW5nLWxpbmstZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0hPU1RJTkdfTElOS19ET01BSU4gKi8pO1xuICAgIHJlcXVlc3QuY29udGludWVVcmwgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsO1xuICAgIHJlcXVlc3QuZHluYW1pY0xpbmtEb21haW4gPSBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW47XG4gICAgcmVxdWVzdC5saW5rRG9tYWluID0gYWN0aW9uQ29kZVNldHRpbmdzLmxpbmtEb21haW47XG4gICAgcmVxdWVzdC5jYW5IYW5kbGVDb2RlSW5BcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwO1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TKSB7XG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmlPUy5idW5kbGVJZC5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovKTtcbiAgICAgICAgcmVxdWVzdC5pT1NCdW5kbGVJZCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MuYnVuZGxlSWQ7XG4gICAgfVxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZCkge1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLnBhY2thZ2VOYW1lLmxlbmd0aCA+IDAsIGF1dGgsIFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovKTtcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkSW5zdGFsbEFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLmluc3RhbGxBcHA7XG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZE1pbmltdW1WZXJzaW9uQ29kZSA9XG4gICAgICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5taW5pbXVtVmVyc2lvbjtcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkUGFja2FnZU5hbWUgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBhc3N3b3JkIHBvbGljeSBjYWNoZWQgaW4gdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSBpZiBhIHBvbGljeSBpcyBhbHJlYWR5XG4gKiBjYWNoZWQgZm9yIHRoZSBwcm9qZWN0IG9yIHRlbmFudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2Ugb25seSBmZXRjaCB0aGUgcGFzc3dvcmQgcG9saWN5IGlmIHRoZSBwYXNzd29yZCBkaWQgbm90IG1lZXQgcG9saWN5IHJlcXVpcmVtZW50cyBhbmRcbiAqIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHBvbGljeSBjYWNoZWQuIEEgZGV2ZWxvcGVyIG11c3QgY2FsbCB2YWxpZGF0ZVBhc3N3b3JkIGF0IGxlYXN0XG4gKiBvbmNlIGZvciB0aGUgY2FjaGUgdG8gYmUgYXV0b21hdGljYWxseSB1cGRhdGVkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBpZiAoYXV0aEludGVybmFsLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcbiAgICAgICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVQYXNzd29yZFBvbGljeSgpO1xuICAgIH1cbn1cbi8qKlxuICogU2VuZHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlblxuICogdGhlcmUncyBubyB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcyBhbmRcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cbiAqIGlzIGVuYWJsZWQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRvIGNvbXBsZXRlIHRoZSBwYXNzd29yZCByZXNldCwgY2FsbCB7QGxpbmsgY29uZmlybVBhc3N3b3JkUmVzZXR9IHdpdGggdGhlIGNvZGUgc3VwcGxpZWQgaW5cbiAqIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLCBhbG9uZyB3aXRoIHRoZSBuZXcgcGFzc3dvcmQgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRQYXNzd29yZFJlc2V0RW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB1c2VyLlxuICogYXdhaXQgY29uZmlybVBhc3N3b3JkUmVzZXQoJ3VzZXJAZXhhbXBsZS5jb20nLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgIH07XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICB9XG4gICAgYXdhaXQgaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovLCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xufVxuLyoqXG4gKiBDb21wbGV0ZXMgdGhlIHBhc3N3b3JkIHJlc2V0IHByb2Nlc3MsIGdpdmVuIGEgY29uZmlybWF0aW9uIGNvZGUgYW5kIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgY29uZmlybWF0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBjb25maXJtUGFzc3dvcmRSZXNldChhdXRoLCBvb2JDb2RlLCBuZXdQYXNzd29yZCkge1xuICAgIGF3YWl0IHJlc2V0UGFzc3dvcmQoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCB7XG4gICAgICAgIG9vYkNvZGUsXG4gICAgICAgIG5ld1Bhc3N3b3JkXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT1cbiAgICAgICAgICAgIGBhdXRoLyR7XCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi99YCkge1xuICAgICAgICAgICAgdm9pZCByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgLy8gRG8gbm90IHJldHVybiB0aGUgZW1haWwuXG59XG4vKipcbiAqIEFwcGxpZXMgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XG4gICAgYXdhaXQgYXBwbHlBY3Rpb25Db2RlJDEoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCB7IG9vYkNvZGUgfSk7XG59XG4vKipcbiAqIENoZWNrcyBhIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEByZXR1cm5zIG1ldGFkYXRhIGFib3V0IHRoZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tBY3Rpb25Db2RlKGF1dGgsIG9vYkNvZGUpIHtcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc2V0UGFzc3dvcmQoYXV0aE1vZHVsYXIsIHsgb29iQ29kZSB9KTtcbiAgICAvLyBFbWFpbCBjb3VsZCBiZSBlbXB0eSBvbmx5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXMgRU1BSUxfU0lHTklOIG9yXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXG4gICAgLy8gTmV3IGVtYWlsIHNob3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xuICAgIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxuICAgIC8vIE11bHRpLWZhY3RvciBpbmZvIGNvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXG4gICAgLy8gUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04uXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gcmVzcG9uc2UucmVxdWVzdFR5cGU7XG4gICAgX2Fzc2VydChvcGVyYXRpb24sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi86XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLm5ld0VtYWlsLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04gKi86XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLm1mYUluZm8sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5lbWFpbCwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICB9XG4gICAgLy8gVGhlIG11bHRpLWZhY3RvciBpbmZvIGZvciByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvblxuICAgIGxldCBtdWx0aUZhY3RvckluZm8gPSBudWxsO1xuICAgIGlmIChyZXNwb25zZS5tZmFJbmZvKSB7XG4gICAgICAgIG11bHRpRmFjdG9ySW5mbyA9IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShfY2FzdEF1dGgoYXV0aE1vZHVsYXIpLCByZXNwb25zZS5tZmFJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW1haWw6IChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi9cbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLm5ld0VtYWlsXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5lbWFpbCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzRW1haWw6IChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi9cbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVtYWlsXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5uZXdFbWFpbCkgfHwgbnVsbCxcbiAgICAgICAgICAgIG11bHRpRmFjdG9ySW5mb1xuICAgICAgICB9LFxuICAgICAgICBvcGVyYXRpb25cbiAgICB9O1xufVxuLyoqXG4gKiBDaGVja3MgYSBwYXNzd29yZCByZXNldCBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEByZXR1cm5zIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpZiB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlKGF1dGgsIGNvZGUpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNoZWNrQWN0aW9uQ29kZShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIGNvZGUpO1xuICAgIC8vIEVtYWlsIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBzaW5jZSBhIGNvZGUgd2FzIHNlbnQgdG8gaXRcbiAgICByZXR1cm4gZGF0YS5lbWFpbDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB1c2VyIGFjY291bnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwgYWRkcmVzcyBhbmQgcGFzc3dvcmQuXG4gKlxuICogQHJlbWFya3NcbiAqIE9uIHN1Y2Nlc3NmdWwgY3JlYXRpb24gb2YgdGhlIHVzZXIgYWNjb3VudCwgdGhpcyB1c2VyIHdpbGwgYWxzbyBiZSBzaWduZWQgaW4gdG8geW91ciBhcHBsaWNhdGlvbi5cbiAqXG4gKiBVc2VyIGFjY291bnQgY3JlYXRpb24gY2FuIGZhaWwgaWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMgb3IgdGhlIHBhc3N3b3JkIGlzIGludmFsaWQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogTm90ZTogVGhlIGVtYWlsIGFkZHJlc3MgYWN0cyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciBhbmQgZW5hYmxlcyBhbiBlbWFpbC1iYXNlZFxuICogcGFzc3dvcmQgcmVzZXQuIFRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgdXNlciBhY2NvdW50IGFuZCBzZXQgdGhlIGluaXRpYWwgdXNlciBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgdXNlcidzIGNob3NlbiBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgfTtcbiAgICBjb25zdCBzaWduVXBSZXNwb25zZSA9IGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEludGVybmFsLCByZXF1ZXN0LCBcInNpZ25VcFBhc3N3b3JkXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX1VQX1BBU1NXT1JEICovLCBzaWduVXAsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnblVwUmVzcG9uc2UuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGFuIGVtYWlsIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBhbmQgcGFzc3dvcmQgZG8gbm90IG1hdGNoLiBXaGVuXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLCB0aGlzIG1ldGhvZCBmYWlscyB3aXRoIFwiYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWxcIiBpbiBjYXNlIG9mIGFuIGludmFsaWRcbiAqIGVtYWlsL3Bhc3N3b3JkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24ge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIE5vdGU6IFRoZSB1c2VyJ3MgcGFzc3dvcmQgaXMgTk9UIHRoZSBwYXNzd29yZCB1c2VkIHRvIGFjY2VzcyB0aGUgdXNlcidzIGVtYWlsIGFjY291bnQuIFRoZVxuICogZW1haWwgYWRkcmVzcyBzZXJ2ZXMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIsIGFuZCB0aGUgcGFzc3dvcmQgaXMgdXNlZCB0byBhY2Nlc3NcbiAqIHRoZSB1c2VyJ3MgYWNjb3VudCBpbiB5b3VyIEZpcmViYXNlIHByb2plY3QuIFNlZSBhbHNvOiB7QGxpbmsgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkfS5cbiAqXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXJzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgdXNlcnMgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduSW5XaXRoQ3JlZGVudGlhbChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZW5kcyBhIHNpZ24taW4gZW1haWwgbGluayB0byB0aGUgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBzaWduLWluIG9wZXJhdGlvbiBoYXMgdG8gYWx3YXlzIGJlIGNvbXBsZXRlZCBpbiB0aGUgYXBwIHVubGlrZSBvdGhlciBvdXQgb2YgYmFuZCBlbWFpbFxuICogYWN0aW9ucyAocGFzc3dvcmQgcmVzZXQgYW5kIGVtYWlsIHZlcmlmaWNhdGlvbnMpLiBUaGlzIGlzIGJlY2F1c2UsIGF0IHRoZSBlbmQgb2YgdGhlIGZsb3csXG4gKiB0aGUgdXNlciBpcyBleHBlY3RlZCB0byBiZSBzaWduZWQgaW4gYW5kIHRoZWlyIEF1dGggc3RhdGUgcGVyc2lzdGVkIHdpdGhpbiB0aGUgYXBwLlxuICpcbiAqIFRvIGNvbXBsZXRlIHNpZ24gaW4gd2l0aCB0aGUgZW1haWwgbGluaywgY2FsbCB7QGxpbmsgc2lnbkluV2l0aEVtYWlsTGlua30gd2l0aCB0aGUgZW1haWxcbiAqIGFkZHJlc3MgYW5kIHRoZSBlbWFpbCBsaW5rIHN1cHBsaWVkIGluIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoSW50ZXJuYWwgLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHAsIGF1dGhJbnRlcm5hbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBY3Rpb25Db2RlU2V0dGluZ3MocmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGluY29taW5nIGxpbmsgaXMgYSBzaWduLWluIHdpdGggZW1haWwgbGluayBzdWl0YWJsZSBmb3Ige0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspIHtcbiAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcbiAgICByZXR1cm4gKGFjdGlvbkNvZGVVcmwgPT09IG51bGwgfHwgYWN0aW9uQ29kZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uQ29kZVVybC5vcGVyYXRpb24pID09PSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgc2lnbi1pbiBlbWFpbCBsaW5rLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBubyBsaW5rIGlzIHBhc3NlZCwgdGhlIGxpbmsgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY3VycmVudCBVUkwuXG4gKlxuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkIG9yIE9UUCBpbiBlbWFpbCBsaW5rIGV4cGlyZXMuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogTm90ZTogQ29uZmlybSB0aGUgbGluayBpcyBhIHNpZ24taW4gZW1haWwgbGluayBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCBmaXJlYmFzZS5hdXRoLkF1dGguaXNTaWduSW5XaXRoRW1haWxMaW5rLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspIHtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoZW1haWwsIGVtYWlsTGluayB8fCBfZ2V0Q3VycmVudFVybCgpKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgdGVuYW50IElEIGluIHRoZSBlbWFpbCBsaW5rIG1hdGNoZXMgdGhlIHRlbmFudCBJRCBvbiBBdXRoXG4gICAgLy8gaW5zdGFuY2UuXG4gICAgX2Fzc2VydChjcmVkZW50aWFsLl90ZW5hbnRJZCA9PT0gKGF1dGhNb2R1bGFyLnRlbmFudElkIHx8IG51bGwpLCBhdXRoTW9kdWxhciwgXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqLyk7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGhNb2R1bGFyLCBjcmVkZW50aWFsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhVcmkoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpjcmVhdGVBdXRoVXJpXCIgLyogRW5kcG9pbnQuQ1JFQVRFX0FVVEhfVVJJICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IG9mIHBvc3NpYmxlIHNpZ24gaW4gbWV0aG9kcyBmb3IgdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHJldHVybnMgYW5cbiAqIGVtcHR5IGxpc3Qgd2hlblxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxuICogaXMgZW5hYmxlZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBudW1iZXIgb2YgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBlbWFpbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB1c2VmdWwgdG8gZGlmZmVyZW50aWF0ZSBtZXRob2RzIG9mIHNpZ24taW4gZm9yIHRoZSBzYW1lIHByb3ZpZGVyLCBlZy5cbiAqIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2hpY2ggaGFzIDIgbWV0aG9kcyBvZiBzaWduLWluLFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBEZXByZWNhdGVkLiBNaWdyYXRpbmcgb2ZmIG9mIHRoaXMgbWV0aG9kIGlzIHJlY29tbWVuZGVkIGFzIGEgc2VjdXJpdHkgYmVzdC1wcmFjdGljZS5cbiAqIExlYXJuIG1vcmUgaW4gdGhlIElkZW50aXR5IFBsYXRmb3JtIGRvY3VtZW50YXRpb24gZm9yXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259LlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbChhdXRoLCBlbWFpbCkge1xuICAgIC8vIGNyZWF0ZUF1dGhVcmkgcmV0dXJucyBhbiBlcnJvciBpZiBjb250aW51ZSBVUkkgaXMgbm90IGh0dHAgb3IgaHR0cHMuXG4gICAgLy8gRm9yIGVudmlyb25tZW50cyBsaWtlIENvcmRvdmEsIENocm9tZSBleHRlbnNpb25zLCBuYXRpdmUgZnJhbWV3b3JrcywgZmlsZVxuICAgIC8vIHN5c3RlbXMsIGV0YywgdXNlIGh0dHA6Ly9sb2NhbGhvc3QgYXMgY29udGludWUgVVJMLlxuICAgIGNvbnN0IGNvbnRpbnVlVXJpID0gX2lzSHR0cE9ySHR0cHMoKSA/IF9nZXRDdXJyZW50VXJsKCkgOiAnaHR0cDovL2xvY2FsaG9zdCc7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgaWRlbnRpZmllcjogZW1haWwsXG4gICAgICAgIGNvbnRpbnVlVXJpXG4gICAgfTtcbiAgICBjb25zdCB7IHNpZ25pbk1ldGhvZHMgfSA9IGF3YWl0IGNyZWF0ZUF1dGhVcmkoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gc2lnbmluTWV0aG9kcyB8fCBbXTtcbn1cbi8qKlxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MgaXMgY29tcGxldGVkIGJ5IGNhbGxpbmcge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9FTUFJTCAqLyxcbiAgICAgICAgaWRUb2tlblxuICAgIH07XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24kMSh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XG4gICAgICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIG5ldyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgdXNlcidzIGVtYWlsIHdpbGwgYmUgdXBkYXRlZCB0byB0aGUgbmV3IG9uZSBhZnRlciBiZWluZyB2ZXJpZmllZC5cbiAqXG4gKiBJZiB5b3UgaGF2ZSBhIGN1c3RvbSBlbWFpbCBhY3Rpb24gaGFuZGxlciwgeW91IGNhbiBjb21wbGV0ZSB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MgYnkgY2FsbGluZ1xuICoge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwodXNlciwgJ25ld2VtYWlsQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdGhlIHVzZXIuXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIG5ld0VtYWlsIC0gVGhlIG5ldyBlbWFpbCBhZGRyZXNzIHRvIGJlIHZlcmlmaWVkIGJlZm9yZSB1cGRhdGUuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwodXNlciwgbmV3RW1haWwsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovLFxuICAgICAgICBpZFRva2VuLFxuICAgICAgICBuZXdFbWFpbFxuICAgIH07XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCB2ZXJpZnlBbmRDaGFuZ2VFbWFpbCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XG4gICAgICAgIC8vIElmIHRoZSBsb2NhbCBjb3B5IG9mIHRoZSBlbWFpbCBvbiB1c2VyIGlzIG91dGRhdGVkLCByZWxvYWQgdGhlXG4gICAgICAgIC8vIHVzZXIuXG4gICAgICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgYSB1c2VyJ3MgcHJvZmlsZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvZmlsZSAtIFRoZSBwcm9maWxlJ3MgYGRpc3BsYXlOYW1lYCBhbmQgYHBob3RvVVJMYCB0byB1cGRhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9maWxlKHVzZXIsIHsgZGlzcGxheU5hbWUsIHBob3RvVVJMOiBwaG90b1VybCB9KSB7XG4gICAgaWYgKGRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgJiYgcGhvdG9VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCBwcm9maWxlUmVxdWVzdCA9IHtcbiAgICAgICAgaWRUb2tlbixcbiAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIHBob3RvVXJsLFxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VySW50ZXJuYWwsIHVwZGF0ZVByb2ZpbGUkMSh1c2VySW50ZXJuYWwuYXV0aCwgcHJvZmlsZVJlcXVlc3QpKTtcbiAgICB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgIHVzZXJJbnRlcm5hbC5waG90b1VSTCA9IHJlc3BvbnNlLnBob3RvVXJsIHx8IG51bGw7XG4gICAgLy8gVXBkYXRlIHRoZSBwYXNzd29yZCBwcm92aWRlciBhcyB3ZWxsXG4gICAgY29uc3QgcGFzc3dvcmRQcm92aWRlciA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmluZCgoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQgPT09IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovKTtcbiAgICBpZiAocGFzc3dvcmRQcm92aWRlcikge1xuICAgICAgICBwYXNzd29yZFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gdXNlckludGVybmFsLmRpc3BsYXlOYW1lO1xuICAgICAgICBwYXNzd29yZFByb3ZpZGVyLnBob3RvVVJMID0gdXNlckludGVybmFsLnBob3RvVVJMO1xuICAgIH1cbiAgICBhd2FpdCB1c2VySW50ZXJuYWwuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIGVtYWlsIHdpbGwgYmUgc2VudCB0byB0aGUgb3JpZ2luYWwgZW1haWwgYWRkcmVzcyAoaWYgaXQgd2FzIHNldCkgdGhhdCBhbGxvd3MgdG8gcmV2b2tlIHRoZVxuICogZW1haWwgYWRkcmVzcyBjaGFuZ2UsIGluIG9yZGVyIHRvIHByb3RlY3QgdGhlbSBmcm9tIGFjY291bnQgaGlqYWNraW5nLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24gYW55IHtAbGluayBVc2VyfSBzaWduZWQgaW4gYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlc1xuICogY3JlYXRlZCB3aXRoIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5IHNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5IHNpZ25lZFxuICogaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIG5ld0VtYWlsIC0gVGhlIG5ldyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIFRocm93cyBcImF1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgZXJyb3Igd2hlblxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxuICogaXMgZW5hYmxlZC5cbiAqIERlcHJlY2F0ZWQgLSBVc2Uge0BsaW5rIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsfSBpbnN0ZWFkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRW1haWwodXNlciwgbmV3RW1haWwpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHVzZXJJbnRlcm5hbC5hdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHVzZXJJbnRlcm5hbC5hdXRoKSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQodXNlckludGVybmFsLCBuZXdFbWFpbCwgbnVsbCk7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFzc3dvcmQodXNlciwgbmV3UGFzc3dvcmQpIHtcbiAgICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgbnVsbCwgbmV3UGFzc3dvcmQpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxPclBhc3N3b3JkKHVzZXIsIGVtYWlsLCBwYXNzd29yZCkge1xuICAgIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgaWRUb2tlbixcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9O1xuICAgIGlmIChlbWFpbCkge1xuICAgICAgICByZXF1ZXN0LmVtYWlsID0gZW1haWw7XG4gICAgfVxuICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgICByZXF1ZXN0LnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgdXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSk7XG4gICAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUGFyc2UgdGhlIGBBZGRpdGlvbmFsVXNlckluZm9gIGZyb20gdGhlIElEIHRva2VuIHJlc3BvbnNlLlxuICpcbiAqL1xuZnVuY3Rpb24gX2Zyb21JZFRva2VuUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWlkVG9rZW5SZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBwcm92aWRlcklkIH0gPSBpZFRva2VuUmVzcG9uc2U7XG4gICAgY29uc3QgcHJvZmlsZSA9IGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mb1xuICAgICAgICA/IEpTT04ucGFyc2UoaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvKVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IGlzTmV3VXNlciA9IGlkVG9rZW5SZXNwb25zZS5pc05ld1VzZXIgfHxcbiAgICAgICAgaWRUb2tlblJlc3BvbnNlLmtpbmQgPT09IFwiaWRlbnRpdHl0b29sa2l0I1NpZ251cE5ld1VzZXJSZXNwb25zZVwiIC8qIElkVG9rZW5SZXNwb25zZUtpbmQuU2lnbnVwTmV3VXNlciAqLztcbiAgICBpZiAoIXByb3ZpZGVySWQgJiYgKGlkVG9rZW5SZXNwb25zZSA9PT0gbnVsbCB8fCBpZFRva2VuUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkVG9rZW5SZXNwb25zZS5pZFRva2VuKSkge1xuICAgICAgICBjb25zdCBzaWduSW5Qcm92aWRlciA9IChfYiA9IChfYSA9IF9wYXJzZVRva2VuKGlkVG9rZW5SZXNwb25zZS5pZFRva2VuKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcmViYXNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3NpZ25faW5fcHJvdmlkZXInXTtcbiAgICAgICAgaWYgKHNpZ25JblByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3ZpZGVySWQgPSBzaWduSW5Qcm92aWRlciAhPT0gXCJhbm9ueW1vdXNcIiAvKiBQcm92aWRlcklkLkFOT05ZTU9VUyAqLyAmJlxuICAgICAgICAgICAgICAgIHNpZ25JblByb3ZpZGVyICE9PSBcImN1c3RvbVwiIC8qIFByb3ZpZGVySWQuQ1VTVE9NICovXG4gICAgICAgICAgICAgICAgPyBzaWduSW5Qcm92aWRlclxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFVzZXMgZ2VuZXJpYyBjbGFzcyBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIGxlZ2FjeSBTREsuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBmaWx0ZXJlZFByb3ZpZGVySWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXJJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChwcm92aWRlcklkKSB7XG4gICAgICAgIGNhc2UgXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWNlYm9va0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xuICAgICAgICBjYXNlIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICAgICAgY2FzZSBcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgICAgIGNhc2UgXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHdpdHRlckFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUsIGlkVG9rZW5SZXNwb25zZS5zY3JlZW5OYW1lIHx8IG51bGwpO1xuICAgICAgICBjYXNlIFwiY3VzdG9tXCIgLyogUHJvdmlkZXJJZC5DVVNUT00gKi86XG4gICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIiAvKiBQcm92aWRlcklkLkFOT05ZTU9VUyAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIG51bGwpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XG4gICAgfVxufVxuY2xhc3MgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlID0ge30pIHtcbiAgICAgICAgdGhpcy5pc05ld1VzZXIgPSBpc05ld1VzZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgfVxufVxuY2xhc3MgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlLCB1c2VybmFtZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUpO1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgfVxufVxuY2xhc3MgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi8sIHByb2ZpbGUpO1xuICAgIH1cbn1cbmNsYXNzIEdpdGh1YkFkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi8sIHByb2ZpbGUsIHR5cGVvZiAocHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luKSA9PT0gJ3N0cmluZycgPyBwcm9maWxlID09PSBudWxsIHx8IHByb2ZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2ZpbGUubG9naW4gOiBudWxsKTtcbiAgICB9XG59XG5jbGFzcyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLywgcHJvZmlsZSk7XG4gICAgfVxufVxuY2xhc3MgVHdpdHRlckFkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlLCBzY3JlZW5OYW1lKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLywgcHJvZmlsZSwgc2NyZWVuTmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0cyBwcm92aWRlciBzcGVjaWZpYyB7QGxpbmsgQWRkaXRpb25hbFVzZXJJbmZvfSBmb3IgdGhlIGdpdmVuIGNyZWRlbnRpYWwuXG4gKlxuICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxVc2VySW5mbyh1c2VyQ3JlZGVudGlhbCkge1xuICAgIGNvbnN0IHsgdXNlciwgX3Rva2VuUmVzcG9uc2UgfSA9IHVzZXJDcmVkZW50aWFsO1xuICAgIGlmICh1c2VyLmlzQW5vbnltb3VzICYmICFfdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAvLyBIYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSBzaWduSW5Bbm9ueW1vdXNseSgpIGdldHMgY2FsbGVkIHR3aWNlLlxuICAgICAgICAvLyBObyBuZXR3b3JrIGNhbGwgaXMgbWFkZSBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gYWN0dWFsbHkgZmlsbCB0aGlzIGluXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBudWxsLFxuICAgICAgICAgICAgaXNOZXdVc2VyOiBmYWxzZSxcbiAgICAgICAgICAgIHByb2ZpbGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9mcm9tSWRUb2tlblJlc3BvbnNlKF90b2tlblJlc3BvbnNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIE5vbi1vcHRpb25hbCBhdXRoIG1ldGhvZHMuXG4vKipcbiAqIENoYW5nZXMgdGhlIHR5cGUgb2YgcGVyc2lzdGVuY2Ugb24gdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnRseSBzYXZlZFxuICogYEF1dGhgIHNlc3Npb24gYW5kIGFwcGxpZXMgdGhpcyB0eXBlIG9mIHBlcnNpc3RlbmNlIGZvciBmdXR1cmUgc2lnbi1pbiByZXF1ZXN0cywgaW5jbHVkaW5nXG4gKiBzaWduLWluIHdpdGggcmVkaXJlY3QgcmVxdWVzdHMuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbWFrZXMgaXQgZWFzeSBmb3IgYSB1c2VyIHNpZ25pbmcgaW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZWlyIHNlc3Npb24gc2hvdWxkIGJlXG4gKiByZW1lbWJlcmVkIG9yIG5vdC4gSXQgYWxzbyBtYWtlcyBpdCBlYXNpZXIgdG8gbmV2ZXIgcGVyc2lzdCB0aGUgYEF1dGhgIHN0YXRlIGZvciBhcHBsaWNhdGlvbnNcbiAqIHRoYXQgYXJlIHNoYXJlZCBieSBvdGhlciB1c2VycyBvciBoYXZlIHNlbnNpdGl2ZSBkYXRhLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50IG9yIHdpdGgge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBzZXRQZXJzaXN0ZW5jZShhdXRoLCBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwZXJzaXN0ZW5jZSAtIFRoZSB7QGxpbmsgUGVyc2lzdGVuY2V9IHRvIHVzZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgcGVyc2lzdGVuY2UgY2hhbmdlIGhhcyBjb21wbGV0ZWRcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbmNlKGF1dGgsIHBlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSk7XG59XG4vKipcbiAqIExvYWRzIHRoZSByZUNBUFRDSEEgY29uZmlndXJhdGlvbiBpbnRvIHRoZSBgQXV0aGAgaW5zdGFuY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgd2lsbCBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnLCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVDQVBUQ0hBXG4gKiB2ZXJpZmljYXRpb24gZmxvdyBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvciBlYWNoIGF1dGggcHJvdmlkZXIsIGludG8gdGhlXG4gKiBjdXJyZW50IEF1dGggc2Vzc2lvbi5cbiAqXG4gKiBJZiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCkgaXMgbm90IGludm9rZWQsIHRoZSBhdXRoIGZsb3cgd2lsbCBhbHdheXMgc3RhcnRcbiAqIHdpdGhvdXQgcmVDQVBUQ0hBIHZlcmlmaWNhdGlvbi4gSWYgdGhlIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWQgdG8gcmVxdWlyZSByZUNBUFRDSEFcbiAqIHZlcmlmaWNhdGlvbiwgdGhlIFNESyB3aWxsIHRyYW5zcGFyZW50bHkgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBhbmQgcmVzdGFydCB0aGVcbiAqIGF1dGggZmxvd3MuXG4gKlxuICogVGh1cywgYnkgY2FsbGluZyB0aGlzIG9wdGlvbmFsIG1ldGhvZCwgeW91IHdpbGwgcmVkdWNlIHRoZSBsYXRlbmN5IG9mIGZ1dHVyZSBhdXRoIGZsb3dzLlxuICogTG9hZGluZyB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBlYXJseSB3aWxsIGFsc28gZW5oYW5jZSB0aGUgc2lnbmFsIGNvbGxlY3RlZCBieSByZUNBUFRDSEEuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpIHtcbiAgICByZXR1cm4gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgcGFzc3dvcmQgYWdhaW5zdCB0aGUgcGFzc3dvcmQgcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0IG9yIHRlbmFudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgbm8gdGVuYW50IElEIGlzIHNldCBvbiB0aGUgYEF1dGhgIGluc3RhbmNlLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwYXNzd29yZFxuICogcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwb2xpY3kgY29uZmlndXJlZFxuICogZm9yIHRoZSB0ZW5hbnQuIElmIGEgcGFzc3dvcmQgcG9saWN5IGhhcyBub3QgYmVlbiBjb25maWd1cmVkLCB0aGVuIHRoZSBkZWZhdWx0IHBvbGljeVxuICogY29uZmlndXJlZCBmb3IgYWxsIHByb2plY3RzIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBJZiBhbiBhdXRoIGZsb3cgZmFpbHMgYmVjYXVzZSBhIHN1Ym1pdHRlZCBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHRoZSBwYXNzd29yZCBwb2xpY3lcbiAqIHJlcXVpcmVtZW50cyBhbmQgdGhpcyBtZXRob2QgaGFzIHByZXZpb3VzbHkgYmVlbiBjYWxsZWQsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlXG4gKiBtb3N0IHJlY2VudCBwb2xpY3kgYXZhaWxhYmxlIHdoZW4gY2FsbGVkIGFnYWluLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YWxpZGF0ZVBhc3N3b3JkKGF1dGgsICdzb21lLXBhc3N3b3JkJyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byB2YWxpZGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgcmV0dXJuIGF1dGhJbnRlcm5hbC52YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKTtcbn1cbi8qKlxuICogQWRkcyBhbiBvYnNlcnZlciBmb3IgY2hhbmdlcyB0byB0aGUgc2lnbmVkLWluIHVzZXIncyBJRCB0b2tlbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpbmNsdWRlcyBzaWduLWluLCBzaWduLW91dCwgYW5kIHRva2VuIHJlZnJlc2ggZXZlbnRzLlxuICogVGhpcyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB1cG9uIElEIHRva2VuIGV4cGlyYXRpb24uIFVzZSB7QGxpbmsgVXNlci5nZXRJZFRva2VufSB0byByZWZyZXNoIHRoZSBJRCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9uSWRUb2tlbkNoYW5nZWQoYXV0aCwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uSWRUb2tlbkNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xufVxuLyoqXG4gKiBBZGRzIGEgYmxvY2tpbmcgY2FsbGJhY2sgdGhhdCBydW5zIGJlZm9yZSBhbiBhdXRoIHN0YXRlIGNoYW5nZVxuICogc2V0cyBhIG5ldyB1c2VyLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxiYWNrIHRyaWdnZXJlZCBiZWZvcmUgbmV3IHVzZXIgdmFsdWUgaXMgc2V0LlxuICogICBJZiB0aGlzIHRocm93cywgaXQgYmxvY2tzIHRoZSB1c2VyIGZyb20gYmVpbmcgc2V0LlxuICogQHBhcmFtIG9uQWJvcnQgLSBjYWxsYmFjayB0cmlnZ2VyZWQgaWYgYSBsYXRlciBgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCgpYFxuICogICBjYWxsYmFjayB0aHJvd3MsIGFsbG93aW5nIHlvdSB0byB1bmRvIGFueSBzaWRlIGVmZmVjdHMuXG4gKi9cbmZ1bmN0aW9uIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoYXV0aCwgY2FsbGJhY2ssIG9uQWJvcnQpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLmJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpO1xufVxuLyoqXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8ga2VlcCB0aGUgb2xkIGJlaGF2aW9yLCBzZWUge0BsaW5rIG9uSWRUb2tlbkNoYW5nZWR9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtIGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBjaGFuZ2UuXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cbiAqIHNpZ24taW4vc2lnbi1vdXQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25BdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxhbmd1YWdlIHRvIHRoZSBkZWZhdWx0IGRldmljZS9icm93c2VyIHByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRGV2aWNlTGFuZ3VhZ2UoYXV0aCkge1xuICAgIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS51c2VEZXZpY2VMYW5ndWFnZSgpO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzZXRzIHRoZSBwcm92aWRlZCB1c2VyIGFzIHtAbGluayBBdXRoLmN1cnJlbnRVc2VyfSBvbiB0aGVcbiAqIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBuZXcgaW5zdGFuY2UgY29weSBvZiB0aGUgdXNlciBwcm92aWRlZCB3aWxsIGJlIG1hZGUgYW5kIHNldCBhcyBjdXJyZW50VXNlci5cbiAqXG4gKiBUaGlzIHdpbGwgdHJpZ2dlciB7QGxpbmsgb25BdXRoU3RhdGVDaGFuZ2VkfSBhbmQge0BsaW5rIG9uSWRUb2tlbkNoYW5nZWR9IGxpc3RlbmVyc1xuICogbGlrZSBvdGhlciBzaWduIGluIG1ldGhvZHMuXG4gKlxuICogVGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB1c2VyIHRvIGJlIHVwZGF0ZWQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBGaXJlYmFzZVxuICogcHJvamVjdC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gdXNlciAtIFRoZSBuZXcge0BsaW5rIFVzZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ3VycmVudFVzZXIoYXV0aCwgdXNlcikge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXBkYXRlQ3VycmVudFVzZXIodXNlcik7XG59XG4vKipcbiAqIFNpZ25zIG91dCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzaWduT3V0KGF1dGgpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnNpZ25PdXQoKTtcbn1cbi8qKlxuICogUmV2b2tlcyB0aGUgZ2l2ZW4gYWNjZXNzIHRva2VuLiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW4uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZXZva2VBY2Nlc3NUb2tlbihhdXRoLCB0b2tlbikge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICByZXR1cm4gYXV0aEludGVybmFsLnJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKTtcbn1cbi8qKlxuICogRGVsZXRlcyBhbmQgc2lnbnMgb3V0IHRoZSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eS1zZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseVxuICogc2lnbmVkIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcikge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UodXNlcikuZGVsZXRlKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvclNlc3Npb25JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbCA9IGNyZWRlbnRpYWw7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbUlkdG9rZW4oaWRUb2tlbiwgdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwoXCJlbnJvbGxcIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTCAqLywgaWRUb2tlbiwgdXNlcik7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG1mYVBlbmRpbmdDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcInNpZ25pblwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTiAqLywgbWZhUGVuZGluZ0NyZWRlbnRpYWwpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMudHlwZSA9PT0gXCJlbnJvbGxcIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLkVOUk9MTCAqL1xuICAgICAgICAgICAgPyAnaWRUb2tlbidcbiAgICAgICAgICAgIDogJ3BlbmRpbmdDcmVkZW50aWFsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG11bHRpRmFjdG9yU2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgIFtrZXldOiB0aGlzLmNyZWRlbnRpYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKG9iaikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKChfYSA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZW5kaW5nQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwob2JqLm11bHRpRmFjdG9yU2Vzc2lvbi5wZW5kaW5nQ3JlZGVudGlhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoX2IgPSBvYmoubXVsdGlGYWN0b3JTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tSWR0b2tlbihvYmoubXVsdGlGYWN0b3JTZXNzaW9uLmlkVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBoaW50cywgc2lnbkluUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5oaW50cyA9IGhpbnRzO1xuICAgICAgICB0aGlzLnNpZ25JblJlc29sdmVyID0gc2lnbkluUmVzb2x2ZXI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21FcnJvcihhdXRoRXh0ZXJuLCBlcnJvcikge1xuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xuICAgICAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGVycm9yLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlO1xuICAgICAgICBjb25zdCBoaW50cyA9IChzZXJ2ZXJSZXNwb25zZS5tZmFJbmZvIHx8IFtdKS5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkpO1xuICAgICAgICBfYXNzZXJ0KHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwoc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwpO1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsKHNlc3Npb24sIGhpbnRzLCBhc3luYyAoYXNzZXJ0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZmFSZXNwb25zZSA9IGF3YWl0IGFzc2VydGlvbi5fcHJvY2VzcyhhdXRoLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgdW5uZWVkZWQgZmllbGRzIGZyb20gdGhlIG9sZCBsb2dpbiByZXNwb25zZVxuICAgICAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYUluZm87XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWw7XG4gICAgICAgICAgICAvLyBVc2UgaW4gdGhlIG5ldyB0b2tlbiAmIHJlZnJlc2ggdG9rZW4gaW4gdGhlIG9sZCByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJ2ZXJSZXNwb25zZSksIHsgaWRUb2tlbjogbWZhUmVzcG9uc2UuaWRUb2tlbiwgcmVmcmVzaFRva2VuOiBtZmFSZXNwb25zZS5yZWZyZXNoVG9rZW4gfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgY29sbGFwc2UgdGhpcyBzd2l0Y2ggc3RhdGVtZW50IGludG8gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24gYW5kIGhhdmUgaXQgc3VwcG9ydCB0aGUgU0lHTl9JTiBjYXNlXG4gICAgICAgICAgICBzd2l0Y2ggKGVycm9yLm9wZXJhdGlvblR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBlcnJvci5vcGVyYXRpb25UeXBlLCBpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi86XG4gICAgICAgICAgICAgICAgICAgIF9hc3NlcnQoZXJyb3IudXNlciwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24oZXJyb3IudXNlciwgZXJyb3Iub3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlU2lnbkluKGFzc2VydGlvbkV4dGVybikge1xuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm47XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25JblJlc29sdmVyKGFzc2VydGlvbik7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlcyBhIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyfSBzdWl0YWJsZSBmb3IgY29tcGxldGlvbiBvZiBhXG4gKiBtdWx0aS1mYWN0b3IgZmxvdy5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUge0BsaW5rIE11bHRpRmFjdG9yRXJyb3J9IHJhaXNlZCBkdXJpbmcgYSBzaWduLWluLCBvclxuICogcmVhdXRoZW50aWNhdGlvbiBvcGVyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRNdWx0aUZhY3RvclJlc29sdmVyKGF1dGgsIGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF1dGhNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICAgIGNvbnN0IGVycm9ySW50ZXJuYWwgPSBlcnJvcjtcbiAgICBfYXNzZXJ0KGVycm9yLmN1c3RvbURhdGEub3BlcmF0aW9uVHlwZSwgYXV0aE1vZHVsYXIsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICBfYXNzZXJ0KChfYSA9IGVycm9ySW50ZXJuYWwuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZmFQZW5kaW5nQ3JlZGVudGlhbCwgYXV0aE1vZHVsYXIsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICByZXR1cm4gTXVsdGlGYWN0b3JSZXNvbHZlckltcGwuX2Zyb21FcnJvcihhdXRoTW9kdWxhciwgZXJyb3JJbnRlcm5hbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBzdGFydEVucm9sbFRvdHBNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OnN0YXJ0XCIgLyogRW5kcG9pbnQuU1RBUlRfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUVucm9sbFRvdHBNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5mdW5jdGlvbiB3aXRoZHJhd01mYShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6d2l0aGRyYXdcIiAvKiBFbmRwb2ludC5XSVRIRFJBV19NRkEgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbmNsYXNzIE11bHRpRmFjdG9yVXNlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHVzZXIpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSBbXTtcbiAgICAgICAgdXNlci5fb25SZWxvYWQodXNlckluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXJJbmZvLm1mYUluZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHVzZXJJbmZvLm1mYUluZm8ubWFwKGVucm9sbG1lbnQgPT4gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKHVzZXIuYXV0aCwgZW5yb2xsbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tVXNlcih1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JVc2VySW1wbCh1c2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCksIHRoaXMudXNlcik7XG4gICAgfVxuICAgIGFzeW5jIGVucm9sbChhc3NlcnRpb25FeHRlcm4sIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IChhd2FpdCB0aGlzLmdldFNlc3Npb24oKSk7XG4gICAgICAgIGNvbnN0IGZpbmFsaXplTWZhUmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLnVzZXIsIGFzc2VydGlvbi5fcHJvY2Vzcyh0aGlzLnVzZXIuYXV0aCwgc2Vzc2lvbiwgZGlzcGxheU5hbWUpKTtcbiAgICAgICAgLy8gTmV3IHRva2VucyB3aWxsIGJlIGlzc3VlZCBhZnRlciBlbnJvbGxtZW50IG9mIHRoZSBuZXcgc2Vjb25kIGZhY3RvcnMuXG4gICAgICAgIC8vIFRoZXkgbmVlZCB0byBiZSB1cGRhdGVkIG9uIHRoZSB1c2VyLlxuICAgICAgICBhd2FpdCB0aGlzLnVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KGZpbmFsaXplTWZhUmVzcG9uc2UpO1xuICAgICAgICAvLyBUaGUgdXNlciBuZWVkcyB0byBiZSByZWxvYWRlZCB0byBnZXQgdGhlIG5ldyBtdWx0aS1mYWN0b3IgaW5mb3JtYXRpb25cbiAgICAgICAgLy8gZnJvbSBzZXJ2ZXIuIFVTRVJfUkVMT0FERUQgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgYW5kIGBlbnJvbGxlZEZhY3RvcnNgXG4gICAgICAgIC8vIHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlci5yZWxvYWQoKTtcbiAgICB9XG4gICAgYXN5bmMgdW5lbnJvbGwoaW5mb09yVWlkKSB7XG4gICAgICAgIGNvbnN0IG1mYUVucm9sbG1lbnRJZCA9IHR5cGVvZiBpbmZvT3JVaWQgPT09ICdzdHJpbmcnID8gaW5mb09yVWlkIDogaW5mb09yVWlkLnVpZDtcbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLnVzZXIsIHdpdGhkcmF3TWZhKHRoaXMudXNlci5hdXRoLCB7XG4gICAgICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgICAgICBtZmFFbnJvbGxtZW50SWRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2Vjb25kIGZhY3RvciBmcm9tIHRoZSB1c2VyJ3MgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdGhpcy5lbnJvbGxlZEZhY3RvcnMuZmlsdGVyKCh7IHVpZCB9KSA9PiB1aWQgIT09IG1mYUVucm9sbG1lbnRJZCk7XG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYmFja2VuZCBkZWNpZGVkIHRvIHJldm9rZSB0aGUgdXNlcidzIHNlc3Npb24sXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW5SZXNwb25zZSBtYXkgYmUgZW1wdHkuIElmIHRoZSB0b2tlbnMgd2VyZSBub3QgdXBkYXRlZCAoYW5kIHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBub3cgaW52YWxpZCksIHJlbG9hZGluZyB0aGUgdXNlciB3aWxsIGRpc2NvdmVyIHRoaXMgYW5kIGludmFsaWRhdGVcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyJ3Mgc3RhdGUgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXIucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBtdWx0aUZhY3RvclVzZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JVc2VyfSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWNjZXNzIGFsbCBtdWx0aS1mYWN0b3IgcHJvcGVydGllcyBhbmQgb3BlcmF0aW9ucyByZWxhdGVkIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBtdWx0aUZhY3Rvcih1c2VyKSB7XG4gICAgY29uc3QgdXNlck1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgaWYgKCFtdWx0aUZhY3RvclVzZXJDYWNoZS5oYXModXNlck1vZHVsYXIpKSB7XG4gICAgICAgIG11bHRpRmFjdG9yVXNlckNhY2hlLnNldCh1c2VyTW9kdWxhciwgTXVsdGlGYWN0b3JVc2VySW1wbC5fZnJvbVVzZXIodXNlck1vZHVsYXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG11bHRpRmFjdG9yVXNlckNhY2hlLmdldCh1c2VyTW9kdWxhcik7XG59XG5cbnZhciBuYW1lID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xudmFyIHZlcnNpb24gPSBcIjEuMTAuN1wiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aEludGVyb3Age1xuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0VWlkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBpZiAoIXRoaXMuYXV0aC5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmF1dGguY3VycmVudFVzZXIuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xuICAgICAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiB9O1xuICAgIH1cbiAgICBhZGRBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVybmFsTGlzdGVuZXJzLmhhcyhsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuYXV0aC5vbklkVG9rZW5DaGFuZ2VkKHVzZXIgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4pIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5zZXQobGlzdGVuZXIsIHVuc3Vic2NyaWJlKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICAgIHJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgICBhc3NlcnRBdXRoQ29uZmlndXJlZCgpIHtcbiAgICAgICAgX2Fzc2VydCh0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZSwgXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi8pO1xuICAgIH1cbiAgICB1cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkge1xuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSBcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovOlxuICAgICAgICAgICAgcmV0dXJuICdub2RlJztcbiAgICAgICAgY2FzZSBcIlJlYWN0TmF0aXZlXCIgLyogQ2xpZW50UGxhdGZvcm0uUkVBQ1RfTkFUSVZFICovOlxuICAgICAgICAgICAgcmV0dXJuICdybic7XG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XG4gICAgICAgICAgICByZXR1cm4gJ3dlYndvcmtlcic7XG4gICAgICAgIGNhc2UgXCJDb3Jkb3ZhXCIgLyogQ2xpZW50UGxhdGZvcm0uQ09SRE9WQSAqLzpcbiAgICAgICAgICAgIHJldHVybiAnY29yZG92YSc7XG4gICAgICAgIGNhc2UgXCJXZWJFeHRlbnNpb25cIiAvKiBDbGllbnRQbGF0Zm9ybS5XRUJfRVhURU5TSU9OICovOlxuICAgICAgICAgICAgcmV0dXJuICd3ZWItZXh0ZW5zaW9uJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJBdXRoKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoXCJhdXRoXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSCAqLywgKGNvbnRhaW5lciwgeyBvcHRpb25zOiBkZXBzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xuICAgICAgICBjb25zdCB7IGFwaUtleSwgYXV0aERvbWFpbiB9ID0gYXBwLm9wdGlvbnM7XG4gICAgICAgIF9hc3NlcnQoYXBpS2V5ICYmICFhcGlLZXkuaW5jbHVkZXMoJzonKSwgXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqLywgeyBhcHBOYW1lOiBhcHAubmFtZSB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgYXV0aERvbWFpbixcbiAgICAgICAgICAgIGNsaWVudFBsYXRmb3JtLFxuICAgICAgICAgICAgYXBpSG9zdDogXCJpZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9IT1NUICovLFxuICAgICAgICAgICAgdG9rZW5BcGlIb3N0OiBcInNlY3VyZXRva2VuLmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5UT0tFTl9BUElfSE9TVCAqLyxcbiAgICAgICAgICAgIGFwaVNjaGVtZTogXCJodHRwc1wiIC8qIERlZmF1bHRDb25maWcuQVBJX1NDSEVNRSAqLyxcbiAgICAgICAgICAgIHNka0NsaWVudFZlcnNpb246IF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhdXRoSW5zdGFuY2UgPSBuZXcgQXV0aEltcGwoYXBwLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsIGFwcENoZWNrU2VydmljZVByb3ZpZGVyLCBjb25maWcpO1xuICAgICAgICBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoSW5zdGFuY2UsIGRlcHMpO1xuICAgICAgICByZXR1cm4gYXV0aEluc3RhbmNlO1xuICAgIH0sIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdXRoIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIGJ5IGV4cGxpY2l0bHkgY2FsbGluZyBnZXRBdXRoKCkgb3IgaW5pdGlhbGl6ZUF1dGgoKVxuICAgICAgICAgKiBGb3Igd2h5IHdlIGRvIHRoaXMsIFNlZSBnby9maXJlYmFzZS1uZXh0LWF1dGgtaW5pdFxuICAgICAgICAgKi9cbiAgICAgICAgLnNldEluc3RhbnRpYXRpb25Nb2RlKFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlY2F1c2UgYWxsIGZpcmViYXNlIHByb2R1Y3RzIHRoYXQgZGVwZW5kIG9uIGF1dGggZGVwZW5kIG9uIGF1dGgtaW50ZXJuYWwgZGlyZWN0bHksXG4gICAgICAgICAqIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBhdXRoLWludGVybmFsIGFmdGVyIGF1dGggaXMgaW5pdGlhbGl6ZWQgdG8gbWFrZSBpdCBhdmFpbGFibGUgdG8gb3RoZXIgZmlyZWJhc2UgcHJvZHVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICAuc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soKGNvbnRhaW5lciwgX2luc3RhbmNlSWRlbnRpZmllciwgX2luc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhJbnRlcm5hbFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8pO1xuICAgICAgICBhdXRoSW50ZXJuYWxQcm92aWRlci5pbml0aWFsaXplKCk7XG4gICAgfSkpO1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8sIGNvbnRhaW5lciA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8pLmdldEltbWVkaWF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XG4gICAgfSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKS5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pKTtcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgZ2V0VmVyc2lvbkZvclBsYXRmb3JtKGNsaWVudFBsYXRmb3JtKSk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEluaXRpYWxpemUgdGhlIGZldGNoIHBvbHlmaWxsLCB0aGUgdHlwZXMgYXJlIHNsaWdodGx5IG9mZiBzbyBqdXN0IGNhc3QgYW5kIGhvcGUgZm9yIHRoZSBiZXN0XG5GZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoZmV0Y2gsIEhlYWRlcnMsIFJlc3BvbnNlKTtcbi8vIEZpcnN0LCB3ZSBzZXQgdXAgdGhlIHZhcmlvdXMgcGxhdGZvcm0tc3BlY2lmaWMgZmVhdHVyZXMgZm9yIE5vZGUgKHJlZ2lzdGVyXG4vLyB0aGUgdmVyc2lvbiBhbmQgZGVjbGFyZSB0aGUgTm9kZSBnZXRBdXRoIGZ1bmN0aW9uKVxuZnVuY3Rpb24gZ2V0QXV0aChhcHAgPSBnZXRBcHAoKSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2F1dGgnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCk7XG4gICAgY29uc3QgYXV0aEVtdWxhdG9ySG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QoJ2F1dGgnKTtcbiAgICBpZiAoYXV0aEVtdWxhdG9ySG9zdCkge1xuICAgICAgICBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIGBodHRwOi8vJHthdXRoRW11bGF0b3JIb3N0fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aDtcbn1cbnJlZ2lzdGVyQXV0aChcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovKTtcbi8vIFRoZSByZXN0IG9mIHRoaXMgZmlsZSBjb250YWlucyBuby1vcHMgYW5kIGVycm9ycyBmb3IgYnJvd3Nlci1zcGVjaWZpY1xuLy8gbWV0aG9kcy4gV2Uga2VlcCB0aGUgYnJvd3NlciBhbmQgTm9kZSBlbnRyeSBwb2ludHMgdGhlIHNhbWUsIGJ1dCBmZWF0dXJlc1xuLy8gdGhhdCBvbmx5IHdvcmsgaW4gYnJvd3NlcnMgYXJlIHNldCB0byBlaXRoZXIgZG8gbm90aGluZyAoc2V0UGVyc2lzdGVuY2UpIG9yXG4vLyB0byByZWplY3Qgd2l0aCBhbiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgZXJyb3IuXG4vLyBUaGUgYmVsb3cgZXhwb3J0cyBhcmUgcHVsbGVkIGludG8gdGhlIG1haW4gZW50cnkgcG9pbnQgYnkgYSByb2xsdXAgYWxpYXNcbi8vIHBsdWdpbiAob3ZlcndyaXRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBpbXBvcnRzKS5cbi8qKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgKi9cbmNvbnN0IE5PVF9BVkFJTEFCTEVfRVJST1IgPSBfY3JlYXRlRXJyb3IoXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLyk7XG4vKiogUmVqZWN0IHdpdGggYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXG5hc3luYyBmdW5jdGlvbiBmYWlsKCkge1xuICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG59XG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggd2lsbCB0aHJvdyB3aXRoXG4gKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgaWYgaW5zdGFudGlhdGVkXG4gKi9cbmNsYXNzIEZhaWxDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG4gICAgfVxufVxuY29uc3QgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuY29uc3QgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XG5jb25zdCBicm93c2VyQ29va2llUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuY29uc3QgaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XG5jb25zdCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyID0gTk9UX0FWQUlMQUJMRV9FUlJPUjtcbmNvbnN0IFBob25lQXV0aFByb3ZpZGVyID0gRmFpbENsYXNzO1xuY29uc3Qgc2lnbkluV2l0aFBob25lTnVtYmVyID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgdXBkYXRlUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3Qgc2lnbkluV2l0aFBvcHVwID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUG9wdXAgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUG9wdXAgPSBmYWlsO1xuY29uc3Qgc2lnbkluV2l0aFJlZGlyZWN0ID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgZ2V0UmVkaXJlY3RSZXN1bHQgPSBmYWlsO1xuY29uc3QgUmVjYXB0Y2hhVmVyaWZpZXIgPSBGYWlsQ2xhc3M7XG5jbGFzcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIHtcbiAgICBzdGF0aWMgYXNzZXJ0aW9uKCkge1xuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xuICAgIH1cbn1cbi8vIFNldCBwZXJzaXN0ZW5jZSBzaG91bGQgbm8tb3AgaW5zdGVhZCBvZiBmYWlsLiBDaGFuZ2luZyB0aGUgcHJvdG90eXBlIHdpbGxcbi8vIG1ha2Ugc3VyZSBib3RoIHNldFBlcnNpc3RlbmNlKGF1dGgsIHBlcnNpc3RlbmNlKSBhbmRcbi8vIGF1dGguc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIGFyZSBjb3ZlcmVkLlxuQXV0aEltcGwucHJvdG90eXBlLnNldFBlcnNpc3RlbmNlID0gYXN5bmMgKCkgPT4geyB9O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZmluYWxpemVTaWduSW5Ub3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhU2lnbkluOmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX1NJR05fSU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbmNsYXNzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9ySWQpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xuICAgIH1cbiAgICBfcHJvY2VzcyhhdXRoLCBzZXNzaW9uLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBzd2l0Y2ggKHNlc3Npb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZUVucm9sbChhdXRoLCBzZXNzaW9uLmNyZWRlbnRpYWwsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzaWduaW5cIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplU2lnbkluKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ3VuZXhwZWN0ZWQgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2ZcbiAgICAgKiB0aGUgVE9UUCAodGltZS1iYXNlZCBvbmUtdGltZSBwYXNzd29yZCkgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIGVucm9sbG1lbnQgaW4gVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlY3JldCBBIHtAbGluayBUb3RwU2VjcmV0fSBjb250YWluaW5nIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgVE9UUCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvbmVUaW1lUGFzc3dvcmQgT25lLXRpbWUgcGFzc3dvcmQgZnJvbSBUT1RQIEFwcC5cbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JVc2VyLmVucm9sbH0uXG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydGlvbkZvckVucm9sbG1lbnQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21TZWNyZXQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHRvIGNvbmZpcm0gb3duZXJzaGlwIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBzaWduSW4gd2l0aCBUT1RQIGFzIHRoZSBzZWNvbmQgZmFjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVucm9sbG1lbnRJZCBpZGVudGlmaWVzIHRoZSBlbnJvbGxlZCBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyLnJlc29sdmVTaWduSW59LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3NlcnRpb25Gb3JTaWduSW4oZW5yb2xsbWVudElkLCBvbmVUaW1lUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21FbnJvbGxtZW50SWQoZW5yb2xsbWVudElkLCBvbmVUaW1lUGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0gd2hpY2ggY29udGFpbnMgdGhlIFRPVFAgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMuXG4gICAgICogQ3JlYXRlcyBhIFRPVFAgc2VjcmV0IGFzIHBhcnQgb2YgZW5yb2xsaW5nIGEgVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgICAqIFVzZWQgZm9yIGdlbmVyYXRpbmcgYSBRUiBjb2RlIFVSTCBvciBpbnB1dHRpbmcgaW50byBhIFRPVFAgYXBwLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGF1dGggaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byB0aGUgdXNlciBpbiB0aGUgbXVsdGlGYWN0b3JTZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlc3Npb24gVGhlIHtAbGluayBNdWx0aUZhY3RvclNlc3Npb259IHRoYXQgdGhlIHVzZXIgaXMgcGFydCBvZi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8ge0BsaW5rIFRvdHBTZWNyZXR9LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVNlY3JldChzZXNzaW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWZhU2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIF9hc3NlcnQodHlwZW9mICgoX2EgPSBtZmFTZXNzaW9uLnVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRoKSAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdGFydEVucm9sbFRvdHBNZmEobWZhU2Vzc2lvbi51c2VyLmF1dGgsIHtcbiAgICAgICAgICAgIGlkVG9rZW46IG1mYVNlc3Npb24uY3JlZGVudGlhbCxcbiAgICAgICAgICAgIHRvdHBFbnJvbGxtZW50SW5mbzoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUb3RwU2VjcmV0Ll9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBtZmFTZXNzaW9uLnVzZXIuYXV0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yOiBgdG90cGAuXG4gKi9cblRvdHBNdWx0aUZhY3RvckdlbmVyYXRvci5GQUNUT1JfSUQgPSBcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovO1xuY2xhc3MgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCBleHRlbmRzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3RwLCBlbnJvbGxtZW50SWQsIHNlY3JldCkge1xuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovKTtcbiAgICAgICAgdGhpcy5vdHAgPSBvdHA7XG4gICAgICAgIHRoaXMuZW5yb2xsbWVudElkID0gZW5yb2xsbWVudElkO1xuICAgICAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVNlY3JldChzZWNyZXQsIG90cCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCB1bmRlZmluZWQsIHNlY3JldCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21FbnJvbGxtZW50SWQoZW5yb2xsbWVudElkLCBvdHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsKG90cCwgZW5yb2xsbWVudElkKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9maW5hbGl6ZUVucm9sbChhdXRoLCBpZFRva2VuLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB0aGlzLnNlY3JldCAhPT0gJ3VuZGVmaW5lZCcsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCB7XG4gICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5zZWNyZXQuX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyh0aGlzLm90cClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZmluYWxpemVTaWduSW4oYXV0aCwgbWZhUGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgX2Fzc2VydCh0aGlzLmVucm9sbG1lbnRJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3RwICE9PSB1bmRlZmluZWQsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgdG90cFZlcmlmaWNhdGlvbkluZm8gPSB7IHZlcmlmaWNhdGlvbkNvZGU6IHRoaXMub3RwIH07XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwge1xuICAgICAgICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgICAgICAgICBtZmFFbnJvbGxtZW50SWQ6IHRoaXMuZW5yb2xsbWVudElkLFxuICAgICAgICAgICAgdG90cFZlcmlmaWNhdGlvbkluZm9cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259LlxuICpcbiAqIFN0b3JlcyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMgdG8gZ2VuZXJhdGUgdGltZS1iYXNlZCBPVFBzLlxuICogSW1wbGVtZW50cyBtZXRob2RzIHRvIHJldHJpZXZlIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgZ2VuZXJhdGUgYSBRUiBjb2RlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVG90cFNlY3JldCB7XG4gICAgLy8gVGhlIHB1YmxpYyBtZW1iZXJzIGFyZSBkZWNsYXJlZCBvdXRzaWRlIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGUgZG9jcyBjYW4gYmUgZ2VuZXJhdGVkLlxuICAgIGNvbnN0cnVjdG9yKHNlY3JldEtleSwgaGFzaGluZ0FsZ29yaXRobSwgY29kZUxlbmd0aCwgY29kZUludGVydmFsU2Vjb25kcywgZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSwgc2Vzc2lvbkluZm8sIGF1dGgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSW5mbyA9IHNlc3Npb25JbmZvO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleTtcbiAgICAgICAgdGhpcy5oYXNoaW5nQWxnb3JpdGhtID0gaGFzaGluZ0FsZ29yaXRobTtcbiAgICAgICAgdGhpcy5jb2RlTGVuZ3RoID0gY29kZUxlbmd0aDtcbiAgICAgICAgdGhpcy5jb2RlSW50ZXJ2YWxTZWNvbmRzID0gY29kZUludGVydmFsU2Vjb25kcztcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lID0gZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShyZXNwb25zZSwgYXV0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBTZWNyZXQocmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnNoYXJlZFNlY3JldEtleSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLmhhc2hpbmdBbGdvcml0aG0sIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby52ZXJpZmljYXRpb25Db2RlTGVuZ3RoLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8ucGVyaW9kU2VjLCBuZXcgRGF0ZShyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uZmluYWxpemVFbnJvbGxtZW50VGltZSkudG9VVENTdHJpbmcoKSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnNlc3Npb25JbmZvLCBhdXRoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tYWtlVG90cFZlcmlmaWNhdGlvbkluZm8ob3RwKSB7XG4gICAgICAgIHJldHVybiB7IHNlc3Npb25JbmZvOiB0aGlzLnNlc3Npb25JbmZvLCB2ZXJpZmljYXRpb25Db2RlOiBvdHAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFFSIGNvZGUgVVJMIGFzIGRlc2NyaWJlZCBpblxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZ29vZ2xlLWF1dGhlbnRpY2F0b3Ivd2lraS9LZXktVXJpLUZvcm1hdFxuICAgICAqIFRoaXMgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhcyBhIFFSIGNvZGUgdG8gYmUgc2Nhbm5lZCBpbnRvIGEgVE9UUCBhcHAgbGlrZSBHb29nbGUgQXV0aGVudGljYXRvci5cbiAgICAgKiBJZiB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdW5zcGVjaWZpZWQsIGFuIGFjY291bnROYW1lIG9mIDx1c2VyRW1haWw+IGFuZCBpc3N1ZXIgb2YgPGZpcmViYXNlQXBwTmFtZT4gYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjb3VudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGFjY291bnQvYXBwIGFsb25nIHdpdGggYSB1c2VyIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgb2YgdGhlIFRPVFAgKGxpa2VseSB0aGUgYXBwIG5hbWUpLlxuICAgICAqIEByZXR1cm5zIEEgUVIgY29kZSBVUkwgc3RyaW5nLlxuICAgICAqL1xuICAgIGdlbmVyYXRlUXJDb2RlVXJsKGFjY291bnROYW1lLCBpc3N1ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSB8fCBfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZURlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudE5hbWUgPSAoKF9hID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1haWwpIHx8ICd1bmtub3dudXNlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoaXNzdWVyKSkge1xuICAgICAgICAgICAgICAgIGlzc3VlciA9IHRoaXMuYXV0aC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgb3RwYXV0aDovL3RvdHAvJHtpc3N1ZXJ9OiR7YWNjb3VudE5hbWV9P3NlY3JldD0ke3RoaXMuc2VjcmV0S2V5fSZpc3N1ZXI9JHtpc3N1ZXJ9JmFsZ29yaXRobT0ke3RoaXMuaGFzaGluZ0FsZ29yaXRobX0mZGlnaXRzPSR7dGhpcy5jb2RlTGVuZ3RofWA7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gX2lzRW1wdHlTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0Lmxlbmd0aCkgPT09IDA7XG59XG5cbmV4cG9ydCB7IFNBTUxBdXRoUHJvdmlkZXIgYXMgJCwgQWN0aW9uQ29kZU9wZXJhdGlvbiBhcyBBLCB1c2VEZXZpY2VMYW5ndWFnZSBhcyBCLCB1cGRhdGVDdXJyZW50VXNlciBhcyBDLCBzaWduT3V0IGFzIEQsIHJldm9rZUFjY2Vzc1Rva2VuIGFzIEUsIEZhY3RvcklkIGFzIEYsIGRlbGV0ZVVzZXIgYXMgRywgZGVidWdFcnJvck1hcCBhcyBILCBwcm9kRXJyb3JNYXAgYXMgSSwgQVVUSF9FUlJPUl9DT0RFU19NQVBfRE9fTk9UX1VTRV9JTlRFUk5BTExZIGFzIEosIGluaXRpYWxpemVBdXRoIGFzIEssIGNvbm5lY3RBdXRoRW11bGF0b3IgYXMgTCwgQXV0aENyZWRlbnRpYWwgYXMgTSwgRW1haWxBdXRoQ3JlZGVudGlhbCBhcyBOLCBPcGVyYXRpb25UeXBlIGFzIE8sIFBob25lQXV0aFByb3ZpZGVyIGFzIFAsIE9BdXRoQ3JlZGVudGlhbCBhcyBRLCBSZWNhcHRjaGFWZXJpZmllciBhcyBSLCBTaWduSW5NZXRob2QgYXMgUywgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIFQsIFBob25lQXV0aENyZWRlbnRpYWwgYXMgVSwgaW5NZW1vcnlQZXJzaXN0ZW5jZSBhcyBWLCBFbWFpbEF1dGhQcm92aWRlciBhcyBXLCBGYWNlYm9va0F1dGhQcm92aWRlciBhcyBYLCBHb29nbGVBdXRoUHJvdmlkZXIgYXMgWSwgR2l0aHViQXV0aFByb3ZpZGVyIGFzIFosIE9BdXRoUHJvdmlkZXIgYXMgXywgYnJvd3NlckNvb2tpZVBlcnNpc3RlbmNlIGFzIGEsIFR3aXR0ZXJBdXRoUHJvdmlkZXIgYXMgYTAsIHNpZ25JbkFub255bW91c2x5IGFzIGExLCBzaWduSW5XaXRoQ3JlZGVudGlhbCBhcyBhMiwgbGlua1dpdGhDcmVkZW50aWFsIGFzIGEzLCByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsIGFzIGE0LCBzaWduSW5XaXRoQ3VzdG9tVG9rZW4gYXMgYTUsIHNlbmRQYXNzd29yZFJlc2V0RW1haWwgYXMgYTYsIGNvbmZpcm1QYXNzd29yZFJlc2V0IGFzIGE3LCBhcHBseUFjdGlvbkNvZGUgYXMgYTgsIGNoZWNrQWN0aW9uQ29kZSBhcyBhOSwgc2lnbkluV2l0aElkcCBhcyBhQSwgX2ZhaWwgYXMgYUIsIGRlYnVnQXNzZXJ0IGFzIGFDLCBfcGVyc2lzdGVuY2VLZXlOYW1lIGFzIGFELCBfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciBhcyBhRSwgX2Nhc3RBdXRoIGFzIGFGLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgYXMgYUcsIEJhc2VPQXV0aFByb3ZpZGVyIGFzIGFILCBfZW11bGF0b3JVcmwgYXMgYUksIF9wZXJmb3JtQXBpUmVxdWVzdCBhcyBhSiwgX2lzSU9TIGFzIGFLLCBfaXNBbmRyb2lkIGFzIGFMLCBfaXNJT1M3T3I4IGFzIGFNLCBfY3JlYXRlRXJyb3IgYXMgYU4sIF9pc01vYmlsZUJyb3dzZXIgYXMgYU8sIF9pc0lFMTAgYXMgYVAsIFVzZXJJbXBsIGFzIGFRLCBBdXRoSW1wbCBhcyBhUiwgX2dldENsaWVudFZlcnNpb24gYXMgYVMsIEZldGNoUHJvdmlkZXIgYXMgYVQsIFNBTUxBdXRoQ3JlZGVudGlhbCBhcyBhVSwgdmVyaWZ5UGFzc3dvcmRSZXNldENvZGUgYXMgYWEsIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYiwgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQgYXMgYWMsIHNlbmRTaWduSW5MaW5rVG9FbWFpbCBhcyBhZCwgaXNTaWduSW5XaXRoRW1haWxMaW5rIGFzIGFlLCBzaWduSW5XaXRoRW1haWxMaW5rIGFzIGFmLCBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCBhcyBhZywgc2VuZEVtYWlsVmVyaWZpY2F0aW9uIGFzIGFoLCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCBhcyBhaSwgQWN0aW9uQ29kZVVSTCBhcyBhaiwgcGFyc2VBY3Rpb25Db2RlVVJMIGFzIGFrLCB1cGRhdGVQcm9maWxlIGFzIGFsLCB1cGRhdGVFbWFpbCBhcyBhbSwgdXBkYXRlUGFzc3dvcmQgYXMgYW4sIGdldElkVG9rZW4gYXMgYW8sIGdldElkVG9rZW5SZXN1bHQgYXMgYXAsIHVubGluayBhcyBhcSwgZ2V0QWRkaXRpb25hbFVzZXJJbmZvIGFzIGFyLCByZWxvYWQgYXMgYXMsIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIgYXMgYXQsIG11bHRpRmFjdG9yIGFzIGF1LCBfZ2V0SW5zdGFuY2UgYXMgYXYsIF9hc3NlcnQgYXMgYXcsIF9zaWduSW5XaXRoQ3JlZGVudGlhbCBhcyBheCwgX3JlYXV0aGVudGljYXRlIGFzIGF5LCBfbGluayBhcyBheiwgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UgYXMgYiwgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSBhcyBjLCBzaWduSW5XaXRoUG9wdXAgYXMgZCwgbGlua1dpdGhQb3B1cCBhcyBlLCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCBhcyBmLCBzaWduSW5XaXRoUmVkaXJlY3QgYXMgZywgbGlua1dpdGhSZWRpcmVjdCBhcyBoLCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGFzIGksIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0IGFzIGosIGdldFJlZGlyZWN0UmVzdWx0IGFzIGssIGxpbmtXaXRoUGhvbmVOdW1iZXIgYXMgbCwgYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciBhcyBtLCBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIG4sIFRvdHBTZWNyZXQgYXMgbywgZ2V0QXV0aCBhcyBwLCBQcm92aWRlcklkIGFzIHEsIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIGFzIHIsIHNpZ25JbldpdGhQaG9uZU51bWJlciBhcyBzLCBzZXRQZXJzaXN0ZW5jZSBhcyB0LCB1cGRhdGVQaG9uZU51bWJlciBhcyB1LCBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIGFzIHYsIHZhbGlkYXRlUGFzc3dvcmQgYXMgdywgb25JZFRva2VuQ2hhbmdlZCBhcyB4LCBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIGFzIHksIG9uQXV0aFN0YXRlQ2hhbmdlZCBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3RwLTE4MTM3NDMzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/firebase/node_modules/@firebase/auth/dist/node-esm/totp-18137433.js\n");

/***/ })

};
;